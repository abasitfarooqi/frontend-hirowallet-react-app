{"version":3,"file":"structuredData.esm.js","sources":["../../src/signature/structuredData.ts"],"sourcesContent":["import { bytesToHex } from '@stacks/common';\nimport { serializeCV } from '@stacks/transactions';\nimport { createUnsecuredToken, TokenSigner } from 'jsontokens';\nimport { getDefaultSignatureRequestOptions } from '.';\nimport { getKeys, hasAppPrivateKey } from '../transactions';\nimport {\n  StructuredDataSignatureOptions,\n  StructuredDataSignaturePayload,\n  StructuredDataSignaturePopup,\n  StructuredDataSignatureRequestOptions,\n} from '../types/structuredDataSignature';\nimport { getStacksProvider } from '../utils';\n\nasync function generateTokenAndOpenPopup<T extends StructuredDataSignatureOptions>(\n  options: T,\n  makeTokenFn: (options: T) => Promise<string>\n) {\n  const token = await makeTokenFn({\n    ...getDefaultSignatureRequestOptions(options),\n    ...options,\n  } as T);\n  return openStructuredDataSignaturePopup({ token, options });\n}\n\nfunction parseUnserializableBigIntValues(payload: any) {\n  return {\n    ...payload,\n    message: bytesToHex(serializeCV(payload.message)),\n    domain: bytesToHex(serializeCV(payload.domain)),\n  };\n}\n\n// eslint-disable-next-line @typescript-eslint/require-await\nasync function signPayload(payload: StructuredDataSignaturePayload, privateKey: string) {\n  const tokenSigner = new TokenSigner('ES256k', privateKey);\n  return tokenSigner.signAsync(parseUnserializableBigIntValues(payload));\n}\n\n// eslint-disable-next-line @typescript-eslint/require-await\nexport async function signStructuredMessage(options: StructuredDataSignatureRequestOptions) {\n  const { userSession, ..._options } = options;\n  if (hasAppPrivateKey(userSession)) {\n    const { privateKey, publicKey } = getKeys(userSession);\n    const payload: StructuredDataSignaturePayload = {\n      ..._options,\n      publicKey,\n    };\n    return signPayload(payload, privateKey);\n  }\n  // Type casting `any` as payload contains non-serialisable content,\n  // such as `StacksNetwork`\n  return createUnsecuredToken(parseUnserializableBigIntValues(options));\n}\n\nasync function openStructuredDataSignaturePopup({ token, options }: StructuredDataSignaturePopup) {\n  const provider = getStacksProvider();\n  if (!provider) {\n    throw new Error('Hiro Wallet not installed.');\n  }\n\n  try {\n    const signatureResponse = await provider.structuredDataSignatureRequest(token);\n\n    options.onFinish?.(signatureResponse);\n  } catch (error) {\n    console.error('[Connect] Error during signature request', error);\n    options.onCancel?.();\n  }\n}\n\nexport function openStructuredDataSignatureRequestPopup(\n  options: StructuredDataSignatureRequestOptions\n) {\n  return generateTokenAndOpenPopup(options, signStructuredMessage);\n}\n"],"names":["options","makeTokenFn","getDefaultSignatureRequestOptions","token","openStructuredDataSignaturePopup","payload","message","bytesToHex","serializeCV","domain","privateKey","tokenSigner","TokenSigner","signAsync","parseUnserializableBigIntValues","userSession","_options","hasAppPrivateKey","getKeys","publicKey","signPayload","createUnsecuredToken","provider","getStacksProvider","Error","structuredDataSignatureRequest","signatureResponse","onFinish","error","onCancel","generateTokenAndOpenPopup","signStructuredMessage"],"mappings":";;;;;;;;;;;;;0FAaA,iBACEA,SACAC;;;;;;iBAEoBA,yBACfC,kCAAkCF,UAClCA;;UAFCG;2CAICC,iCAAiC;YAAED,OAAAA;YAAOH,SAAAA;;;;;;;;;;AAGnD,yCAAyCK,SAAc;sBAEhDA;IACHC,SAASC,WAAWC,YAAYH,QAAQC;IACxCG,QAAQF,WAAWC,YAAYH,QAAQI;;AAAA;;;;;4EAK3C,kBAA2BJ,SAAyCK;;;;;UAC5DC,cAAc,IAAIC,YAAY,UAAUF;4CACvCC,YAAYE,UAAUC,gCAAgCT;;;;;;;;;;;;;wGAInBL;;;;;UAClCe,cAA6Bf,QAA7Be,aAAgBC,yCAAahB;eACjCiB,iBAAiBF;;;;qBACeG,QAAQH,cAAlCL,sBAAAA,YAAYS,qBAAAA;UACdd,uBACDW;YACHG,WAAAA;;4CAEKC,YAAYf,SAASK;;4CAIvBW,qBAAqBP,gCAAgCd;;;;;;;;;;;;;iGAG9D;IAAA;IAAA;MAAA;QAAA;UAAkDG,aAAAA,OAAOH,eAAAA;UACjDsB,WAAWC;cACZD;;;;gBACG,IAAIE,MAAM;;;;iBAIgBF,SAASG,+BAA+BtB;;UAAlEuB;kBAEEC,oCAAAA,SAAWD;;;;;;kBAEXE,MAAM;kBACNC,oCAAAA;;;;;;;;;iDAKV7B,SACA;SACO8B,0BAA0B9B,SAAS+B;AAAA;;;;"}