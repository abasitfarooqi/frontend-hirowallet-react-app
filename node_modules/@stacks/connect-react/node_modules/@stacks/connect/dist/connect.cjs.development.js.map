{"version":3,"file":"connect.cjs.development.js","sources":["../src/utils.ts","../src/auth.ts","../src/types/transactions.ts","../src/transactions/index.ts","../src/signature/index.ts","../src/signature/structuredData.ts","../src/profile/index.ts","../src/ui.ts"],"sourcesContent":["export function getStacksProvider() {\n  return window.StacksProvider || window.BlockstackProvider;\n}\n\nexport function isStacksWalletInstalled() {\n  return !!getStacksProvider();\n}\n","import { AppConfig, UserSession } from '@stacks/auth';\nimport { decodeToken } from 'jsontokens';\nimport type { AuthOptions, AuthResponsePayload } from './types';\n\nimport { getStacksProvider } from './utils';\n\nexport const defaultAuthURL = 'https://app.blockstack.org';\n\nconst version = __VERSION__;\n\nif (typeof window !== 'undefined') {\n  window.__CONNECT_VERSION__ = version;\n}\n\nexport const isMobile = () => {\n  const ua = navigator.userAgent;\n  if (/android/i.test(ua)) {\n    return true;\n  }\n  if (/iPad|iPhone|iPod/.test(ua)) {\n    return true;\n  }\n  return /windows phone/i.test(ua);\n};\n\n/**\n * mobile should not use a 'popup' type of window.\n */\nexport const shouldUsePopup = () => {\n  return !isMobile();\n};\n\nexport const getOrCreateUserSession = (userSession?: UserSession): UserSession => {\n  if (!userSession) {\n    const appConfig = new AppConfig(['store_write'], document.location.href);\n    userSession = new UserSession({ appConfig });\n  }\n  return userSession;\n};\n\nexport const authenticate = async (authOptions: AuthOptions) => {\n  const provider = getStacksProvider();\n  if (!provider) {\n    throw new Error('Unable to authenticate without Hiro Wallet extension');\n  }\n\n  const {\n    redirectTo = '/',\n    manifestPath,\n    onFinish,\n    onCancel,\n    sendToSignIn = false,\n    userSession: _userSession,\n    appDetails,\n  } = authOptions;\n  const userSession = getOrCreateUserSession(_userSession);\n  if (userSession.isUserSignedIn()) {\n    userSession.signUserOut();\n  }\n  const transitKey = userSession.generateAndStoreTransitKey();\n  const authRequest = userSession.makeAuthRequest(\n    transitKey,\n    `${document.location.origin}${redirectTo}`,\n    `${document.location.origin}${manifestPath}`,\n    userSession.appConfig.scopes,\n    undefined,\n    undefined,\n    {\n      sendToSignIn,\n      appDetails,\n      connectVersion: version,\n    }\n  );\n\n  try {\n    const authResponse = await provider.authenticationRequest(authRequest);\n    await userSession.handlePendingSignIn(authResponse);\n    const token = decodeToken(authResponse);\n    const payload = token?.payload;\n    const authResponsePayload = payload as unknown as AuthResponsePayload;\n    onFinish?.({\n      authResponse,\n      authResponsePayload,\n      userSession,\n    });\n  } catch (error) {\n    console.error('[Connect] Error during auth request', error);\n    onCancel?.();\n  }\n};\n\n// eslint-disable-next-line @typescript-eslint/require-await\nexport const getUserData = async (userSession?: UserSession) => {\n  userSession = getOrCreateUserSession(userSession);\n  if (userSession.isUserSignedIn()) {\n    return userSession.loadUserData();\n  }\n  if (userSession.isSignInPending()) {\n    return userSession.handlePendingSignIn();\n  }\n  return null;\n};\n","import { UserSession } from '@stacks/auth';\nimport type { AuthOptions } from '../types/auth';\nimport {\n  PostConditionMode,\n  PostCondition,\n  AnchorMode,\n  ClarityValue,\n  StacksTransaction,\n} from '@stacks/transactions';\nimport { StacksNetwork } from '@stacks/network';\n\nexport interface TxBase {\n  appDetails?: AuthOptions['appDetails'];\n  postConditionMode?: PostConditionMode;\n  postConditions?: (string | PostCondition)[];\n  network?: StacksNetwork;\n  anchorMode?: AnchorMode;\n  attachment?: string;\n  fee?: number | string;\n  /**\n   * Provide the Hiro Wallet with a suggested account to sign this transaction with.\n   * This is set by default if a `userSession` option is provided.\n   */\n  stxAddress?: string;\n  /** @deprecated `unused - only included for compatibility with @stacks/transactions` */\n  senderKey?: string;\n  /** @deprecated `unused - only included for compatibility with @stacks/transactions` */\n  nonce?: number;\n}\n\nexport interface SponsoredFinishedTxPayload {\n  txRaw: string;\n}\n\nexport interface SponsoredFinishedTxData extends SponsoredFinishedTxPayload {\n  stacksTransaction: StacksTransaction;\n}\n\nexport interface FinishedTxPayload extends SponsoredFinishedTxPayload {\n  txId: string;\n}\n\nexport interface FinishedTxData extends FinishedTxPayload {\n  stacksTransaction: StacksTransaction;\n}\n\nexport enum TransactionTypes {\n  ContractCall = 'contract_call',\n  ContractDeploy = 'smart_contract',\n  STXTransfer = 'token_transfer',\n}\n\n/**\n * Contract Call\n */\n\nexport enum ContractCallArgumentType {\n  BUFFER = 'buffer',\n  UINT = 'uint',\n  INT = 'int',\n  PRINCIPAL = 'principal',\n  BOOL = 'bool',\n}\n\nexport interface ContractCallBase extends TxBase {\n  contractAddress: string;\n  contractName: string;\n  functionName: string;\n  functionArgs: (string | ClarityValue)[];\n}\n\nexport interface OptionsBase {\n  /**\n   * @deprecated Authentication is no longer supported through a hosted\n   * version. Users must install an extension.\n   */\n  authOrigin?: string;\n  userSession?: UserSession;\n}\n\nexport type SponsoredFinished = (data: SponsoredFinishedTxData) => void;\nexport type Finished = (data: FinishedTxData) => void;\nexport type Canceled = () => void;\n\nexport interface SponsoredOptionsBase extends TxBase, OptionsBase {\n  sponsored: true;\n  onFinish?: SponsoredFinished;\n  onCancel?: Canceled;\n}\n\nexport interface RegularOptionsBase extends TxBase, OptionsBase {\n  sponsored?: false;\n  onFinish?: Finished;\n  onCancel?: Canceled;\n}\n\nexport type ContractCallRegularOptions = ContractCallBase & RegularOptionsBase;\nexport type ContractCallSponsoredOptions = ContractCallBase & SponsoredOptionsBase;\nexport type ContractCallOptions = ContractCallRegularOptions | ContractCallSponsoredOptions;\n\nexport interface ContractCallArgument {\n  type: ContractCallArgumentType;\n  value: string;\n}\n\nexport interface ContractCallPayload extends ContractCallBase {\n  txType: TransactionTypes.ContractCall;\n  publicKey: string;\n  functionArgs: string[];\n  sponsored?: boolean;\n}\n\n/**\n * Contract Deploy\n */\nexport interface ContractDeployBase extends TxBase {\n  contractName: string;\n  codeBody: string;\n}\n\nexport type ContractDeployRegularOptions = ContractDeployBase & RegularOptionsBase;\nexport type ContractDeploySponsoredOptions = ContractDeployBase & SponsoredOptionsBase;\nexport type ContractDeployOptions = ContractDeployRegularOptions | ContractDeploySponsoredOptions;\n\nexport interface ContractDeployPayload extends ContractDeployBase {\n  publicKey: string;\n  txType: TransactionTypes.ContractDeploy;\n  sponsored?: boolean;\n}\n\n/**\n * STX Transfer\n */\n\nexport interface STXTransferBase extends TxBase {\n  recipient: string;\n  amount: BigInt | string;\n  memo?: string;\n}\n\nexport type STXTransferRegularOptions = STXTransferBase & RegularOptionsBase;\nexport type STXTransferSponsoredOptions = STXTransferBase & SponsoredOptionsBase;\nexport type STXTransferOptions = STXTransferRegularOptions | STXTransferSponsoredOptions;\n\nexport interface STXTransferPayload extends STXTransferBase {\n  publicKey: string;\n  txType: TransactionTypes.STXTransfer;\n  amount: string;\n  sponsored?: boolean;\n}\n\n/**\n * Transaction Popup\n */\n\nexport type TransactionOptions = ContractCallOptions | ContractDeployOptions | STXTransferOptions;\nexport type TransactionPayload = ContractCallPayload | ContractDeployPayload | STXTransferPayload;\n\nexport interface TransactionPopup {\n  token: string;\n  options: TransactionOptions;\n}\n","import { AppConfig, UserSession } from '@stacks/auth';\nimport { bytesToHex, hexToBytes } from '@stacks/common';\nimport { StacksTestnet } from '@stacks/network';\nimport {\n  ChainID,\n  deserializeTransaction,\n  PostCondition,\n  serializeCV,\n  serializePostCondition,\n} from '@stacks/transactions';\nimport { createUnsecuredToken, Json, SECP256K1Client, TokenSigner } from 'jsontokens';\nimport {\n  ContractCallOptions,\n  ContractCallPayload,\n  ContractCallRegularOptions,\n  ContractCallSponsoredOptions,\n  ContractDeployOptions,\n  ContractDeployPayload,\n  ContractDeployRegularOptions,\n  ContractDeploySponsoredOptions,\n  FinishedTxPayload,\n  SponsoredFinishedTxPayload,\n  STXTransferOptions,\n  STXTransferPayload,\n  STXTransferRegularOptions,\n  STXTransferSponsoredOptions,\n  TransactionOptions,\n  TransactionPayload,\n  TransactionPopup,\n  TransactionTypes,\n} from '../types/transactions';\nimport { getStacksProvider } from '../utils';\n\n// TODO extract out of transactions\nexport const getUserSession = (_userSession?: UserSession) => {\n  let userSession = _userSession;\n\n  if (!userSession) {\n    const appConfig = new AppConfig(['store_write'], document.location.href);\n    userSession = new UserSession({ appConfig });\n  }\n  return userSession;\n};\n\nexport function hasAppPrivateKey(userSession?: UserSession) {\n  try {\n    const session = getUserSession(userSession).loadUserData();\n    return session.appPrivateKey;\n  } catch (e) {\n    return false;\n  }\n}\n\nexport const getKeys = (_userSession?: UserSession) => {\n  const userSession = getUserSession(_userSession);\n  const privateKey = userSession.loadUserData().appPrivateKey;\n  const publicKey = SECP256K1Client.derivePublicKey(privateKey);\n\n  return { privateKey, publicKey };\n};\n\n// TODO extract out of transactions\nexport function getStxAddress(options: TransactionOptions) {\n  const { stxAddress, userSession, network } = options;\n\n  if (stxAddress) return stxAddress;\n  if (!userSession || !network) return undefined;\n  const stxAddresses = userSession?.loadUserData().profile?.stxAddress;\n  const chainIdToKey = {\n    [ChainID.Mainnet]: 'mainnet',\n    [ChainID.Testnet]: 'testnet',\n  };\n  const address: string | undefined = stxAddresses?.[chainIdToKey[network.chainId]];\n  return address;\n}\n\nfunction getDefaults(options: TransactionOptions) {\n  const network = options.network || new StacksTestnet();\n\n  const userSession = getUserSession(options.userSession);\n  const defaults: TransactionOptions = {\n    ...options,\n    network,\n    userSession,\n  };\n\n  return {\n    stxAddress: getStxAddress(defaults),\n    ...defaults,\n  };\n}\n\nfunction encodePostConditions(postConditions: PostCondition[]) {\n  return postConditions.map(pc => bytesToHex(serializePostCondition(pc)));\n}\n\n// eslint-disable-next-line @typescript-eslint/require-await\nasync function signPayload(payload: TransactionPayload, privateKey: string) {\n  let { postConditions } = payload;\n  if (postConditions && typeof postConditions[0] !== 'string') {\n    postConditions = encodePostConditions(postConditions as PostCondition[]);\n  }\n  const tokenSigner = new TokenSigner('ES256k', privateKey);\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n  return tokenSigner.signAsync({ ...payload, postConditions } as any);\n}\n\nfunction createUnsignedTransactionPayload(payload: Partial<TransactionPayload>) {\n  let { postConditions } = payload;\n  if (postConditions && typeof postConditions[0] !== 'string') {\n    postConditions = encodePostConditions(postConditions as PostCondition[]);\n  }\n  return createUnsecuredToken({ ...payload, postConditions } as unknown as Json);\n}\n\nconst openTransactionPopup = async ({ token, options }: TransactionPopup) => {\n  const provider = getStacksProvider();\n  if (!provider) {\n    throw new Error('Hiro Wallet not installed');\n  }\n\n  try {\n    const txResponse = await provider.transactionRequest(token);\n    const { txRaw } = txResponse;\n    const txBytes = hexToBytes(txRaw.replace(/^0x/, ''));\n    const stacksTransaction = deserializeTransaction(txBytes);\n\n    if ('sponsored' in options && options.sponsored) {\n      options.onFinish?.({\n        ...(txResponse as SponsoredFinishedTxPayload),\n        stacksTransaction,\n      });\n      return;\n    }\n    options.onFinish?.({\n      ...(txResponse as FinishedTxPayload),\n      stacksTransaction,\n    });\n  } catch (error) {\n    console.error('[Connect] Error during transaction request', error);\n    options.onCancel?.();\n  }\n};\n\n// eslint-disable-next-line @typescript-eslint/require-await\nexport const makeContractCallToken = async (options: ContractCallOptions) => {\n  const { functionArgs, appDetails, userSession, ..._options } = options;\n\n  const args: string[] = functionArgs.map(arg => {\n    if (typeof arg === 'string') {\n      return arg;\n    }\n    return bytesToHex(serializeCV(arg));\n  });\n  if (hasAppPrivateKey(userSession)) {\n    const { privateKey, publicKey } = getKeys(userSession);\n    const payload: ContractCallPayload = {\n      ..._options,\n      functionArgs: args,\n      txType: TransactionTypes.ContractCall,\n      publicKey,\n    };\n    if (appDetails) payload.appDetails = appDetails;\n    return signPayload(payload, privateKey);\n  }\n  const payload: Partial<ContractCallPayload> = {\n    ..._options,\n    functionArgs: args,\n    txType: TransactionTypes.ContractCall,\n  };\n  if (appDetails) payload.appDetails = appDetails;\n  return createUnsignedTransactionPayload(payload);\n};\n\n// eslint-disable-next-line @typescript-eslint/require-await\nexport const makeContractDeployToken = async (options: ContractDeployOptions) => {\n  const { appDetails, userSession, ..._options } = options;\n  if (hasAppPrivateKey(userSession)) {\n    const { privateKey, publicKey } = getKeys(userSession);\n    const payload: ContractDeployPayload = {\n      ..._options,\n      publicKey,\n      txType: TransactionTypes.ContractDeploy,\n    };\n    if (appDetails) payload.appDetails = appDetails;\n    return signPayload(payload, privateKey);\n  }\n\n  const payload: Partial<ContractDeployPayload> = {\n    ..._options,\n    txType: TransactionTypes.ContractDeploy,\n  };\n  if (appDetails) payload.appDetails = appDetails;\n  return createUnsignedTransactionPayload(payload);\n};\n\n// eslint-disable-next-line @typescript-eslint/require-await\nexport const makeSTXTransferToken = async (options: STXTransferOptions) => {\n  const { amount, appDetails, userSession, ..._options } = options;\n\n  if (hasAppPrivateKey(userSession)) {\n    const { privateKey, publicKey } = getKeys(userSession);\n    const payload: STXTransferPayload = {\n      ..._options,\n      amount: amount.toString(10),\n      publicKey,\n      txType: TransactionTypes.STXTransfer,\n    };\n    if (appDetails) payload.appDetails = appDetails;\n    return signPayload(payload, privateKey);\n  }\n\n  const payload: Partial<STXTransferPayload> = {\n    ..._options,\n    amount: amount.toString(10),\n    txType: TransactionTypes.STXTransfer,\n  };\n  if (appDetails) payload.appDetails = appDetails;\n  return createUnsignedTransactionPayload(payload);\n};\n\nasync function generateTokenAndOpenPopup<T extends TransactionOptions>(\n  options: T,\n  makeTokenFn: (options: T) => Promise<string>\n) {\n  const token = await makeTokenFn({\n    ...getDefaults(options),\n    ...options,\n  } as T);\n  return openTransactionPopup({ token, options });\n}\n\nexport function openContractCall(options: ContractCallRegularOptions): Promise<void>;\nexport function openContractCall(options: ContractCallSponsoredOptions): Promise<void>;\nexport function openContractCall(options: ContractCallOptions): Promise<void>;\nexport function openContractCall(options: ContractCallOptions) {\n  return generateTokenAndOpenPopup(options, makeContractCallToken);\n}\n\nexport function openContractDeploy(options: ContractDeployRegularOptions): Promise<void>;\nexport function openContractDeploy(options: ContractDeploySponsoredOptions): Promise<void>;\nexport function openContractDeploy(options: ContractDeployOptions): Promise<void>;\nexport function openContractDeploy(options: ContractDeployOptions) {\n  return generateTokenAndOpenPopup(options, makeContractDeployToken);\n}\n\nexport function openSTXTransfer(options: STXTransferRegularOptions): Promise<void>;\nexport function openSTXTransfer(options: STXTransferSponsoredOptions): Promise<void>;\nexport function openSTXTransfer(options: STXTransferOptions): Promise<void>;\nexport function openSTXTransfer(options: STXTransferOptions) {\n  return generateTokenAndOpenPopup(options, makeSTXTransferToken);\n}\n","import { StacksTestnet } from '@stacks/network';\nimport { ChainID } from '@stacks/transactions';\nimport { createUnsecuredToken, TokenSigner } from 'jsontokens';\nimport { getKeys, getUserSession, hasAppPrivateKey } from '../transactions';\nimport {\n  CommonSignatureRequestOptions,\n  SignatureOptions,\n  SignaturePayload,\n  SignaturePopup,\n  SignatureRequestOptions,\n} from '../types/signature';\nimport { getStacksProvider } from '../utils';\n\nfunction getStxAddress(options: CommonSignatureRequestOptions) {\n  const { userSession, network } = options;\n\n  if (!userSession || !network) return undefined;\n  const stxAddresses = userSession?.loadUserData().profile?.stxAddress;\n  const chainIdToKey = {\n    [ChainID.Mainnet]: 'mainnet',\n    [ChainID.Testnet]: 'testnet',\n  };\n  const address: string | undefined = stxAddresses?.[chainIdToKey[network.chainId]];\n  return address;\n}\n\n// eslint-disable-next-line @typescript-eslint/require-await\nasync function signPayload(payload: SignaturePayload, privateKey: string) {\n  const tokenSigner = new TokenSigner('ES256k', privateKey);\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n  return tokenSigner.signAsync({ ...payload } as any);\n}\n\nexport function getDefaultSignatureRequestOptions(options: CommonSignatureRequestOptions) {\n  const network = options.network || new StacksTestnet();\n  const userSession = getUserSession(options.userSession);\n  const defaults: CommonSignatureRequestOptions = {\n    ...options,\n    network,\n    userSession,\n  };\n  return {\n    stxAddress: getStxAddress(defaults),\n    ...defaults,\n  };\n}\n\nasync function openSignaturePopup({ token, options }: SignaturePopup) {\n  const provider = getStacksProvider();\n  if (!provider) {\n    throw new Error('Hiro Wallet not installed.');\n  }\n\n  try {\n    const signatureResponse = await provider.signatureRequest(token);\n    options.onFinish?.(signatureResponse);\n  } catch (error) {\n    console.error('[Connect] Error during signature request', error);\n    options.onCancel?.();\n  }\n}\n\nexport interface SignatureRequestPayload {\n  message: string;\n}\n\n// eslint-disable-next-line @typescript-eslint/require-await\nexport const signMessage = async (options: SignatureRequestOptions) => {\n  const { userSession, ..._options } = options;\n  if (hasAppPrivateKey(userSession)) {\n    const { privateKey, publicKey } = getKeys(userSession);\n\n    const payload: SignaturePayload = {\n      ..._options,\n      publicKey,\n    };\n\n    return signPayload(payload, privateKey);\n  }\n  const payload = { ..._options };\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n  return createUnsecuredToken(payload as any);\n};\n\nasync function generateTokenAndOpenPopup<T extends SignatureOptions>(\n  options: T,\n  makeTokenFn: (options: T) => Promise<string>\n) {\n  const token = await makeTokenFn({\n    ...getDefaultSignatureRequestOptions(options),\n    ...options,\n  } as T);\n  return openSignaturePopup({ token, options });\n}\n\nexport function openSignatureRequestPopup(options: SignatureRequestOptions) {\n  return generateTokenAndOpenPopup(options, signMessage);\n}\n","import { bytesToHex } from '@stacks/common';\nimport { serializeCV } from '@stacks/transactions';\nimport { createUnsecuredToken, TokenSigner } from 'jsontokens';\nimport { getDefaultSignatureRequestOptions } from '.';\nimport { getKeys, hasAppPrivateKey } from '../transactions';\nimport {\n  StructuredDataSignatureOptions,\n  StructuredDataSignaturePayload,\n  StructuredDataSignaturePopup,\n  StructuredDataSignatureRequestOptions,\n} from '../types/structuredDataSignature';\nimport { getStacksProvider } from '../utils';\n\nasync function generateTokenAndOpenPopup<T extends StructuredDataSignatureOptions>(\n  options: T,\n  makeTokenFn: (options: T) => Promise<string>\n) {\n  const token = await makeTokenFn({\n    ...getDefaultSignatureRequestOptions(options),\n    ...options,\n  } as T);\n  return openStructuredDataSignaturePopup({ token, options });\n}\n\nfunction parseUnserializableBigIntValues(payload: any) {\n  return {\n    ...payload,\n    message: bytesToHex(serializeCV(payload.message)),\n    domain: bytesToHex(serializeCV(payload.domain)),\n  };\n}\n\n// eslint-disable-next-line @typescript-eslint/require-await\nasync function signPayload(payload: StructuredDataSignaturePayload, privateKey: string) {\n  const tokenSigner = new TokenSigner('ES256k', privateKey);\n  return tokenSigner.signAsync(parseUnserializableBigIntValues(payload));\n}\n\n// eslint-disable-next-line @typescript-eslint/require-await\nexport async function signStructuredMessage(options: StructuredDataSignatureRequestOptions) {\n  const { userSession, ..._options } = options;\n  if (hasAppPrivateKey(userSession)) {\n    const { privateKey, publicKey } = getKeys(userSession);\n    const payload: StructuredDataSignaturePayload = {\n      ..._options,\n      publicKey,\n    };\n    return signPayload(payload, privateKey);\n  }\n  // Type casting `any` as payload contains non-serialisable content,\n  // such as `StacksNetwork`\n  return createUnsecuredToken(parseUnserializableBigIntValues(options));\n}\n\nasync function openStructuredDataSignaturePopup({ token, options }: StructuredDataSignaturePopup) {\n  const provider = getStacksProvider();\n  if (!provider) {\n    throw new Error('Hiro Wallet not installed.');\n  }\n\n  try {\n    const signatureResponse = await provider.structuredDataSignatureRequest(token);\n\n    options.onFinish?.(signatureResponse);\n  } catch (error) {\n    console.error('[Connect] Error during signature request', error);\n    options.onCancel?.();\n  }\n}\n\nexport function openStructuredDataSignatureRequestPopup(\n  options: StructuredDataSignatureRequestOptions\n) {\n  return generateTokenAndOpenPopup(options, signStructuredMessage);\n}\n","import { StacksTestnet } from '@stacks/network';\nimport { createUnsecuredToken, Json, TokenSigner } from 'jsontokens';\nimport { getKeys, getUserSession, hasAppPrivateKey } from '../transactions';\nimport { ProfileUpdatePayload, ProfileUpdatePopup, ProfileUpdateRequestOptions } from '../types';\n\nimport { getStacksProvider } from '../utils';\n\n// eslint-disable-next-line @typescript-eslint/require-await\nasync function signPayload(payload: ProfileUpdatePayload, privateKey: string) {\n  const tokenSigner = new TokenSigner('ES256k', privateKey);\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n  return tokenSigner.signAsync({ ...payload } as any);\n}\n\nexport function getDefaultProfileUpdateRequestOptions(options: ProfileUpdateRequestOptions) {\n  const network = options.network || new StacksTestnet();\n  const userSession = getUserSession(options.userSession);\n  const defaults: ProfileUpdateRequestOptions = {\n    ...options,\n    network,\n    userSession,\n  };\n  return {\n    ...defaults,\n  };\n}\n\nasync function openProfileUpdatePopup({ token, options }: ProfileUpdatePopup) {\n  const provider = getStacksProvider();\n  if (!provider) {\n    throw new Error('Hiro Wallet not installed.');\n  }\n\n  try {\n    const profileUpdateResponse = await provider.profileUpdateRequest(token);\n    options.onFinish?.(profileUpdateResponse);\n  } catch (error) {\n    console.error('[Connect] Error during signature request', error);\n    options.onCancel?.();\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/require-await\nexport const makeProfileUpdateToken = async (options: ProfileUpdateRequestOptions) => {\n  const { userSession, profile, ..._options } = options;\n  if (hasAppPrivateKey(userSession)) {\n    const { privateKey, publicKey } = getKeys(userSession);\n\n    const payload: ProfileUpdatePayload = {\n      ..._options,\n      profile,\n      publicKey,\n    };\n\n    return signPayload(payload, privateKey);\n  }\n  const payload = { ..._options };\n  return createUnsecuredToken(payload as Json);\n};\n\nasync function generateTokenAndOpenPopup<T extends ProfileUpdateRequestOptions>(\n  options: T,\n  makeTokenFn: (options: T) => Promise<string>\n) {\n  const token = await makeTokenFn({\n    ...getDefaultProfileUpdateRequestOptions(options),\n    ...options,\n  } as T);\n  return openProfileUpdatePopup({ token, options });\n}\n\nexport function openProfileUpdateRequestPopup(options: ProfileUpdateRequestOptions) {\n  return generateTokenAndOpenPopup(options, makeProfileUpdateToken);\n}\n","import { authenticate } from './auth';\nimport type { AuthOptions } from './types/auth';\nimport { defineCustomElements } from '@stacks/connect-ui/loader';\nimport { getStacksProvider } from './utils';\n\nexport const showConnect = (authOptions: AuthOptions) => {\n  if (getStacksProvider()) {\n    void authenticate(authOptions);\n    return;\n  }\n  if (typeof window !== undefined) {\n    void defineCustomElements(window);\n    const element = document.createElement('connect-modal');\n    element.authOptions = authOptions;\n    document.body.appendChild(element);\n    const handleEsc = (ev: KeyboardEvent) => {\n      if (ev.key === 'Escape') {\n        document.removeEventListener('keydown', handleEsc);\n        element.remove();\n      }\n    };\n    document.addEventListener('keydown', handleEsc);\n  }\n};\n\n/**\n * @deprecated Use the renamed `showConnect` method\n */\nexport const showBlockstackConnect = (authOptions: AuthOptions) => showConnect(authOptions);\n"],"names":["window","StacksProvider","BlockstackProvider","getStacksProvider","defaultAuthURL","version","__VERSION__","__CONNECT_VERSION__","isMobile","ua","navigator","userAgent","test","shouldUsePopup","getOrCreateUserSession","userSession","appConfig","AppConfig","document","location","href","UserSession","authenticate","authOptions","provider","Error","redirectTo","manifestPath","onFinish","onCancel","sendToSignIn","_userSession","appDetails","isUserSignedIn","signUserOut","transitKey","generateAndStoreTransitKey","authRequest","makeAuthRequest","origin","scopes","connectVersion","authenticationRequest","authResponse","handlePendingSignIn","token","decodeToken","payload","authResponsePayload","error","getUserData","loadUserData","isSignInPending","TransactionTypes2","TransactionTypes","ContractCallArgumentType2","ContractCallArgumentType","getUserSession","session","appPrivateKey","e","getKeys","privateKey","publicKey","SECP256K1Client","derivePublicKey","options","stxAddress","network","stxAddresses","profile","chainIdToKey","ChainID","Mainnet","Testnet","address","chainId","StacksTestnet","defaults","getStxAddress","postConditions","map","bytesToHex","serializePostCondition","pc","encodePostConditions","tokenSigner","TokenSigner","signAsync","createUnsecuredToken","openTransactionPopup","transactionRequest","txResponse","txRaw","txBytes","hexToBytes","replace","stacksTransaction","deserializeTransaction","sponsored","makeContractCallToken","functionArgs","_options","args","arg","serializeCV","hasAppPrivateKey","payload2","txType","ContractCall","signPayload","createUnsignedTransactionPayload","makeContractDeployToken","ContractDeploy","makeSTXTransferToken","amount","toString","STXTransfer","makeTokenFn","getDefaults","generateTokenAndOpenPopup","signatureRequest","signatureResponse","signMessage","getDefaultSignatureRequestOptions","openSignaturePopup","openStructuredDataSignaturePopup","message","domain","parseUnserializableBigIntValues","structuredDataSignatureRequest","signStructuredMessage","profileUpdateRequest","profileUpdateResponse","makeProfileUpdateToken","getDefaultProfileUpdateRequestOptions","openProfileUpdatePopup","showConnect","defineCustomElements","element","createElement","body","appendChild","handleEsc","ev","key","removeEventListener","remove","addEventListener","showBlockstackConnect"],"mappings":"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"}