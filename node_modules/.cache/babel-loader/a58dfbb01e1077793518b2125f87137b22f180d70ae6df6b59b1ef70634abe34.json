{"ast":null,"code":"import { DeserializationError } from './errors';\nimport { PubKeyEncoding, RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, StacksMessageType } from './constants';\nimport { compressPublicKey, deserializePublicKey, serializePublicKey } from './keys';\nimport { createMessageSignature } from './common';\nimport { bytesToHex, concatArray, hexToBytes } from '@stacks/common';\nexport var AuthFieldType;\n(function (AuthFieldType) {\n  AuthFieldType[AuthFieldType[\"PublicKeyCompressed\"] = 0] = \"PublicKeyCompressed\";\n  AuthFieldType[AuthFieldType[\"PublicKeyUncompressed\"] = 1] = \"PublicKeyUncompressed\";\n  AuthFieldType[AuthFieldType[\"SignatureCompressed\"] = 2] = \"SignatureCompressed\";\n  AuthFieldType[AuthFieldType[\"SignatureUncompressed\"] = 3] = \"SignatureUncompressed\";\n})(AuthFieldType || (AuthFieldType = {}));\nexport function deserializeMessageSignature(bytesReader) {\n  return createMessageSignature(bytesToHex(bytesReader.readBytes(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES)));\n}\nexport function createTransactionAuthField(pubKeyEncoding, contents) {\n  return {\n    pubKeyEncoding,\n    type: StacksMessageType.TransactionAuthField,\n    contents\n  };\n}\nexport function deserializeTransactionAuthField(bytesReader) {\n  const authFieldType = bytesReader.readUInt8Enum(AuthFieldType, n => {\n    throw new DeserializationError(`Could not read ${n} as AuthFieldType`);\n  });\n  switch (authFieldType) {\n    case AuthFieldType.PublicKeyCompressed:\n      return createTransactionAuthField(PubKeyEncoding.Compressed, deserializePublicKey(bytesReader));\n    case AuthFieldType.PublicKeyUncompressed:\n      return createTransactionAuthField(PubKeyEncoding.Uncompressed, deserializePublicKey(bytesReader));\n    case AuthFieldType.SignatureCompressed:\n      return createTransactionAuthField(PubKeyEncoding.Compressed, deserializeMessageSignature(bytesReader));\n    case AuthFieldType.SignatureUncompressed:\n      return createTransactionAuthField(PubKeyEncoding.Uncompressed, deserializeMessageSignature(bytesReader));\n    default:\n      throw new Error(`Unknown auth field type: ${JSON.stringify(authFieldType)}`);\n  }\n}\nexport function serializeMessageSignature(messageSignature) {\n  return hexToBytes(messageSignature.data);\n}\nexport function serializeTransactionAuthField(field) {\n  const bytesArray = [];\n  switch (field.contents.type) {\n    case StacksMessageType.PublicKey:\n      if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n        bytesArray.push(AuthFieldType.PublicKeyCompressed);\n        bytesArray.push(serializePublicKey(field.contents));\n      } else {\n        bytesArray.push(AuthFieldType.PublicKeyUncompressed);\n        bytesArray.push(serializePublicKey(compressPublicKey(field.contents.data)));\n      }\n      break;\n    case StacksMessageType.MessageSignature:\n      if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n        bytesArray.push(AuthFieldType.SignatureCompressed);\n      } else {\n        bytesArray.push(AuthFieldType.SignatureUncompressed);\n      }\n      bytesArray.push(serializeMessageSignature(field.contents));\n      break;\n  }\n  return concatArray(bytesArray);\n}","map":{"version":3,"names":["DeserializationError","PubKeyEncoding","RECOVERABLE_ECDSA_SIG_LENGTH_BYTES","StacksMessageType","compressPublicKey","deserializePublicKey","serializePublicKey","createMessageSignature","bytesToHex","concatArray","hexToBytes","AuthFieldType","deserializeMessageSignature","bytesReader","readBytes","createTransactionAuthField","pubKeyEncoding","contents","type","TransactionAuthField","deserializeTransactionAuthField","authFieldType","readUInt8Enum","n","PublicKeyCompressed","Compressed","PublicKeyUncompressed","Uncompressed","SignatureCompressed","SignatureUncompressed","Error","JSON","stringify","serializeMessageSignature","messageSignature","data","serializeTransactionAuthField","field","bytesArray","PublicKey","push","MessageSignature"],"sources":["C:\\Users\\abasi\\Desktop\\web3-apps\\react-cra\\node_modules\\@stacks\\transactions\\src\\signature.ts"],"sourcesContent":["import { BytesReader } from './bytesReader';\nimport { DeserializationError } from './errors';\nimport { PubKeyEncoding, RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, StacksMessageType } from './constants';\nimport {\n  compressPublicKey,\n  deserializePublicKey,\n  serializePublicKey,\n  StacksPublicKey,\n} from './keys';\n\nimport { createMessageSignature, MessageSignature } from './common';\n\n// @ts-ignore\nimport { bytesToHex, concatArray, hexToBytes } from '@stacks/common';\n\nexport enum AuthFieldType {\n  PublicKeyCompressed = 0x00,\n  PublicKeyUncompressed = 0x01,\n  SignatureCompressed = 0x02,\n  SignatureUncompressed = 0x03,\n}\n\nexport interface TransactionAuthField {\n  type: StacksMessageType.TransactionAuthField;\n  pubKeyEncoding: PubKeyEncoding;\n  contents: TransactionAuthFieldContents;\n}\n\nexport type TransactionAuthFieldContents = StacksPublicKey | MessageSignature;\n\nexport function deserializeMessageSignature(bytesReader: BytesReader): MessageSignature {\n  return createMessageSignature(\n    bytesToHex(bytesReader.readBytes(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES))\n  );\n}\n\nexport interface TransactionAuthField {\n  type: StacksMessageType.TransactionAuthField;\n  pubKeyEncoding: PubKeyEncoding;\n  contents: TransactionAuthFieldContents;\n}\n\nexport function createTransactionAuthField(\n  pubKeyEncoding: PubKeyEncoding,\n  contents: TransactionAuthFieldContents\n): TransactionAuthField {\n  return {\n    pubKeyEncoding,\n    type: StacksMessageType.TransactionAuthField,\n    contents,\n  };\n}\n\nexport function deserializeTransactionAuthField(bytesReader: BytesReader): TransactionAuthField {\n  const authFieldType = bytesReader.readUInt8Enum(AuthFieldType, n => {\n    throw new DeserializationError(`Could not read ${n} as AuthFieldType`);\n  });\n\n  switch (authFieldType) {\n    case AuthFieldType.PublicKeyCompressed:\n      return createTransactionAuthField(\n        PubKeyEncoding.Compressed,\n        deserializePublicKey(bytesReader)\n      );\n    case AuthFieldType.PublicKeyUncompressed:\n      return createTransactionAuthField(\n        PubKeyEncoding.Uncompressed,\n        deserializePublicKey(bytesReader)\n      );\n    case AuthFieldType.SignatureCompressed:\n      return createTransactionAuthField(\n        PubKeyEncoding.Compressed,\n        deserializeMessageSignature(bytesReader)\n      );\n    case AuthFieldType.SignatureUncompressed:\n      return createTransactionAuthField(\n        PubKeyEncoding.Uncompressed,\n        deserializeMessageSignature(bytesReader)\n      );\n    default:\n      throw new Error(`Unknown auth field type: ${JSON.stringify(authFieldType)}`);\n  }\n}\n\nexport function serializeMessageSignature(messageSignature: MessageSignature): Uint8Array {\n  return hexToBytes(messageSignature.data);\n}\n\nexport function serializeTransactionAuthField(field: TransactionAuthField): Uint8Array {\n  const bytesArray = [];\n\n  switch (field.contents.type) {\n    case StacksMessageType.PublicKey:\n      if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n        bytesArray.push(AuthFieldType.PublicKeyCompressed);\n        bytesArray.push(serializePublicKey(field.contents));\n      } else {\n        bytesArray.push(AuthFieldType.PublicKeyUncompressed);\n        bytesArray.push(serializePublicKey(compressPublicKey(field.contents.data)));\n      }\n      break;\n    case StacksMessageType.MessageSignature:\n      if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n        bytesArray.push(AuthFieldType.SignatureCompressed);\n      } else {\n        bytesArray.push(AuthFieldType.SignatureUncompressed);\n      }\n      bytesArray.push(serializeMessageSignature(field.contents));\n      break;\n  }\n\n  return concatArray(bytesArray);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}