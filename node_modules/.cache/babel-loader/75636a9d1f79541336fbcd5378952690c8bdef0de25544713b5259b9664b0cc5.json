{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.c32ToB58 = exports.b58ToC32 = exports.c32addressDecode = exports.c32address = exports.versions = void 0;\nconst checksum_1 = require(\"./checksum\");\nconst base58check = require(\"./base58check\");\nconst utils_1 = require(\"@noble/hashes/utils\");\nexports.versions = {\n  mainnet: {\n    p2pkh: 22,\n    p2sh: 20 // 'M'\n  },\n\n  testnet: {\n    p2pkh: 26,\n    p2sh: 21 // 'N'\n  }\n};\n// address conversion : bitcoin to stacks\nconst ADDR_BITCOIN_TO_STACKS = {};\nADDR_BITCOIN_TO_STACKS[0] = exports.versions.mainnet.p2pkh;\nADDR_BITCOIN_TO_STACKS[5] = exports.versions.mainnet.p2sh;\nADDR_BITCOIN_TO_STACKS[111] = exports.versions.testnet.p2pkh;\nADDR_BITCOIN_TO_STACKS[196] = exports.versions.testnet.p2sh;\n// address conversion : stacks to bitcoin\nconst ADDR_STACKS_TO_BITCOIN = {};\nADDR_STACKS_TO_BITCOIN[exports.versions.mainnet.p2pkh] = 0;\nADDR_STACKS_TO_BITCOIN[exports.versions.mainnet.p2sh] = 5;\nADDR_STACKS_TO_BITCOIN[exports.versions.testnet.p2pkh] = 111;\nADDR_STACKS_TO_BITCOIN[exports.versions.testnet.p2sh] = 196;\n/**\n * Make a c32check address with the given version and hash160\n * The only difference between a c32check string and c32 address\n * is that the letter 'S' is pre-pended.\n * @param {number} version - the address version number\n * @param {string} hash160hex - the hash160 to encode (must be a hash160)\n * @returns {string} the address\n */\nfunction c32address(version, hash160hex) {\n  if (!hash160hex.match(/^[0-9a-fA-F]{40}$/)) {\n    throw new Error('Invalid argument: not a hash160 hex string');\n  }\n  const c32string = (0, checksum_1.c32checkEncode)(version, hash160hex);\n  return `S${c32string}`;\n}\nexports.c32address = c32address;\n/**\n * Decode a c32 address into its version and hash160\n * @param {string} c32addr - the c32check-encoded address\n * @returns {[number, string]} a tuple with the version and hash160\n */\nfunction c32addressDecode(c32addr) {\n  if (c32addr.length <= 5) {\n    throw new Error('Invalid c32 address: invalid length');\n  }\n  if (c32addr[0] != 'S') {\n    throw new Error('Invalid c32 address: must start with \"S\"');\n  }\n  return (0, checksum_1.c32checkDecode)(c32addr.slice(1));\n}\nexports.c32addressDecode = c32addressDecode;\n/*\n * Convert a base58check address to a c32check address.\n * Try to convert the version number if one is not given.\n * @param {string} b58check - the base58check encoded address\n * @param {number} version - the version number, if not inferred from the address\n * @returns {string} the c32 address with the given version number (or the\n *   semantically-equivalent c32 version number, if not given)\n */\nfunction b58ToC32(b58check) {\n  let version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n  const addrInfo = base58check.decode(b58check);\n  const hash160String = (0, utils_1.bytesToHex)(addrInfo.data);\n  const addrVersion = parseInt((0, utils_1.bytesToHex)(addrInfo.prefix), 16);\n  let stacksVersion;\n  if (version < 0) {\n    stacksVersion = addrVersion;\n    if (ADDR_BITCOIN_TO_STACKS[addrVersion] !== undefined) {\n      stacksVersion = ADDR_BITCOIN_TO_STACKS[addrVersion];\n    }\n  } else {\n    stacksVersion = version;\n  }\n  return c32address(stacksVersion, hash160String);\n}\nexports.b58ToC32 = b58ToC32;\n/*\n * Convert a c32check address to a base58check address.\n * @param {string} c32string - the c32check address\n * @param {number} version - the version number, if not inferred from the address\n * @returns {string} the base58 address with the given version number (or the\n *    semantically-equivalent bitcoin version number, if not given)\n */\nfunction c32ToB58(c32string) {\n  let version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n  const addrInfo = c32addressDecode(c32string);\n  const stacksVersion = addrInfo[0];\n  const hash160String = addrInfo[1];\n  let bitcoinVersion;\n  if (version < 0) {\n    bitcoinVersion = stacksVersion;\n    if (ADDR_STACKS_TO_BITCOIN[stacksVersion] !== undefined) {\n      bitcoinVersion = ADDR_STACKS_TO_BITCOIN[stacksVersion];\n    }\n  } else {\n    bitcoinVersion = version;\n  }\n  let prefix = bitcoinVersion.toString(16);\n  if (prefix.length === 1) {\n    prefix = `0${prefix}`;\n  }\n  return base58check.encode(hash160String, prefix);\n}\nexports.c32ToB58 = c32ToB58;","map":{"version":3,"names":["Object","defineProperty","exports","value","c32ToB58","b58ToC32","c32addressDecode","c32address","versions","checksum_1","require","base58check","utils_1","mainnet","p2pkh","p2sh","testnet","ADDR_BITCOIN_TO_STACKS","ADDR_STACKS_TO_BITCOIN","version","hash160hex","match","Error","c32string","c32checkEncode","c32addr","length","c32checkDecode","slice","b58check","arguments","undefined","addrInfo","decode","hash160String","bytesToHex","data","addrVersion","parseInt","prefix","stacksVersion","bitcoinVersion","toString","encode"],"sources":["C:/Users/abasi/Desktop/web3-apps/react-cra/node_modules/c32check/lib/address.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.c32ToB58 = exports.b58ToC32 = exports.c32addressDecode = exports.c32address = exports.versions = void 0;\nconst checksum_1 = require(\"./checksum\");\nconst base58check = require(\"./base58check\");\nconst utils_1 = require(\"@noble/hashes/utils\");\nexports.versions = {\n    mainnet: {\n        p2pkh: 22,\n        p2sh: 20, // 'M'\n    },\n    testnet: {\n        p2pkh: 26,\n        p2sh: 21, // 'N'\n    },\n};\n// address conversion : bitcoin to stacks\nconst ADDR_BITCOIN_TO_STACKS = {};\nADDR_BITCOIN_TO_STACKS[0] = exports.versions.mainnet.p2pkh;\nADDR_BITCOIN_TO_STACKS[5] = exports.versions.mainnet.p2sh;\nADDR_BITCOIN_TO_STACKS[111] = exports.versions.testnet.p2pkh;\nADDR_BITCOIN_TO_STACKS[196] = exports.versions.testnet.p2sh;\n// address conversion : stacks to bitcoin\nconst ADDR_STACKS_TO_BITCOIN = {};\nADDR_STACKS_TO_BITCOIN[exports.versions.mainnet.p2pkh] = 0;\nADDR_STACKS_TO_BITCOIN[exports.versions.mainnet.p2sh] = 5;\nADDR_STACKS_TO_BITCOIN[exports.versions.testnet.p2pkh] = 111;\nADDR_STACKS_TO_BITCOIN[exports.versions.testnet.p2sh] = 196;\n/**\n * Make a c32check address with the given version and hash160\n * The only difference between a c32check string and c32 address\n * is that the letter 'S' is pre-pended.\n * @param {number} version - the address version number\n * @param {string} hash160hex - the hash160 to encode (must be a hash160)\n * @returns {string} the address\n */\nfunction c32address(version, hash160hex) {\n    if (!hash160hex.match(/^[0-9a-fA-F]{40}$/)) {\n        throw new Error('Invalid argument: not a hash160 hex string');\n    }\n    const c32string = (0, checksum_1.c32checkEncode)(version, hash160hex);\n    return `S${c32string}`;\n}\nexports.c32address = c32address;\n/**\n * Decode a c32 address into its version and hash160\n * @param {string} c32addr - the c32check-encoded address\n * @returns {[number, string]} a tuple with the version and hash160\n */\nfunction c32addressDecode(c32addr) {\n    if (c32addr.length <= 5) {\n        throw new Error('Invalid c32 address: invalid length');\n    }\n    if (c32addr[0] != 'S') {\n        throw new Error('Invalid c32 address: must start with \"S\"');\n    }\n    return (0, checksum_1.c32checkDecode)(c32addr.slice(1));\n}\nexports.c32addressDecode = c32addressDecode;\n/*\n * Convert a base58check address to a c32check address.\n * Try to convert the version number if one is not given.\n * @param {string} b58check - the base58check encoded address\n * @param {number} version - the version number, if not inferred from the address\n * @returns {string} the c32 address with the given version number (or the\n *   semantically-equivalent c32 version number, if not given)\n */\nfunction b58ToC32(b58check, version = -1) {\n    const addrInfo = base58check.decode(b58check);\n    const hash160String = (0, utils_1.bytesToHex)(addrInfo.data);\n    const addrVersion = parseInt((0, utils_1.bytesToHex)(addrInfo.prefix), 16);\n    let stacksVersion;\n    if (version < 0) {\n        stacksVersion = addrVersion;\n        if (ADDR_BITCOIN_TO_STACKS[addrVersion] !== undefined) {\n            stacksVersion = ADDR_BITCOIN_TO_STACKS[addrVersion];\n        }\n    }\n    else {\n        stacksVersion = version;\n    }\n    return c32address(stacksVersion, hash160String);\n}\nexports.b58ToC32 = b58ToC32;\n/*\n * Convert a c32check address to a base58check address.\n * @param {string} c32string - the c32check address\n * @param {number} version - the version number, if not inferred from the address\n * @returns {string} the base58 address with the given version number (or the\n *    semantically-equivalent bitcoin version number, if not given)\n */\nfunction c32ToB58(c32string, version = -1) {\n    const addrInfo = c32addressDecode(c32string);\n    const stacksVersion = addrInfo[0];\n    const hash160String = addrInfo[1];\n    let bitcoinVersion;\n    if (version < 0) {\n        bitcoinVersion = stacksVersion;\n        if (ADDR_STACKS_TO_BITCOIN[stacksVersion] !== undefined) {\n            bitcoinVersion = ADDR_STACKS_TO_BITCOIN[stacksVersion];\n        }\n    }\n    else {\n        bitcoinVersion = version;\n    }\n    let prefix = bitcoinVersion.toString(16);\n    if (prefix.length === 1) {\n        prefix = `0${prefix}`;\n    }\n    return base58check.encode(hash160String, prefix);\n}\nexports.c32ToB58 = c32ToB58;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}