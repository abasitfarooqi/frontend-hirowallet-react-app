{"ast":null,"code":"import { extends as _extends, asyncToGenerator as _asyncToGenerator, regeneratorRuntime as _regeneratorRuntime, objectWithoutPropertiesLoose as _objectWithoutPropertiesLoose } from '../_virtual/_rollupPluginBabelHelpers.js';\nimport { createUnsecuredToken, TokenSigner } from 'jsontokens';\nimport { getStacksProvider } from '../utils.esm.js';\nimport { StacksTestnet } from '@stacks/network';\nimport { ChainID } from '@stacks/transactions';\nimport { getUserSession, hasAppPrivateKey, getKeys } from '../transactions/index.esm.js';\nvar _excluded = [\"userSession\"];\nfunction getStxAddress(options) {\n  var _userSession$loadUser, _chainIdToKey;\n  var userSession = options.userSession,\n    network = options.network;\n  if (!userSession || !network) return void 0;\n  var stxAddresses = userSession == null ? void 0 : (_userSession$loadUser = userSession.loadUserData().profile) == null ? void 0 : _userSession$loadUser.stxAddress;\n  var chainIdToKey = (_chainIdToKey = {}, _chainIdToKey[ChainID.Mainnet] = \"mainnet\", _chainIdToKey[ChainID.Testnet] = \"testnet\", _chainIdToKey);\n  var address = stxAddresses == null ? void 0 : stxAddresses[chainIdToKey[network.chainId]];\n  return address;\n}\nfunction signPayload(_x, _x2) {\n  return _signPayload.apply(this, arguments);\n}\nfunction _signPayload() {\n  _signPayload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(payload, privateKey) {\n    var tokenSigner;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          tokenSigner = new TokenSigner(\"ES256k\", privateKey);\n          return _context2.abrupt(\"return\", tokenSigner.signAsync(_extends({}, payload)));\n        case 2:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _signPayload.apply(this, arguments);\n}\nfunction getDefaultSignatureRequestOptions(options) {\n  var network = options.network || new StacksTestnet();\n  var userSession = getUserSession(options.userSession);\n  var defaults = _extends({}, options, {\n    network: network,\n    userSession: userSession\n  });\n  return _extends({\n    stxAddress: getStxAddress(defaults)\n  }, defaults);\n}\nfunction openSignaturePopup(_x3) {\n  return _openSignaturePopup.apply(this, arguments);\n}\nfunction _openSignaturePopup() {\n  _openSignaturePopup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_ref) {\n    var token, options, provider, signatureResponse;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          token = _ref.token, options = _ref.options;\n          provider = getStacksProvider();\n          if (provider) {\n            _context3.next = 4;\n            break;\n          }\n          throw new Error(\"Hiro Wallet not installed.\");\n        case 4:\n          _context3.prev = 4;\n          _context3.next = 7;\n          return provider.signatureRequest(token);\n        case 7:\n          signatureResponse = _context3.sent;\n          options.onFinish == null ? void 0 : options.onFinish(signatureResponse);\n          _context3.next = 15;\n          break;\n        case 11:\n          _context3.prev = 11;\n          _context3.t0 = _context3[\"catch\"](4);\n          console.error(\"[Connect] Error during signature request\", _context3.t0);\n          options.onCancel == null ? void 0 : options.onCancel();\n        case 15:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3, null, [[4, 11]]);\n  }));\n  return _openSignaturePopup.apply(this, arguments);\n}\nvar signMessage = /*#__PURE__*/function () {\n  var _ref2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(options) {\n    var userSession, _options, _getKeys, privateKey, publicKey, payload2, payload;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          userSession = options.userSession, _options = _objectWithoutPropertiesLoose(options, _excluded);\n          if (!hasAppPrivateKey(userSession)) {\n            _context.next = 5;\n            break;\n          }\n          _getKeys = getKeys(userSession), privateKey = _getKeys.privateKey, publicKey = _getKeys.publicKey;\n          payload2 = _extends({}, _options, {\n            publicKey: publicKey\n          });\n          return _context.abrupt(\"return\", signPayload(payload2, privateKey));\n        case 5:\n          payload = _extends({}, _options);\n          return _context.abrupt(\"return\", createUnsecuredToken(payload));\n        case 7:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function signMessage(_x4) {\n    return _ref2.apply(this, arguments);\n  };\n}();\nfunction generateTokenAndOpenPopup(_x5, _x6) {\n  return _generateTokenAndOpenPopup.apply(this, arguments);\n}\nfunction _generateTokenAndOpenPopup() {\n  _generateTokenAndOpenPopup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(options, makeTokenFn) {\n    var token;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          _context4.next = 2;\n          return makeTokenFn(_extends({}, getDefaultSignatureRequestOptions(options), options));\n        case 2:\n          token = _context4.sent;\n          return _context4.abrupt(\"return\", openSignaturePopup({\n            token: token,\n            options: options\n          }));\n        case 4:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4);\n  }));\n  return _generateTokenAndOpenPopup.apply(this, arguments);\n}\nfunction openSignatureRequestPopup(options) {\n  return generateTokenAndOpenPopup(options, signMessage);\n}\nexport { getDefaultSignatureRequestOptions, openSignatureRequestPopup, signMessage };","map":{"version":3,"names":["getStxAddress","options","_userSession$loadUser","_chainIdToKey","userSession","network","stxAddresses","loadUserData","profile","stxAddress","chainIdToKey","ChainID","Mainnet","Testnet","address","chainId","_callee2","payload","privateKey","tokenSigner","TokenSigner","signAsync","_extends","StacksTestnet","getUserSession","defaults","_callee3","_ref","token","provider","signatureResponse","_regeneratorRuntime","wrap","_callee3$","_context3","prev","next","getStacksProvider","Error","signatureRequest","sent","onFinish","error","t0","onCancel","signMessage","_callee","_options","_objectWithoutPropertiesLoose","_excluded","hasAppPrivateKey","getKeys","_getKeys","publicKey","payload2","signPayload","createUnsecuredToken","_x4","_callee4","makeTokenFn","getDefaultSignatureRequestOptions","_context4","openSignaturePopup","generateTokenAndOpenPopup"],"sources":["C:\\Users\\abasi\\Desktop\\web3-apps\\react-cra\\node_modules\\@stacks\\connect-react\\node_modules\\@stacks\\connect\\src\\signature\\index.ts"],"sourcesContent":["import { StacksTestnet } from '@stacks/network';\nimport { ChainID } from '@stacks/transactions';\nimport { createUnsecuredToken, TokenSigner } from 'jsontokens';\nimport { getKeys, getUserSession, hasAppPrivateKey } from '../transactions';\nimport {\n  CommonSignatureRequestOptions,\n  SignatureOptions,\n  SignaturePayload,\n  SignaturePopup,\n  SignatureRequestOptions,\n} from '../types/signature';\nimport { getStacksProvider } from '../utils';\n\nfunction getStxAddress(options: CommonSignatureRequestOptions) {\n  const { userSession, network } = options;\n\n  if (!userSession || !network) return undefined;\n  const stxAddresses = userSession?.loadUserData().profile?.stxAddress;\n  const chainIdToKey = {\n    [ChainID.Mainnet]: 'mainnet',\n    [ChainID.Testnet]: 'testnet',\n  };\n  const address: string | undefined = stxAddresses?.[chainIdToKey[network.chainId]];\n  return address;\n}\n\n// eslint-disable-next-line @typescript-eslint/require-await\nasync function signPayload(payload: SignaturePayload, privateKey: string) {\n  const tokenSigner = new TokenSigner('ES256k', privateKey);\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n  return tokenSigner.signAsync({ ...payload } as any);\n}\n\nexport function getDefaultSignatureRequestOptions(options: CommonSignatureRequestOptions) {\n  const network = options.network || new StacksTestnet();\n  const userSession = getUserSession(options.userSession);\n  const defaults: CommonSignatureRequestOptions = {\n    ...options,\n    network,\n    userSession,\n  };\n  return {\n    stxAddress: getStxAddress(defaults),\n    ...defaults,\n  };\n}\n\nasync function openSignaturePopup({ token, options }: SignaturePopup) {\n  const provider = getStacksProvider();\n  if (!provider) {\n    throw new Error('Hiro Wallet not installed.');\n  }\n\n  try {\n    const signatureResponse = await provider.signatureRequest(token);\n    options.onFinish?.(signatureResponse);\n  } catch (error) {\n    console.error('[Connect] Error during signature request', error);\n    options.onCancel?.();\n  }\n}\n\nexport interface SignatureRequestPayload {\n  message: string;\n}\n\n// eslint-disable-next-line @typescript-eslint/require-await\nexport const signMessage = async (options: SignatureRequestOptions) => {\n  const { userSession, ..._options } = options;\n  if (hasAppPrivateKey(userSession)) {\n    const { privateKey, publicKey } = getKeys(userSession);\n\n    const payload: SignaturePayload = {\n      ..._options,\n      publicKey,\n    };\n\n    return signPayload(payload, privateKey);\n  }\n  const payload = { ..._options };\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n  return createUnsecuredToken(payload as any);\n};\n\nasync function generateTokenAndOpenPopup<T extends SignatureOptions>(\n  options: T,\n  makeTokenFn: (options: T) => Promise<string>\n) {\n  const token = await makeTokenFn({\n    ...getDefaultSignatureRequestOptions(options),\n    ...options,\n  } as T);\n  return openSignaturePopup({ token, options });\n}\n\nexport function openSignatureRequestPopup(options: SignatureRequestOptions) {\n  return generateTokenAndOpenPopup(options, signMessage);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}