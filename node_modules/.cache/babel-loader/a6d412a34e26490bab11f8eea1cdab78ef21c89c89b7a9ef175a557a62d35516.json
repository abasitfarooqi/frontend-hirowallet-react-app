{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SECP256K1Client = void 0;\nconst hmac_1 = require(\"@noble/hashes/hmac\");\nconst sha256_1 = require(\"@noble/hashes/sha256\");\nconst secp = require(\"@noble/secp256k1\");\nconst ecdsaSigFormatter_1 = require(\"../ecdsaSigFormatter\");\nconst errors_1 = require(\"../errors\");\nconst utils_1 = require(\"@noble/hashes/utils\");\n// required to use noble secp https://github.com/paulmillr/noble-secp256k1\nsecp.utils.hmacSha256Sync = function (key) {\n  const h = hmac_1.hmac.create(sha256_1.sha256, key);\n  for (var _len = arguments.length, msgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    msgs[_key - 1] = arguments[_key];\n  }\n  msgs.forEach(msg => h.update(msg));\n  return h.digest();\n};\nclass SECP256K1Client {\n  static derivePublicKey(privateKey) {\n    let compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (privateKey.length === 66) {\n      privateKey = privateKey.slice(0, 64);\n    }\n    if (privateKey.length < 64) {\n      // backward compatibly accept too short private keys\n      privateKey = privateKey.padStart(64, '0');\n    }\n    return (0, utils_1.bytesToHex)(secp.getPublicKey(privateKey, compressed));\n  }\n  static signHash(signingInputHash, privateKey) {\n    let format = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'jose';\n    // make sure the required parameters are provided\n    if (!signingInputHash || !privateKey) {\n      throw new errors_1.MissingParametersError('a signing input hash and private key are all required');\n    }\n    const derSignature = secp.signSync(signingInputHash, privateKey.slice(0, 64), {\n      der: true,\n      canonical: false\n    });\n    if (format === 'der') return (0, utils_1.bytesToHex)(derSignature);\n    if (format === 'jose') return (0, ecdsaSigFormatter_1.derToJose)(derSignature, 'ES256');\n    throw Error('Invalid signature format');\n  }\n  static loadSignature(joseSignature) {\n    // create and return the DER-formatted signature bytes\n    return (0, ecdsaSigFormatter_1.joseToDer)(joseSignature, 'ES256');\n  }\n  static verifyHash(signingInputHash, derSignatureBytes, publicKey) {\n    // make sure the required parameters are provided\n    if (!signingInputHash || !derSignatureBytes || !publicKey) {\n      throw new errors_1.MissingParametersError('a signing input hash, der signature, and public key are all required');\n    }\n    return secp.verify(derSignatureBytes, signingInputHash, publicKey, {\n      strict: false\n    });\n  }\n}\nexports.SECP256K1Client = SECP256K1Client;\nSECP256K1Client.algorithmName = 'ES256K';","map":{"version":3,"names":["hmac_1","require","sha256_1","secp","ecdsaSigFormatter_1","errors_1","utils_1","utils","hmacSha256Sync","key","h","hmac","create","sha256","_len","arguments","length","msgs","Array","_key","forEach","msg","update","digest","SECP256K1Client","derivePublicKey","privateKey","compressed","undefined","slice","padStart","bytesToHex","getPublicKey","signHash","signingInputHash","format","MissingParametersError","derSignature","signSync","der","canonical","derToJose","Error","loadSignature","joseSignature","joseToDer","verifyHash","derSignatureBytes","publicKey","verify","strict","exports","algorithmName"],"sources":["cryptoClients/secp256k1.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}