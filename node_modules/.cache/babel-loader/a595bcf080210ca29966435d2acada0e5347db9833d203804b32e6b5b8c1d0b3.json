{"ast":null,"code":"import { cloneDeep } from './utils';\nimport { uintCV, intCV, contractPrincipalCV, standardPrincipalCV, noneCV, bufferCV, falseCV, trueCV, ClarityType, getCVTypeString, bufferCVFromString } from './clarity';\nimport { NotImplementedError } from './errors';\nimport { stringAsciiCV, stringUtf8CV } from './clarity/types/stringCV';\nimport { utf8ToBytes } from '@stacks/common';\nexport var ClarityAbiTypeId;\n(function (ClarityAbiTypeId) {\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeUInt128\"] = 1] = \"ClarityAbiTypeUInt128\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeInt128\"] = 2] = \"ClarityAbiTypeInt128\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeBool\"] = 3] = \"ClarityAbiTypeBool\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypePrincipal\"] = 4] = \"ClarityAbiTypePrincipal\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeNone\"] = 5] = \"ClarityAbiTypeNone\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeBuffer\"] = 6] = \"ClarityAbiTypeBuffer\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeResponse\"] = 7] = \"ClarityAbiTypeResponse\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeOptional\"] = 8] = \"ClarityAbiTypeOptional\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeTuple\"] = 9] = \"ClarityAbiTypeTuple\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeList\"] = 10] = \"ClarityAbiTypeList\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeStringAscii\"] = 11] = \"ClarityAbiTypeStringAscii\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeStringUtf8\"] = 12] = \"ClarityAbiTypeStringUtf8\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeTraitReference\"] = 13] = \"ClarityAbiTypeTraitReference\";\n})(ClarityAbiTypeId || (ClarityAbiTypeId = {}));\nexport const isClarityAbiPrimitive = val => typeof val === 'string';\nexport const isClarityAbiBuffer = val => val.buffer !== undefined;\nexport const isClarityAbiStringAscii = val => val['string-ascii'] !== undefined;\nexport const isClarityAbiStringUtf8 = val => val['string-utf8'] !== undefined;\nexport const isClarityAbiResponse = val => val.response !== undefined;\nexport const isClarityAbiOptional = val => val.optional !== undefined;\nexport const isClarityAbiTuple = val => val.tuple !== undefined;\nexport const isClarityAbiList = val => val.list !== undefined;\nexport function getTypeUnion(val) {\n  if (isClarityAbiPrimitive(val)) {\n    if (val === 'uint128') {\n      return {\n        id: ClarityAbiTypeId.ClarityAbiTypeUInt128,\n        type: val\n      };\n    } else if (val === 'int128') {\n      return {\n        id: ClarityAbiTypeId.ClarityAbiTypeInt128,\n        type: val\n      };\n    } else if (val === 'bool') {\n      return {\n        id: ClarityAbiTypeId.ClarityAbiTypeBool,\n        type: val\n      };\n    } else if (val === 'principal') {\n      return {\n        id: ClarityAbiTypeId.ClarityAbiTypePrincipal,\n        type: val\n      };\n    } else if (val === 'trait_reference') {\n      return {\n        id: ClarityAbiTypeId.ClarityAbiTypeTraitReference,\n        type: val\n      };\n    } else if (val === 'none') {\n      return {\n        id: ClarityAbiTypeId.ClarityAbiTypeNone,\n        type: val\n      };\n    } else {\n      throw new Error(`Unexpected Clarity ABI type primitive: ${JSON.stringify(val)}`);\n    }\n  } else if (isClarityAbiBuffer(val)) {\n    return {\n      id: ClarityAbiTypeId.ClarityAbiTypeBuffer,\n      type: val\n    };\n  } else if (isClarityAbiResponse(val)) {\n    return {\n      id: ClarityAbiTypeId.ClarityAbiTypeResponse,\n      type: val\n    };\n  } else if (isClarityAbiOptional(val)) {\n    return {\n      id: ClarityAbiTypeId.ClarityAbiTypeOptional,\n      type: val\n    };\n  } else if (isClarityAbiTuple(val)) {\n    return {\n      id: ClarityAbiTypeId.ClarityAbiTypeTuple,\n      type: val\n    };\n  } else if (isClarityAbiList(val)) {\n    return {\n      id: ClarityAbiTypeId.ClarityAbiTypeList,\n      type: val\n    };\n  } else if (isClarityAbiStringAscii(val)) {\n    return {\n      id: ClarityAbiTypeId.ClarityAbiTypeStringAscii,\n      type: val\n    };\n  } else if (isClarityAbiStringUtf8(val)) {\n    return {\n      id: ClarityAbiTypeId.ClarityAbiTypeStringUtf8,\n      type: val\n    };\n  } else {\n    throw new Error(`Unexpected Clarity ABI type: ${JSON.stringify(val)}`);\n  }\n}\nfunction encodeClarityValue(input, val) {\n  let union;\n  if (input.id !== undefined) {\n    union = input;\n  } else {\n    union = getTypeUnion(input);\n  }\n  switch (union.id) {\n    case ClarityAbiTypeId.ClarityAbiTypeUInt128:\n      return uintCV(val);\n    case ClarityAbiTypeId.ClarityAbiTypeInt128:\n      return intCV(val);\n    case ClarityAbiTypeId.ClarityAbiTypeBool:\n      if (val === 'false' || val === '0') return falseCV();else if (val === 'true' || val === '1') return trueCV();else throw new Error(`Unexpected Clarity bool value: ${JSON.stringify(val)}`);\n    case ClarityAbiTypeId.ClarityAbiTypePrincipal:\n      if (val.includes('.')) {\n        const [addr, name] = val.split('.');\n        return contractPrincipalCV(addr, name);\n      } else {\n        return standardPrincipalCV(val);\n      }\n    case ClarityAbiTypeId.ClarityAbiTypeTraitReference:\n      const [addr, name] = val.split('.');\n      return contractPrincipalCV(addr, name);\n    case ClarityAbiTypeId.ClarityAbiTypeNone:\n      return noneCV();\n    case ClarityAbiTypeId.ClarityAbiTypeBuffer:\n      return bufferCV(utf8ToBytes(val));\n    case ClarityAbiTypeId.ClarityAbiTypeStringAscii:\n      return stringAsciiCV(val);\n    case ClarityAbiTypeId.ClarityAbiTypeStringUtf8:\n      return stringUtf8CV(val);\n    case ClarityAbiTypeId.ClarityAbiTypeResponse:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n    case ClarityAbiTypeId.ClarityAbiTypeOptional:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n    case ClarityAbiTypeId.ClarityAbiTypeTuple:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n    case ClarityAbiTypeId.ClarityAbiTypeList:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n    default:\n      throw new Error(`Unexpected Clarity type ID: ${JSON.stringify(union)}`);\n  }\n}\nexport { encodeClarityValue };\nexport function getTypeString(val) {\n  if (isClarityAbiPrimitive(val)) {\n    if (val === 'int128') {\n      return 'int';\n    } else if (val === 'uint128') {\n      return 'uint';\n    }\n    return val;\n  } else if (isClarityAbiBuffer(val)) {\n    return `(buff ${val.buffer.length})`;\n  } else if (isClarityAbiStringAscii(val)) {\n    return `(string-ascii ${val['string-ascii'].length})`;\n  } else if (isClarityAbiStringUtf8(val)) {\n    return `(string-utf8 ${val['string-utf8'].length})`;\n  } else if (isClarityAbiResponse(val)) {\n    return `(response ${getTypeString(val.response.ok)} ${getTypeString(val.response.error)})`;\n  } else if (isClarityAbiOptional(val)) {\n    return `(optional ${getTypeString(val.optional)})`;\n  } else if (isClarityAbiTuple(val)) {\n    return `(tuple ${val.tuple.map(t => `(${t.name} ${getTypeString(t.type)})`).join(' ')})`;\n  } else if (isClarityAbiList(val)) {\n    return `(list ${val.list.length} ${getTypeString(val.list.type)})`;\n  } else {\n    throw new Error(`Type string unsupported for Clarity type: ${JSON.stringify(val)}`);\n  }\n}\nexport function abiFunctionToString(func) {\n  const access = func.access === 'read_only' ? 'read-only' : func.access;\n  return `(define-${access} (${func.name} ${func.args.map(arg => `(${arg.name} ${getTypeString(arg.type)})`).join(' ')}))`;\n}\nfunction matchType(cv, abiType) {\n  const union = getTypeUnion(abiType);\n  switch (cv.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeBool;\n    case ClarityType.Int:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeInt128;\n    case ClarityType.UInt:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeUInt128;\n    case ClarityType.Buffer:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeBuffer && union.type.buffer.length >= cv.buffer.length;\n    case ClarityType.StringASCII:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeStringAscii && union.type['string-ascii'].length >= cv.data.length;\n    case ClarityType.StringUTF8:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeStringUtf8 && union.type['string-utf8'].length >= cv.data.length;\n    case ClarityType.OptionalNone:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeNone || union.id === ClarityAbiTypeId.ClarityAbiTypeOptional;\n    case ClarityType.OptionalSome:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeOptional && matchType(cv.value, union.type.optional);\n    case ClarityType.ResponseErr:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeResponse && matchType(cv.value, union.type.response.error);\n    case ClarityType.ResponseOk:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeResponse && matchType(cv.value, union.type.response.ok);\n    case ClarityType.PrincipalContract:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypePrincipal || union.id === ClarityAbiTypeId.ClarityAbiTypeTraitReference;\n    case ClarityType.PrincipalStandard:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypePrincipal;\n    case ClarityType.List:\n      return union.id == ClarityAbiTypeId.ClarityAbiTypeList && union.type.list.length >= cv.list.length && cv.list.every(val => matchType(val, union.type.list.type));\n    case ClarityType.Tuple:\n      if (union.id == ClarityAbiTypeId.ClarityAbiTypeTuple) {\n        const tuple = cloneDeep(cv.data);\n        for (let i = 0; i < union.type.tuple.length; i++) {\n          const abiTupleEntry = union.type.tuple[i];\n          const key = abiTupleEntry.name;\n          const val = tuple[key];\n          if (val) {\n            if (!matchType(val, abiTupleEntry.type)) {\n              return false;\n            }\n            delete tuple[key];\n          } else {\n            return false;\n          }\n        }\n        return true;\n      } else {\n        return false;\n      }\n    default:\n      return false;\n  }\n}\nexport function validateContractCall(payload, abi) {\n  const filtered = abi.functions.filter(fn => fn.name === payload.functionName.content);\n  if (filtered.length === 1) {\n    const abiFunc = filtered[0];\n    const abiArgs = abiFunc.args;\n    if (payload.functionArgs.length !== abiArgs.length) {\n      throw new Error(`Clarity function expects ${abiArgs.length} argument(s) but received ${payload.functionArgs.length}`);\n    }\n    for (let i = 0; i < payload.functionArgs.length; i++) {\n      const payloadArg = payload.functionArgs[i];\n      const abiArg = abiArgs[i];\n      if (!matchType(payloadArg, abiArg.type)) {\n        const argNum = i + 1;\n        throw new Error(`Clarity function \\`${payload.functionName.content}\\` expects argument ${argNum} to be of type ${getTypeString(abiArg.type)}, not ${getCVTypeString(payloadArg)}`);\n      }\n    }\n    return true;\n  } else if (filtered.length === 0) {\n    throw new Error(`ABI doesn't contain a function with the name ${payload.functionName.content}`);\n  } else {\n    throw new Error(`Malformed ABI. Contains multiple functions with the name ${payload.functionName.content}`);\n  }\n}\nexport function parseToCV(input, type) {\n  const typeString = getTypeString(type);\n  if (isClarityAbiPrimitive(type)) {\n    if (type === 'uint128') {\n      return uintCV(input);\n    } else if (type === 'int128') {\n      return intCV(input);\n    } else if (type === 'bool') {\n      if (input.toLowerCase() === 'true') {\n        return trueCV();\n      } else if (input.toLowerCase() === 'false') {\n        return falseCV();\n      } else {\n        throw new Error(`Invalid bool value: ${input}`);\n      }\n    } else if (type === 'principal') {\n      if (input.includes('.')) {\n        const [address, contractName] = input.split('.');\n        return contractPrincipalCV(address, contractName);\n      } else {\n        return standardPrincipalCV(input);\n      }\n    } else {\n      throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n    }\n  } else if (isClarityAbiBuffer(type)) {\n    const inputLength = utf8ToBytes(input).byteLength;\n    if (inputLength > type.buffer.length) {\n      throw new Error(`Input exceeds specified buffer length limit of ${type.buffer.length}`);\n    }\n    return bufferCVFromString(input);\n  } else if (isClarityAbiResponse(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiOptional(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiTuple(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiList(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  }\n}","map":{"version":3,"names":["cloneDeep","uintCV","intCV","contractPrincipalCV","standardPrincipalCV","noneCV","bufferCV","falseCV","trueCV","ClarityType","getCVTypeString","bufferCVFromString","NotImplementedError","stringAsciiCV","stringUtf8CV","utf8ToBytes","ClarityAbiTypeId","isClarityAbiPrimitive","val","isClarityAbiBuffer","buffer","undefined","isClarityAbiStringAscii","isClarityAbiStringUtf8","isClarityAbiResponse","response","isClarityAbiOptional","optional","isClarityAbiTuple","tuple","isClarityAbiList","list","getTypeUnion","id","ClarityAbiTypeUInt128","type","ClarityAbiTypeInt128","ClarityAbiTypeBool","ClarityAbiTypePrincipal","ClarityAbiTypeTraitReference","ClarityAbiTypeNone","Error","JSON","stringify","ClarityAbiTypeBuffer","ClarityAbiTypeResponse","ClarityAbiTypeOptional","ClarityAbiTypeTuple","ClarityAbiTypeList","ClarityAbiTypeStringAscii","ClarityAbiTypeStringUtf8","encodeClarityValue","input","union","includes","addr","name","split","getTypeString","length","ok","error","map","t","join","abiFunctionToString","func","access","args","arg","matchType","cv","abiType","BoolTrue","BoolFalse","Int","UInt","Buffer","StringASCII","data","StringUTF8","OptionalNone","OptionalSome","value","ResponseErr","ResponseOk","PrincipalContract","PrincipalStandard","List","every","Tuple","i","abiTupleEntry","key","validateContractCall","payload","abi","filtered","functions","filter","fn","functionName","content","abiFunc","abiArgs","functionArgs","payloadArg","abiArg","argNum","parseToCV","typeString","toLowerCase","address","contractName","inputLength","byteLength"],"sources":["C:\\Users\\abasi\\Desktop\\web3-apps\\react-cra\\node_modules\\@stacks\\transactions\\src\\contract-abi.ts"],"sourcesContent":["import { cloneDeep } from './utils';\nimport {\n  ClarityValue,\n  uintCV,\n  intCV,\n  contractPrincipalCV,\n  standardPrincipalCV,\n  noneCV,\n  bufferCV,\n  falseCV,\n  trueCV,\n  ClarityType,\n  getCVTypeString,\n  bufferCVFromString,\n} from './clarity';\nimport { ContractCallPayload } from './payload';\nimport { NotImplementedError } from './errors';\nimport { stringAsciiCV, stringUtf8CV } from './clarity/types/stringCV';\nimport { utf8ToBytes } from '@stacks/common';\n\n// From https://github.com/blockstack/stacks-blockchain-sidecar/blob/master/src/event-stream/contract-abi.ts\n\nexport type ClarityAbiTypeBuffer = { buffer: { length: number } };\nexport type ClarityAbiTypeStringAscii = { 'string-ascii': { length: number } };\nexport type ClarityAbiTypeStringUtf8 = { 'string-utf8': { length: number } };\nexport type ClarityAbiTypeResponse = { response: { ok: ClarityAbiType; error: ClarityAbiType } };\nexport type ClarityAbiTypeOptional = { optional: ClarityAbiType };\nexport type ClarityAbiTypeTuple = { tuple: { name: string; type: ClarityAbiType }[] };\nexport type ClarityAbiTypeList = { list: { type: ClarityAbiType; length: number } };\n\nexport type ClarityAbiTypeUInt128 = 'uint128';\nexport type ClarityAbiTypeInt128 = 'int128';\nexport type ClarityAbiTypeBool = 'bool';\nexport type ClarityAbiTypePrincipal = 'principal';\nexport type ClarityAbiTypeTraitReference = 'trait_reference';\nexport type ClarityAbiTypeNone = 'none';\n\nexport type ClarityAbiTypePrimitive =\n  | ClarityAbiTypeUInt128\n  | ClarityAbiTypeInt128\n  | ClarityAbiTypeBool\n  | ClarityAbiTypePrincipal\n  | ClarityAbiTypeTraitReference\n  | ClarityAbiTypeNone;\n\nexport type ClarityAbiType =\n  | ClarityAbiTypePrimitive\n  | ClarityAbiTypeBuffer\n  | ClarityAbiTypeResponse\n  | ClarityAbiTypeOptional\n  | ClarityAbiTypeTuple\n  | ClarityAbiTypeList\n  | ClarityAbiTypeStringAscii\n  | ClarityAbiTypeStringUtf8\n  | ClarityAbiTypeTraitReference;\n\nexport enum ClarityAbiTypeId {\n  ClarityAbiTypeUInt128 = 1,\n  ClarityAbiTypeInt128 = 2,\n  ClarityAbiTypeBool = 3,\n  ClarityAbiTypePrincipal = 4,\n  ClarityAbiTypeNone = 5,\n  ClarityAbiTypeBuffer = 6,\n  ClarityAbiTypeResponse = 7,\n  ClarityAbiTypeOptional = 8,\n  ClarityAbiTypeTuple = 9,\n  ClarityAbiTypeList = 10,\n  ClarityAbiTypeStringAscii = 11,\n  ClarityAbiTypeStringUtf8 = 12,\n  ClarityAbiTypeTraitReference = 13,\n}\n\nexport const isClarityAbiPrimitive = (val: ClarityAbiType): val is ClarityAbiTypePrimitive =>\n  typeof val === 'string';\nexport const isClarityAbiBuffer = (val: ClarityAbiType): val is ClarityAbiTypeBuffer =>\n  (val as ClarityAbiTypeBuffer).buffer !== undefined;\nexport const isClarityAbiStringAscii = (val: ClarityAbiType): val is ClarityAbiTypeStringAscii =>\n  (val as ClarityAbiTypeStringAscii)['string-ascii'] !== undefined;\nexport const isClarityAbiStringUtf8 = (val: ClarityAbiType): val is ClarityAbiTypeStringUtf8 =>\n  (val as ClarityAbiTypeStringUtf8)['string-utf8'] !== undefined;\nexport const isClarityAbiResponse = (val: ClarityAbiType): val is ClarityAbiTypeResponse =>\n  (val as ClarityAbiTypeResponse).response !== undefined;\nexport const isClarityAbiOptional = (val: ClarityAbiType): val is ClarityAbiTypeOptional =>\n  (val as ClarityAbiTypeOptional).optional !== undefined;\nexport const isClarityAbiTuple = (val: ClarityAbiType): val is ClarityAbiTypeTuple =>\n  (val as ClarityAbiTypeTuple).tuple !== undefined;\nexport const isClarityAbiList = (val: ClarityAbiType): val is ClarityAbiTypeList =>\n  (val as ClarityAbiTypeList).list !== undefined;\n\nexport type ClarityAbiTypeUnion =\n  | { id: ClarityAbiTypeId.ClarityAbiTypeUInt128; type: ClarityAbiTypeUInt128 }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeInt128; type: ClarityAbiTypeInt128 }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeBool; type: ClarityAbiTypeBool }\n  | { id: ClarityAbiTypeId.ClarityAbiTypePrincipal; type: ClarityAbiTypePrincipal }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeTraitReference; type: ClarityAbiTypeTraitReference }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeNone; type: ClarityAbiTypeNone }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeBuffer; type: ClarityAbiTypeBuffer }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeResponse; type: ClarityAbiTypeResponse }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeOptional; type: ClarityAbiTypeOptional }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeTuple; type: ClarityAbiTypeTuple }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeList; type: ClarityAbiTypeList }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeStringAscii; type: ClarityAbiTypeStringAscii }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeStringUtf8; type: ClarityAbiTypeStringUtf8 };\n\nexport function getTypeUnion(val: ClarityAbiType): ClarityAbiTypeUnion {\n  if (isClarityAbiPrimitive(val)) {\n    if (val === 'uint128') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeUInt128, type: val };\n    } else if (val === 'int128') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeInt128, type: val };\n    } else if (val === 'bool') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeBool, type: val };\n    } else if (val === 'principal') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypePrincipal, type: val };\n    } else if (val === 'trait_reference') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeTraitReference, type: val };\n    } else if (val === 'none') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeNone, type: val };\n    } else {\n      throw new Error(`Unexpected Clarity ABI type primitive: ${JSON.stringify(val)}`);\n    }\n  } else if (isClarityAbiBuffer(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeBuffer, type: val };\n  } else if (isClarityAbiResponse(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeResponse, type: val };\n  } else if (isClarityAbiOptional(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeOptional, type: val };\n  } else if (isClarityAbiTuple(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeTuple, type: val };\n  } else if (isClarityAbiList(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeList, type: val };\n  } else if (isClarityAbiStringAscii(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeStringAscii, type: val };\n  } else if (isClarityAbiStringUtf8(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeStringUtf8, type: val };\n  } else {\n    throw new Error(`Unexpected Clarity ABI type: ${JSON.stringify(val)}`);\n  }\n}\n\nfunction encodeClarityValue(type: ClarityAbiType, val: string): ClarityValue;\nfunction encodeClarityValue(type: ClarityAbiTypeUnion, val: string): ClarityValue;\nfunction encodeClarityValue(\n  input: ClarityAbiTypeUnion | ClarityAbiType,\n  val: string\n): ClarityValue {\n  let union: ClarityAbiTypeUnion;\n  if ((input as ClarityAbiTypeUnion).id !== undefined) {\n    union = input as ClarityAbiTypeUnion;\n  } else {\n    union = getTypeUnion(input as ClarityAbiType);\n  }\n  switch (union.id) {\n    case ClarityAbiTypeId.ClarityAbiTypeUInt128:\n      return uintCV(val);\n    case ClarityAbiTypeId.ClarityAbiTypeInt128:\n      return intCV(val);\n    case ClarityAbiTypeId.ClarityAbiTypeBool:\n      if (val === 'false' || val === '0') return falseCV();\n      else if (val === 'true' || val === '1') return trueCV();\n      else throw new Error(`Unexpected Clarity bool value: ${JSON.stringify(val)}`);\n    case ClarityAbiTypeId.ClarityAbiTypePrincipal:\n      if (val.includes('.')) {\n        const [addr, name] = val.split('.');\n        return contractPrincipalCV(addr, name);\n      } else {\n        return standardPrincipalCV(val);\n      }\n    case ClarityAbiTypeId.ClarityAbiTypeTraitReference:\n      const [addr, name] = val.split('.');\n      return contractPrincipalCV(addr, name);\n    case ClarityAbiTypeId.ClarityAbiTypeNone:\n      return noneCV();\n    case ClarityAbiTypeId.ClarityAbiTypeBuffer:\n      return bufferCV(utf8ToBytes(val));\n    case ClarityAbiTypeId.ClarityAbiTypeStringAscii:\n      return stringAsciiCV(val);\n    case ClarityAbiTypeId.ClarityAbiTypeStringUtf8:\n      return stringUtf8CV(val);\n    case ClarityAbiTypeId.ClarityAbiTypeResponse:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n    case ClarityAbiTypeId.ClarityAbiTypeOptional:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n    case ClarityAbiTypeId.ClarityAbiTypeTuple:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n    case ClarityAbiTypeId.ClarityAbiTypeList:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n    default:\n      throw new Error(`Unexpected Clarity type ID: ${JSON.stringify(union)}`);\n  }\n}\nexport { encodeClarityValue };\n\nexport function getTypeString(val: ClarityAbiType): string {\n  if (isClarityAbiPrimitive(val)) {\n    if (val === 'int128') {\n      return 'int';\n    } else if (val === 'uint128') {\n      return 'uint';\n    }\n    return val;\n  } else if (isClarityAbiBuffer(val)) {\n    return `(buff ${val.buffer.length})`;\n  } else if (isClarityAbiStringAscii(val)) {\n    return `(string-ascii ${val['string-ascii'].length})`;\n  } else if (isClarityAbiStringUtf8(val)) {\n    return `(string-utf8 ${val['string-utf8'].length})`;\n  } else if (isClarityAbiResponse(val)) {\n    return `(response ${getTypeString(val.response.ok)} ${getTypeString(val.response.error)})`;\n  } else if (isClarityAbiOptional(val)) {\n    return `(optional ${getTypeString(val.optional)})`;\n  } else if (isClarityAbiTuple(val)) {\n    return `(tuple ${val.tuple.map(t => `(${t.name} ${getTypeString(t.type)})`).join(' ')})`;\n  } else if (isClarityAbiList(val)) {\n    return `(list ${val.list.length} ${getTypeString(val.list.type)})`;\n  } else {\n    throw new Error(`Type string unsupported for Clarity type: ${JSON.stringify(val)}`);\n  }\n}\n\nexport interface ClarityAbiFunction {\n  name: string;\n  access: 'private' | 'public' | 'read_only';\n  args: {\n    name: string;\n    type: ClarityAbiType;\n  }[];\n  outputs: {\n    type: ClarityAbiType;\n  };\n}\n\nexport function abiFunctionToString(func: ClarityAbiFunction): string {\n  const access = func.access === 'read_only' ? 'read-only' : func.access;\n  return `(define-${access} (${func.name} ${func.args\n    .map(arg => `(${arg.name} ${getTypeString(arg.type)})`)\n    .join(' ')}))`;\n}\n\nexport interface ClarityAbiVariable {\n  name: string;\n  access: 'variable' | 'constant';\n  type: ClarityAbiType;\n}\n\nexport interface ClarityAbiMap {\n  name: string;\n  key: {\n    name: string;\n    type: ClarityAbiType;\n  }[];\n  value: {\n    name: string;\n    type: ClarityAbiType;\n  }[];\n}\n\nexport interface ClarityAbiTypeFungibleToken {\n  name: string;\n}\n\nexport interface ClarityAbiTypeNonFungibleToken {\n  name: string;\n  type: ClarityAbiType;\n}\n\nexport interface ClarityAbi {\n  functions: ClarityAbiFunction[];\n  variables: ClarityAbiVariable[];\n  maps: ClarityAbiMap[];\n  fungible_tokens: ClarityAbiTypeFungibleToken[];\n  non_fungible_tokens: ClarityAbiTypeNonFungibleToken[];\n}\n\nfunction matchType(cv: ClarityValue, abiType: ClarityAbiType): boolean {\n  const union = getTypeUnion(abiType);\n\n  switch (cv.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeBool;\n    case ClarityType.Int:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeInt128;\n    case ClarityType.UInt:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeUInt128;\n    case ClarityType.Buffer:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeBuffer &&\n        union.type.buffer.length >= cv.buffer.length\n      );\n    case ClarityType.StringASCII:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeStringAscii &&\n        union.type['string-ascii'].length >= cv.data.length\n      );\n    case ClarityType.StringUTF8:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeStringUtf8 &&\n        union.type['string-utf8'].length >= cv.data.length\n      );\n    case ClarityType.OptionalNone:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeNone ||\n        union.id === ClarityAbiTypeId.ClarityAbiTypeOptional\n      );\n    case ClarityType.OptionalSome:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeOptional &&\n        matchType(cv.value, union.type.optional)\n      );\n    case ClarityType.ResponseErr:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeResponse &&\n        matchType(cv.value, union.type.response.error)\n      );\n    case ClarityType.ResponseOk:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeResponse &&\n        matchType(cv.value, union.type.response.ok)\n      );\n    case ClarityType.PrincipalContract:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypePrincipal ||\n        union.id === ClarityAbiTypeId.ClarityAbiTypeTraitReference\n      );\n    case ClarityType.PrincipalStandard:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypePrincipal;\n    case ClarityType.List:\n      return (\n        union.id == ClarityAbiTypeId.ClarityAbiTypeList &&\n        union.type.list.length >= cv.list.length &&\n        cv.list.every(val => matchType(val, union.type.list.type))\n      );\n    case ClarityType.Tuple:\n      if (union.id == ClarityAbiTypeId.ClarityAbiTypeTuple) {\n        const tuple = cloneDeep(cv.data);\n        for (let i = 0; i < union.type.tuple.length; i++) {\n          const abiTupleEntry = union.type.tuple[i];\n          const key = abiTupleEntry.name;\n          const val = tuple[key];\n\n          // if key exists in cv tuple, check if its type matches the abi\n          // return false if key doesn't exist\n          if (val) {\n            if (!matchType(val, abiTupleEntry.type)) {\n              return false;\n            }\n            delete tuple[key];\n          } else {\n            return false;\n          }\n        }\n        return true;\n      } else {\n        return false;\n      }\n    default:\n      return false;\n  }\n}\n\n/**\n * Validates a contract-call payload with a contract ABI\n *\n * @param {ContractCallPayload} payload - a contract-call payload\n * @param {ClarityAbi} abi - a contract ABI\n *\n * @returns {boolean} true if the payloads functionArgs type check against those in the ABI\n */\nexport function validateContractCall(payload: ContractCallPayload, abi: ClarityAbi): boolean {\n  const filtered = abi.functions.filter(fn => fn.name === payload.functionName.content);\n  if (filtered.length === 1) {\n    const abiFunc = filtered[0];\n    const abiArgs = abiFunc.args;\n\n    if (payload.functionArgs.length !== abiArgs.length) {\n      throw new Error(\n        `Clarity function expects ${abiArgs.length} argument(s) but received ${payload.functionArgs.length}`\n      );\n    }\n\n    for (let i = 0; i < payload.functionArgs.length; i++) {\n      const payloadArg = payload.functionArgs[i];\n      const abiArg = abiArgs[i];\n\n      if (!matchType(payloadArg, abiArg.type)) {\n        const argNum = i + 1;\n        throw new Error(\n          `Clarity function \\`${\n            payload.functionName.content\n          }\\` expects argument ${argNum} to be of type ${getTypeString(\n            abiArg.type\n          )}, not ${getCVTypeString(payloadArg)}`\n        );\n      }\n    }\n\n    return true;\n  } else if (filtered.length === 0) {\n    throw new Error(`ABI doesn't contain a function with the name ${payload.functionName.content}`);\n  } else {\n    throw new Error(\n      `Malformed ABI. Contains multiple functions with the name ${payload.functionName.content}`\n    );\n  }\n}\n\n/**\n * Convert string input to Clarity value based on contract ABI data. Only handles Clarity\n * primitives and buffers. Responses, optionals, tuples and lists are not supported.\n *\n * @param {string} input - string to be parsed into Clarity value\n * @param {ClarityAbiType} type - the contract function argument object\n *\n * @returns {ClarityValue} returns a Clarity value\n */\nexport function parseToCV(input: string, type: ClarityAbiType): ClarityValue {\n  const typeString = getTypeString(type);\n  if (isClarityAbiPrimitive(type)) {\n    if (type === 'uint128') {\n      return uintCV(input);\n    } else if (type === 'int128') {\n      return intCV(input);\n    } else if (type === 'bool') {\n      if (input.toLowerCase() === 'true') {\n        return trueCV();\n      } else if (input.toLowerCase() === 'false') {\n        return falseCV();\n      } else {\n        throw new Error(`Invalid bool value: ${input}`);\n      }\n    } else if (type === 'principal') {\n      if (input.includes('.')) {\n        const [address, contractName] = input.split('.');\n        return contractPrincipalCV(address, contractName);\n      } else {\n        return standardPrincipalCV(input);\n      }\n    } else {\n      throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n    }\n  } else if (isClarityAbiBuffer(type)) {\n    const inputLength = utf8ToBytes(input).byteLength;\n    if (inputLength > type.buffer.length) {\n      throw new Error(`Input exceeds specified buffer length limit of ${type.buffer.length}`);\n    }\n    return bufferCVFromString(input);\n  } else if (isClarityAbiResponse(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiOptional(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiTuple(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiList(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}