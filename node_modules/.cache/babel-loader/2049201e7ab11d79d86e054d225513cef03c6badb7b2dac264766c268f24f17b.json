{"ast":null,"code":"import { sha256 } from '@noble/hashes/sha256';\nimport { bytesToHex, concatBytes, utf8ToBytes } from '@stacks/common';\nimport { ClarityType, serializeCV } from './clarity';\nimport { StacksMessageType } from './constants';\nimport { signMessageHashRsv } from './keys';\nexport const STRUCTURED_DATA_PREFIX = new Uint8Array([0x53, 0x49, 0x50, 0x30, 0x31, 0x38]);\nexport function hashStructuredData(structuredData) {\n  return sha256(serializeCV(structuredData));\n}\nconst hash256BytesLength = 32;\nfunction isDomain(value) {\n  if (value.type !== ClarityType.Tuple) return false;\n  if (!['name', 'version', 'chain-id'].every(key => key in value.data)) return false;\n  if (!['name', 'version'].every(key => value.data[key].type === ClarityType.StringASCII)) return false;\n  if (value.data['chain-id'].type !== ClarityType.UInt) return false;\n  return true;\n}\nexport function encodeStructuredData(_ref) {\n  let {\n    message,\n    domain\n  } = _ref;\n  const structuredDataHash = hashStructuredData(message);\n  if (!isDomain(domain)) {\n    throw new Error(\"domain parameter must be a valid domain of type TupleCV with keys 'name', 'version', 'chain-id' with respective types StringASCII, StringASCII, UInt\");\n  }\n  const domainHash = hashStructuredData(domain);\n  return concatBytes(STRUCTURED_DATA_PREFIX, domainHash, structuredDataHash);\n}\nexport function decodeStructuredDataSignature(signature) {\n  const encodedMessageBytes = typeof signature === 'string' ? utf8ToBytes(signature) : signature;\n  const domainHash = encodedMessageBytes.slice(STRUCTURED_DATA_PREFIX.length, STRUCTURED_DATA_PREFIX.length + hash256BytesLength);\n  const messageHash = encodedMessageBytes.slice(STRUCTURED_DATA_PREFIX.length + hash256BytesLength);\n  return {\n    domainHash,\n    messageHash\n  };\n}\nexport function signStructuredData(_ref2) {\n  let {\n    message,\n    domain,\n    privateKey\n  } = _ref2;\n  const structuredDataHash = bytesToHex(sha256(encodeStructuredData({\n    message,\n    domain\n  })));\n  const {\n    data\n  } = signMessageHashRsv({\n    messageHash: structuredDataHash,\n    privateKey\n  });\n  return {\n    data,\n    type: StacksMessageType.StructuredDataSignature\n  };\n}","map":{"version":3,"names":["sha256","bytesToHex","concatBytes","utf8ToBytes","ClarityType","serializeCV","StacksMessageType","signMessageHashRsv","STRUCTURED_DATA_PREFIX","Uint8Array","hashStructuredData","structuredData","hash256BytesLength","isDomain","value","type","Tuple","every","key","data","StringASCII","UInt","encodeStructuredData","_ref","message","domain","structuredDataHash","Error","domainHash","decodeStructuredDataSignature","signature","encodedMessageBytes","slice","length","messageHash","signStructuredData","_ref2","privateKey","StructuredDataSignature"],"sources":["C:\\Users\\abasi\\Desktop\\web3-apps\\react-cra\\node_modules\\@stacks\\transactions\\src\\structuredDataSignature.ts"],"sourcesContent":["import { sha256 } from '@noble/hashes/sha256';\nimport { bytesToHex, concatBytes, utf8ToBytes } from '@stacks/common';\n\nimport { ClarityType, ClarityValue, serializeCV } from './clarity';\nimport { StacksMessageType } from './constants';\nimport { signMessageHashRsv, StacksPrivateKey } from './keys';\n\n// Refer to SIP018 https://github.com/stacksgov/sips/\n// > asciiToBytes('SIP018')\nexport const STRUCTURED_DATA_PREFIX = new Uint8Array([0x53, 0x49, 0x50, 0x30, 0x31, 0x38]);\n\nexport function hashStructuredData(structuredData: ClarityValue): Uint8Array {\n  return sha256(serializeCV(structuredData));\n}\n\nconst hash256BytesLength = 32;\n\nfunction isDomain(value: ClarityValue): boolean {\n  if (value.type !== ClarityType.Tuple) return false;\n  // Check that the tuple has at least 'name', 'version' and 'chain-id'\n  if (!['name', 'version', 'chain-id'].every(key => key in value.data)) return false;\n  // Check each key is of the right type\n  if (!['name', 'version'].every(key => value.data[key].type === ClarityType.StringASCII))\n    return false;\n\n  if (value.data['chain-id'].type !== ClarityType.UInt) return false;\n  return true;\n}\n\nexport function encodeStructuredData({\n  message,\n  domain,\n}: {\n  message: ClarityValue;\n  domain: ClarityValue;\n}): Uint8Array {\n  const structuredDataHash: Uint8Array = hashStructuredData(message);\n  if (!isDomain(domain)) {\n    throw new Error(\n      \"domain parameter must be a valid domain of type TupleCV with keys 'name', 'version', 'chain-id' with respective types StringASCII, StringASCII, UInt\"\n    );\n  }\n  const domainHash: Uint8Array = hashStructuredData(domain);\n\n  return concatBytes(STRUCTURED_DATA_PREFIX, domainHash, structuredDataHash);\n}\n\nexport type DecodedStructuredData = {\n  domainHash: Uint8Array;\n  messageHash: Uint8Array;\n};\n\nexport function decodeStructuredDataSignature(\n  signature: string | Uint8Array\n): DecodedStructuredData {\n  const encodedMessageBytes: Uint8Array =\n    typeof signature === 'string' ? utf8ToBytes(signature) : signature;\n  const domainHash = encodedMessageBytes.slice(\n    STRUCTURED_DATA_PREFIX.length,\n    STRUCTURED_DATA_PREFIX.length + hash256BytesLength\n  );\n  const messageHash = encodedMessageBytes.slice(STRUCTURED_DATA_PREFIX.length + hash256BytesLength);\n  return {\n    domainHash,\n    messageHash,\n  };\n}\n\nexport interface StructuredDataSignature {\n  readonly type: StacksMessageType.StructuredDataSignature;\n  data: string;\n}\n\n/**\n * Signs a structured message (ClarityValue) and a domain (ClarityValue) using a private key.\n * The resulting signature along with the original message can be verified using {@link verifyMessageSignature}\n * @returns A recoverable signature (in RSV order)\n */\nexport function signStructuredData({\n  message,\n  domain,\n  privateKey,\n}: {\n  message: ClarityValue;\n  domain: ClarityValue;\n  privateKey: StacksPrivateKey;\n}): StructuredDataSignature {\n  const structuredDataHash: string = bytesToHex(sha256(encodeStructuredData({ message, domain })));\n\n  const { data } = signMessageHashRsv({\n    messageHash: structuredDataHash,\n    privateKey,\n  });\n  return {\n    data,\n    type: StacksMessageType.StructuredDataSignature,\n  };\n}\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,sBAAsB;AAC7C,SAASC,UAAU,EAAEC,WAAW,EAAEC,WAAW,QAAQ,gBAAgB;AAErE,SAASC,WAAW,EAAgBC,WAAW,QAAQ,WAAW;AAClE,SAASC,iBAAiB,QAAQ,aAAa;AAC/C,SAASC,kBAAkB,QAA0B,QAAQ;AAI7D,OAAO,MAAMC,sBAAsB,GAAG,IAAIC,UAAU,CAAC,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;AAE1F,OAAM,SAAUC,kBAAkBA,CAACC,cAA4B;EAC7D,OAAOX,MAAM,CAACK,WAAW,CAACM,cAAc,CAAC,CAAC;AAC5C;AAEA,MAAMC,kBAAkB,GAAG,EAAE;AAE7B,SAASC,QAAQA,CAACC,KAAmB;EACnC,IAAIA,KAAK,CAACC,IAAI,KAAKX,WAAW,CAACY,KAAK,EAAE,OAAO,KAAK;EAElD,IAAI,CAAC,CAAC,MAAM,EAAE,SAAS,EAAE,UAAU,CAAC,CAACC,KAAK,CAACC,GAAG,IAAIA,GAAG,IAAIJ,KAAK,CAACK,IAAI,CAAC,EAAE,OAAO,KAAK;EAElF,IAAI,CAAC,CAAC,MAAM,EAAE,SAAS,CAAC,CAACF,KAAK,CAACC,GAAG,IAAIJ,KAAK,CAACK,IAAI,CAACD,GAAG,CAAC,CAACH,IAAI,KAAKX,WAAW,CAACgB,WAAW,CAAC,EACrF,OAAO,KAAK;EAEd,IAAIN,KAAK,CAACK,IAAI,CAAC,UAAU,CAAC,CAACJ,IAAI,KAAKX,WAAW,CAACiB,IAAI,EAAE,OAAO,KAAK;EAClE,OAAO,IAAI;AACb;AAEA,OAAM,SAAUC,oBAAoBA,CAAAC,IAAA,EAMnC;EAAA,IANoC;IACnCC,OAAO;IACPC;EAAM,CAIP,GAAAF,IAAA;EACC,MAAMG,kBAAkB,GAAehB,kBAAkB,CAACc,OAAO,CAAC;EAClE,IAAI,CAACX,QAAQ,CAACY,MAAM,CAAC,EAAE;IACrB,MAAM,IAAIE,KAAK,CACb,sJAAsJ,CACvJ;;EAEH,MAAMC,UAAU,GAAelB,kBAAkB,CAACe,MAAM,CAAC;EAEzD,OAAOvB,WAAW,CAACM,sBAAsB,EAAEoB,UAAU,EAAEF,kBAAkB,CAAC;AAC5E;AAOA,OAAM,SAAUG,6BAA6BA,CAC3CC,SAA8B;EAE9B,MAAMC,mBAAmB,GACvB,OAAOD,SAAS,KAAK,QAAQ,GAAG3B,WAAW,CAAC2B,SAAS,CAAC,GAAGA,SAAS;EACpE,MAAMF,UAAU,GAAGG,mBAAmB,CAACC,KAAK,CAC1CxB,sBAAsB,CAACyB,MAAM,EAC7BzB,sBAAsB,CAACyB,MAAM,GAAGrB,kBAAkB,CACnD;EACD,MAAMsB,WAAW,GAAGH,mBAAmB,CAACC,KAAK,CAACxB,sBAAsB,CAACyB,MAAM,GAAGrB,kBAAkB,CAAC;EACjG,OAAO;IACLgB,UAAU;IACVM;GACD;AACH;AAYA,OAAM,SAAUC,kBAAkBA,CAAAC,KAAA,EAQjC;EAAA,IARkC;IACjCZ,OAAO;IACPC,MAAM;IACNY;EAAU,CAKX,GAAAD,KAAA;EACC,MAAMV,kBAAkB,GAAWzB,UAAU,CAACD,MAAM,CAACsB,oBAAoB,CAAC;IAAEE,OAAO;IAAEC;EAAM,CAAE,CAAC,CAAC,CAAC;EAEhG,MAAM;IAAEN;EAAI,CAAE,GAAGZ,kBAAkB,CAAC;IAClC2B,WAAW,EAAER,kBAAkB;IAC/BW;GACD,CAAC;EACF,OAAO;IACLlB,IAAI;IACJJ,IAAI,EAAET,iBAAiB,CAACgC;GACzB;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}