{"ast":null,"code":"import { concatBytes } from '@stacks/common';\nimport { getCryptoLib } from './cryptoUtils';\nexport class NodeCryptoAesCipher {\n  constructor(createCipher, createDecipher) {\n    this.createCipher = createCipher;\n    this.createDecipher = createDecipher;\n  }\n  async encrypt(algorithm, key, iv, data) {\n    if (algorithm !== 'aes-128-cbc' && algorithm !== 'aes-256-cbc') {\n      throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n    }\n    const cipher = this.createCipher(algorithm, key, iv);\n    const result = new Uint8Array(concatBytes(cipher.update(data), cipher.final()));\n    return Promise.resolve(result);\n  }\n  async decrypt(algorithm, key, iv, data) {\n    if (algorithm !== 'aes-128-cbc' && algorithm !== 'aes-256-cbc') {\n      throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n    }\n    const cipher = this.createDecipher(algorithm, key, iv);\n    const result = new Uint8Array(concatBytes(cipher.update(data), cipher.final()));\n    return Promise.resolve(result);\n  }\n}\nexport class WebCryptoAesCipher {\n  constructor(subtleCrypto) {\n    this.subtleCrypto = subtleCrypto;\n  }\n  async encrypt(algorithm, key, iv, data) {\n    let algo;\n    let length;\n    if (algorithm === 'aes-128-cbc') {\n      algo = 'AES-CBC';\n      length = 128;\n    } else if (algorithm === 'aes-256-cbc') {\n      algo = 'AES-CBC';\n      length = 256;\n    } else {\n      throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n    }\n    const cryptoKey = await this.subtleCrypto.importKey('raw', key, {\n      name: algo,\n      length\n    }, false, ['encrypt']);\n    const result = await this.subtleCrypto.encrypt({\n      name: algo,\n      iv\n    }, cryptoKey, data);\n    return new Uint8Array(result);\n  }\n  async decrypt(algorithm, key, iv, data) {\n    let algo;\n    let length;\n    if (algorithm === 'aes-128-cbc') {\n      algo = 'AES-CBC';\n      length = 128;\n    } else if (algorithm === 'aes-256-cbc') {\n      algo = 'AES-CBC';\n      length = 256;\n    } else {\n      throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n    }\n    const cryptoKey = await this.subtleCrypto.importKey('raw', key, {\n      name: algo,\n      length\n    }, false, ['decrypt']);\n    const result = await this.subtleCrypto.decrypt({\n      name: algo,\n      iv\n    }, cryptoKey, data);\n    return new Uint8Array(result);\n  }\n}\nexport async function createCipher() {\n  const cryptoLib = await getCryptoLib();\n  if (cryptoLib.name === 'subtleCrypto') {\n    return new WebCryptoAesCipher(cryptoLib.lib);\n  }\n  return new NodeCryptoAesCipher(cryptoLib.lib.createCipheriv, cryptoLib.lib.createDecipheriv);\n}","map":{"version":3,"names":["concatBytes","getCryptoLib","NodeCryptoAesCipher","constructor","createCipher","createDecipher","encrypt","algorithm","key","iv","data","Error","cipher","result","Uint8Array","update","final","Promise","resolve","decrypt","WebCryptoAesCipher","subtleCrypto","algo","length","cryptoKey","importKey","name","cryptoLib","lib","createCipheriv","createDecipheriv"],"sources":["C:\\Users\\abasi\\Desktop\\web3-apps\\react-cra\\node_modules\\@stacks\\encryption\\src\\aesCipher.ts"],"sourcesContent":["import { concatBytes } from '@stacks/common';\nimport { getCryptoLib } from './cryptoUtils';\n\ntype NodeCryptoCreateCipher = typeof import('crypto').createCipheriv;\ntype NodeCryptoCreateDecipher = typeof import('crypto').createDecipheriv;\n\nexport type CipherAlgorithm = 'aes-256-cbc' | 'aes-128-cbc';\n\nexport interface AesCipher {\n  encrypt(\n    algorithm: CipherAlgorithm,\n    key: Uint8Array,\n    iv: Uint8Array,\n    data: Uint8Array\n  ): Promise<Uint8Array>;\n\n  decrypt(\n    algorithm: CipherAlgorithm,\n    key: Uint8Array,\n    iv: Uint8Array,\n    data: Uint8Array\n  ): Promise<Uint8Array>;\n}\n\nexport class NodeCryptoAesCipher implements AesCipher {\n  createCipher: NodeCryptoCreateCipher;\n\n  createDecipher: NodeCryptoCreateDecipher;\n\n  constructor(createCipher: NodeCryptoCreateCipher, createDecipher: NodeCryptoCreateDecipher) {\n    this.createCipher = createCipher;\n    this.createDecipher = createDecipher;\n  }\n\n  async encrypt(\n    algorithm: CipherAlgorithm,\n    key: Uint8Array,\n    iv: Uint8Array,\n    data: Uint8Array\n  ): Promise<Uint8Array> {\n    if (algorithm !== 'aes-128-cbc' && algorithm !== 'aes-256-cbc') {\n      throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n    }\n    const cipher = this.createCipher(algorithm, key, iv);\n    const result = new Uint8Array(concatBytes(cipher.update(data), cipher.final()));\n    return Promise.resolve(result);\n  }\n\n  async decrypt(\n    algorithm: CipherAlgorithm,\n    key: Uint8Array,\n    iv: Uint8Array,\n    data: Uint8Array\n  ): Promise<Uint8Array> {\n    if (algorithm !== 'aes-128-cbc' && algorithm !== 'aes-256-cbc') {\n      throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n    }\n    const cipher = this.createDecipher(algorithm, key, iv);\n    const result = new Uint8Array(concatBytes(cipher.update(data), cipher.final()));\n    return Promise.resolve(result);\n  }\n}\n\nexport class WebCryptoAesCipher implements AesCipher {\n  subtleCrypto: SubtleCrypto;\n\n  constructor(subtleCrypto: SubtleCrypto) {\n    this.subtleCrypto = subtleCrypto;\n  }\n\n  async encrypt(\n    algorithm: CipherAlgorithm,\n    key: Uint8Array,\n    iv: Uint8Array,\n    data: Uint8Array\n  ): Promise<Uint8Array> {\n    let algo: string;\n    let length: number;\n    if (algorithm === 'aes-128-cbc') {\n      algo = 'AES-CBC';\n      length = 128;\n    } else if (algorithm === 'aes-256-cbc') {\n      algo = 'AES-CBC';\n      length = 256;\n    } else {\n      throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n    }\n    const cryptoKey = await this.subtleCrypto.importKey('raw', key, { name: algo, length }, false, [\n      'encrypt',\n    ]);\n    const result = await this.subtleCrypto.encrypt({ name: algo, iv }, cryptoKey, data);\n    return new Uint8Array(result);\n  }\n\n  async decrypt(\n    algorithm: CipherAlgorithm,\n    key: Uint8Array,\n    iv: Uint8Array,\n    data: Uint8Array\n  ): Promise<Uint8Array> {\n    let algo: string;\n    let length: number;\n    if (algorithm === 'aes-128-cbc') {\n      algo = 'AES-CBC';\n      length = 128;\n    } else if (algorithm === 'aes-256-cbc') {\n      algo = 'AES-CBC';\n      length = 256;\n    } else {\n      throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n    }\n    const cryptoKey = await this.subtleCrypto.importKey('raw', key, { name: algo, length }, false, [\n      'decrypt',\n    ]);\n    const result = await this.subtleCrypto.decrypt({ name: algo, iv }, cryptoKey, data);\n    return new Uint8Array(result);\n  }\n}\n\nexport async function createCipher(): Promise<AesCipher> {\n  const cryptoLib = await getCryptoLib();\n  if (cryptoLib.name === 'subtleCrypto') {\n    return new WebCryptoAesCipher(cryptoLib.lib);\n  }\n  return new NodeCryptoAesCipher(cryptoLib.lib.createCipheriv, cryptoLib.lib.createDecipheriv);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}