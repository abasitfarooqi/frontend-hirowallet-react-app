{"ast":null,"code":"import { utf8ToBytes } from '@stacks/common';\nimport { decryptECIES, encryptECIES, signECDSA } from './ec';\nimport { getPublicKeyFromPrivate } from './keys';\nexport async function encryptContent(content, options) {\n  const opts = Object.assign({}, options);\n  let privateKey;\n  if (!opts.publicKey) {\n    if (!opts.privateKey) {\n      throw new Error('Either public key or private key must be supplied for encryption.');\n    }\n    opts.publicKey = getPublicKeyFromPrivate(opts.privateKey);\n  }\n  const wasString = typeof opts.wasString === 'boolean' ? opts.wasString : typeof content === 'string';\n  const contentBytes = typeof content === 'string' ? utf8ToBytes(content) : content;\n  const cipherObject = await encryptECIES(opts.publicKey, contentBytes, wasString, opts.cipherTextEncoding);\n  let cipherPayload = JSON.stringify(cipherObject);\n  if (opts.sign) {\n    if (typeof opts.sign === 'string') {\n      privateKey = opts.sign;\n    } else if (!privateKey) {\n      privateKey = opts.privateKey;\n    }\n    const signatureObject = signECDSA(privateKey, cipherPayload);\n    const signedCipherObject = {\n      signature: signatureObject.signature,\n      publicKey: signatureObject.publicKey,\n      cipherText: cipherPayload\n    };\n    cipherPayload = JSON.stringify(signedCipherObject);\n  }\n  return cipherPayload;\n}\nexport function decryptContent(content, options) {\n  const opts = Object.assign({}, options);\n  if (!opts.privateKey) {\n    throw new Error('Private key is required for decryption.');\n  }\n  try {\n    const cipherObject = JSON.parse(content);\n    return decryptECIES(opts.privateKey, cipherObject);\n  } catch (err) {\n    if (err instanceof SyntaxError) {\n      throw new Error('Failed to parse encrypted content JSON. The content may not ' + 'be encrypted. If using getFile, try passing { decrypt: false }.');\n    } else {\n      throw err;\n    }\n  }\n}","map":{"version":3,"names":["utf8ToBytes","decryptECIES","encryptECIES","signECDSA","getPublicKeyFromPrivate","encryptContent","content","options","opts","Object","assign","privateKey","publicKey","Error","wasString","contentBytes","cipherObject","cipherTextEncoding","cipherPayload","JSON","stringify","sign","signatureObject","signedCipherObject","signature","cipherText","decryptContent","parse","err","SyntaxError"],"sources":["C:\\Users\\abasi\\Desktop\\web3-apps\\react-cra\\node_modules\\@stacks\\encryption\\src\\encryption.ts"],"sourcesContent":["import { utf8ToBytes } from '@stacks/common';\nimport {\n  CipherTextEncoding,\n  decryptECIES,\n  encryptECIES,\n  signECDSA,\n  SignedCipherObject,\n} from './ec';\nimport { getPublicKeyFromPrivate } from './keys';\n\nexport interface EncryptionOptions {\n  /**\n   * If set to `true` the data is signed using ECDSA on SHA256 hashes with the user's\n   * app private key. If a string is specified, it is used as the private key instead\n   * of the user's app private key.\n   * @default false\n   */\n  sign?: boolean | string;\n  /**\n   * String encoding format for the cipherText bytes.\n   * Currently defaults to 'hex' for legacy backwards-compatibility.\n   * Only used if the `encrypt` option is also used.\n   * Note: in the future this should default to 'base64' for the significant\n   * file size reduction.\n   */\n  cipherTextEncoding?: CipherTextEncoding;\n  /**\n   * Specifies if the original unencrypted content is a ASCII or UTF-8 string.\n   * For example stringified JSON.\n   * If true, then when the ciphertext is decrypted, it will be returned as\n   * a `string` type variable, otherwise will be returned as bytes.\n   */\n  wasString?: boolean;\n}\n\n/**\n * Specify encryption options, and whether to sign the ciphertext.\n */\nexport interface EncryptContentOptions extends EncryptionOptions {\n  /**\n   * Encrypt the data with this key.\n   */\n  publicKey?: string;\n  /**\n   * Encrypt the data with the public key corresponding to the supplied private key\n   */\n  privateKey?: string;\n}\n\n/**\n * Encrypts the data provided with the app public key.\n * @param {string | Uint8Array} content - data to encrypt\n * @param {Object} [options=null] - options object\n * @param {String} options.publicKey - the hex string of the ECDSA public\n * key to use for encryption. If not provided, will use user's appPublicKey.\n * @return {String} Stringified ciphertext object\n */\nexport async function encryptContent(\n  content: string | Uint8Array,\n  options?: EncryptContentOptions\n): Promise<string> {\n  const opts = Object.assign({}, options);\n  let privateKey: string | undefined;\n  if (!opts.publicKey) {\n    if (!opts.privateKey) {\n      throw new Error('Either public key or private key must be supplied for encryption.');\n    }\n    opts.publicKey = getPublicKeyFromPrivate(opts.privateKey);\n  }\n  const wasString =\n    typeof opts.wasString === 'boolean' ? opts.wasString : typeof content === 'string';\n  const contentBytes = typeof content === 'string' ? utf8ToBytes(content) : content;\n  const cipherObject = await encryptECIES(\n    opts.publicKey,\n    contentBytes,\n    wasString,\n    opts.cipherTextEncoding\n  );\n  let cipherPayload = JSON.stringify(cipherObject);\n  if (opts.sign) {\n    if (typeof opts.sign === 'string') {\n      privateKey = opts.sign;\n    } else if (!privateKey) {\n      privateKey = opts.privateKey;\n    }\n    const signatureObject = signECDSA(privateKey!, cipherPayload);\n    const signedCipherObject: SignedCipherObject = {\n      signature: signatureObject.signature,\n      publicKey: signatureObject.publicKey,\n      cipherText: cipherPayload,\n    };\n    cipherPayload = JSON.stringify(signedCipherObject);\n  }\n  return cipherPayload;\n}\n\n/**\n * Decrypts data encrypted with `encryptContent` with the\n * transit private key.\n * @param {string | Uint8Array} content - encrypted content.\n * @param {Object} [options=null] - options object\n * @param {string} options.privateKey - the hex string of the ECDSA private\n * key to use for decryption. If not provided, will use user's appPrivateKey.\n * @return {string | Uint8Array} decrypted content.\n */\nexport function decryptContent(\n  content: string,\n  options?: {\n    privateKey?: string;\n  }\n): Promise<string | Uint8Array> {\n  const opts = Object.assign({}, options);\n  if (!opts.privateKey) {\n    throw new Error('Private key is required for decryption.');\n  }\n\n  try {\n    const cipherObject = JSON.parse(content);\n    return decryptECIES(opts.privateKey, cipherObject);\n  } catch (err) {\n    if (err instanceof SyntaxError) {\n      throw new Error(\n        'Failed to parse encrypted content JSON. The content may not ' +\n          'be encrypted. If using getFile, try passing { decrypt: false }.'\n      );\n    } else {\n      throw err;\n    }\n  }\n}\n"],"mappings":"AAAA,SAASA,WAAW,QAAQ,gBAAgB;AAC5C,SAEEC,YAAY,EACZC,YAAY,EACZC,SAAS,QAEJ,MAAM;AACb,SAASC,uBAAuB,QAAQ,QAAQ;AAiDhD,OAAO,eAAeC,cAAcA,CAClCC,OAA4B,EAC5BC,OAA+B;EAE/B,MAAMC,IAAI,GAAGC,MAAM,CAACC,MAAM,CAAC,EAAE,EAAEH,OAAO,CAAC;EACvC,IAAII,UAA8B;EAClC,IAAI,CAACH,IAAI,CAACI,SAAS,EAAE;IACnB,IAAI,CAACJ,IAAI,CAACG,UAAU,EAAE;MACpB,MAAM,IAAIE,KAAK,CAAC,mEAAmE,CAAC;;IAEtFL,IAAI,CAACI,SAAS,GAAGR,uBAAuB,CAACI,IAAI,CAACG,UAAU,CAAC;;EAE3D,MAAMG,SAAS,GACb,OAAON,IAAI,CAACM,SAAS,KAAK,SAAS,GAAGN,IAAI,CAACM,SAAS,GAAG,OAAOR,OAAO,KAAK,QAAQ;EACpF,MAAMS,YAAY,GAAG,OAAOT,OAAO,KAAK,QAAQ,GAAGN,WAAW,CAACM,OAAO,CAAC,GAAGA,OAAO;EACjF,MAAMU,YAAY,GAAG,MAAMd,YAAY,CACrCM,IAAI,CAACI,SAAS,EACdG,YAAY,EACZD,SAAS,EACTN,IAAI,CAACS,kBAAkB,CACxB;EACD,IAAIC,aAAa,GAAGC,IAAI,CAACC,SAAS,CAACJ,YAAY,CAAC;EAChD,IAAIR,IAAI,CAACa,IAAI,EAAE;IACb,IAAI,OAAOb,IAAI,CAACa,IAAI,KAAK,QAAQ,EAAE;MACjCV,UAAU,GAAGH,IAAI,CAACa,IAAI;KACvB,MAAM,IAAI,CAACV,UAAU,EAAE;MACtBA,UAAU,GAAGH,IAAI,CAACG,UAAU;;IAE9B,MAAMW,eAAe,GAAGnB,SAAS,CAACQ,UAAW,EAAEO,aAAa,CAAC;IAC7D,MAAMK,kBAAkB,GAAuB;MAC7CC,SAAS,EAAEF,eAAe,CAACE,SAAS;MACpCZ,SAAS,EAAEU,eAAe,CAACV,SAAS;MACpCa,UAAU,EAAEP;KACb;IACDA,aAAa,GAAGC,IAAI,CAACC,SAAS,CAACG,kBAAkB,CAAC;;EAEpD,OAAOL,aAAa;AACtB;AAWA,OAAM,SAAUQ,cAAcA,CAC5BpB,OAAe,EACfC,OAEC;EAED,MAAMC,IAAI,GAAGC,MAAM,CAACC,MAAM,CAAC,EAAE,EAAEH,OAAO,CAAC;EACvC,IAAI,CAACC,IAAI,CAACG,UAAU,EAAE;IACpB,MAAM,IAAIE,KAAK,CAAC,yCAAyC,CAAC;;EAG5D,IAAI;IACF,MAAMG,YAAY,GAAGG,IAAI,CAACQ,KAAK,CAACrB,OAAO,CAAC;IACxC,OAAOL,YAAY,CAACO,IAAI,CAACG,UAAU,EAAEK,YAAY,CAAC;GACnD,CAAC,OAAOY,GAAG,EAAE;IACZ,IAAIA,GAAG,YAAYC,WAAW,EAAE;MAC9B,MAAM,IAAIhB,KAAK,CACb,8DAA8D,GAC5D,iEAAiE,CACpE;KACF,MAAM;MACL,MAAMe,GAAG;;;AAGf"},"metadata":{},"sourceType":"module","externalDependencies":[]}