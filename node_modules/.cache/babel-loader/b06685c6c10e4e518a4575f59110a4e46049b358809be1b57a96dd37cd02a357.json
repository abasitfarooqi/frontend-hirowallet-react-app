{"ast":null,"code":"import { MAX_STRING_LENGTH_BYTES, PostConditionPrincipalID, StacksMessageType } from './constants';\nimport { c32addressDecode } from 'c32check';\nimport { exceedsMaxLengthBytes } from './utils';\nexport function parseAssetInfoString(id) {\n  const [assetAddress, assetContractName, assetTokenName] = id.split(/\\.|::/);\n  const assetInfo = createAssetInfo(assetAddress, assetContractName, assetTokenName);\n  return assetInfo;\n}\nexport function createLPString(content, lengthPrefixBytes, maxLengthBytes) {\n  const prefixLength = lengthPrefixBytes || 1;\n  const maxLength = maxLengthBytes || MAX_STRING_LENGTH_BYTES;\n  if (exceedsMaxLengthBytes(content, maxLength)) {\n    throw new Error(`String length exceeds maximum bytes ${maxLength}`);\n  }\n  return {\n    type: StacksMessageType.LengthPrefixedString,\n    content,\n    lengthPrefixBytes: prefixLength,\n    maxLengthBytes: maxLength\n  };\n}\nexport function createAssetInfo(addressString, contractName, assetName) {\n  return {\n    type: StacksMessageType.AssetInfo,\n    address: createAddress(addressString),\n    contractName: createLPString(contractName),\n    assetName: createLPString(assetName)\n  };\n}\nexport function createAddress(c32AddressString) {\n  const addressData = c32addressDecode(c32AddressString);\n  return {\n    type: StacksMessageType.Address,\n    version: addressData[0],\n    hash160: addressData[1]\n  };\n}\nexport function parsePrincipalString(principalString) {\n  if (principalString.includes('.')) {\n    const [address, contractName] = principalString.split('.');\n    return createContractPrincipal(address, contractName);\n  } else {\n    return createStandardPrincipal(principalString);\n  }\n}\nexport function createContractPrincipal(addressString, contractName) {\n  const addr = createAddress(addressString);\n  const name = createLPString(contractName);\n  return {\n    type: StacksMessageType.Principal,\n    prefix: PostConditionPrincipalID.Contract,\n    address: addr,\n    contractName: name\n  };\n}\nexport function createStandardPrincipal(addressString) {\n  const addr = createAddress(addressString);\n  return {\n    type: StacksMessageType.Principal,\n    prefix: PostConditionPrincipalID.Standard,\n    address: addr\n  };\n}","map":{"version":3,"names":["MAX_STRING_LENGTH_BYTES","PostConditionPrincipalID","StacksMessageType","c32addressDecode","exceedsMaxLengthBytes","parseAssetInfoString","id","assetAddress","assetContractName","assetTokenName","split","assetInfo","createAssetInfo","createLPString","content","lengthPrefixBytes","maxLengthBytes","prefixLength","maxLength","Error","type","LengthPrefixedString","addressString","contractName","assetName","AssetInfo","address","createAddress","c32AddressString","addressData","Address","version","hash160","parsePrincipalString","principalString","includes","createContractPrincipal","createStandardPrincipal","addr","name","Principal","prefix","Contract","Standard"],"sources":["C:\\Users\\abasi\\Desktop\\web3-apps\\react-cra\\node_modules\\@stacks\\transactions\\src\\postcondition-types.ts"],"sourcesContent":["import {\n  FungibleConditionCode,\n  MAX_STRING_LENGTH_BYTES,\n  NonFungibleConditionCode,\n  PostConditionPrincipalID,\n  PostConditionType,\n  StacksMessageType,\n} from './constants';\nimport { c32addressDecode } from 'c32check';\nimport { Address } from './common';\nimport { ClarityValue } from './clarity';\nimport { exceedsMaxLengthBytes } from './utils';\n\nexport interface StandardPrincipal {\n  readonly type: StacksMessageType.Principal;\n  readonly prefix: PostConditionPrincipalID.Standard;\n  readonly address: Address;\n}\n\nexport interface ContractPrincipal {\n  readonly type: StacksMessageType.Principal;\n  readonly prefix: PostConditionPrincipalID.Contract;\n  readonly address: Address;\n  readonly contractName: LengthPrefixedString;\n}\n\nexport interface LengthPrefixedString {\n  readonly type: StacksMessageType.LengthPrefixedString;\n  readonly content: string;\n  readonly lengthPrefixBytes: number;\n  readonly maxLengthBytes: number;\n}\n\nexport interface AssetInfo {\n  readonly type: StacksMessageType.AssetInfo;\n  readonly address: Address;\n  readonly contractName: LengthPrefixedString;\n  readonly assetName: LengthPrefixedString;\n}\n\nexport interface STXPostCondition {\n  readonly type: StacksMessageType.PostCondition;\n  readonly conditionType: PostConditionType.STX;\n  readonly principal: PostConditionPrincipal;\n  readonly conditionCode: FungibleConditionCode;\n  readonly amount: bigint;\n}\n\nexport interface FungiblePostCondition {\n  readonly type: StacksMessageType.PostCondition;\n  readonly conditionType: PostConditionType.Fungible;\n  readonly principal: PostConditionPrincipal;\n  readonly conditionCode: FungibleConditionCode;\n  readonly amount: bigint;\n  readonly assetInfo: AssetInfo;\n}\n\nexport interface NonFungiblePostCondition {\n  readonly type: StacksMessageType.PostCondition;\n  readonly conditionType: PostConditionType.NonFungible;\n  readonly principal: PostConditionPrincipal;\n  readonly conditionCode: NonFungibleConditionCode;\n  /** Structure that identifies the token type. */\n  readonly assetInfo: AssetInfo;\n  /** The Clarity value that names the token instance. */\n  readonly assetName: ClarityValue;\n}\n\nexport function parseAssetInfoString(id: string): AssetInfo {\n  const [assetAddress, assetContractName, assetTokenName] = id.split(/\\.|::/);\n  const assetInfo = createAssetInfo(assetAddress, assetContractName, assetTokenName);\n  return assetInfo;\n}\n\nexport function createLPString(content: string): LengthPrefixedString;\nexport function createLPString(content: string, lengthPrefixBytes: number): LengthPrefixedString;\nexport function createLPString(\n  content: string,\n  lengthPrefixBytes: number,\n  maxLengthBytes: number\n): LengthPrefixedString;\nexport function createLPString(\n  content: string,\n  lengthPrefixBytes?: number,\n  maxLengthBytes?: number\n): LengthPrefixedString {\n  const prefixLength = lengthPrefixBytes || 1;\n  const maxLength = maxLengthBytes || MAX_STRING_LENGTH_BYTES;\n  if (exceedsMaxLengthBytes(content, maxLength)) {\n    throw new Error(`String length exceeds maximum bytes ${maxLength}`);\n  }\n  return {\n    type: StacksMessageType.LengthPrefixedString,\n    content,\n    lengthPrefixBytes: prefixLength,\n    maxLengthBytes: maxLength,\n  };\n}\n\nexport function createAssetInfo(\n  addressString: string,\n  contractName: string,\n  assetName: string\n): AssetInfo {\n  return {\n    type: StacksMessageType.AssetInfo,\n    address: createAddress(addressString),\n    contractName: createLPString(contractName),\n    assetName: createLPString(assetName),\n  };\n}\n\nexport function createAddress(c32AddressString: string): Address {\n  const addressData = c32addressDecode(c32AddressString);\n  return {\n    type: StacksMessageType.Address,\n    version: addressData[0],\n    hash160: addressData[1],\n  };\n}\n\n/**\n * Parses a principal string for either a standard principal or contract principal.\n * @param principalString - String in the format `{address}.{contractName}`\n * @example \"SP13N5TE1FBBGRZD1FCM49QDGN32WAXM2E5F8WT2G.example-contract\"\n * @example \"SP13N5TE1FBBGRZD1FCM49QDGN32WAXM2E5F8WT2G\"\n */\nexport function parsePrincipalString(\n  principalString: string\n): StandardPrincipal | ContractPrincipal {\n  if (principalString.includes('.')) {\n    const [address, contractName] = principalString.split('.');\n    return createContractPrincipal(address, contractName);\n  } else {\n    return createStandardPrincipal(principalString);\n  }\n}\n\nexport function createContractPrincipal(\n  addressString: string,\n  contractName: string\n): ContractPrincipal {\n  const addr = createAddress(addressString);\n  const name = createLPString(contractName);\n  return {\n    type: StacksMessageType.Principal,\n    prefix: PostConditionPrincipalID.Contract,\n    address: addr,\n    contractName: name,\n  };\n}\n\nexport function createStandardPrincipal(addressString: string): StandardPrincipal {\n  const addr = createAddress(addressString);\n  return {\n    type: StacksMessageType.Principal,\n    prefix: PostConditionPrincipalID.Standard,\n    address: addr,\n  };\n}\n\nexport type PostCondition = STXPostCondition | FungiblePostCondition | NonFungiblePostCondition;\n\nexport type PostConditionPrincipal = StandardPrincipal | ContractPrincipal;\n"],"mappings":"AAAA,SAEEA,uBAAuB,EAEvBC,wBAAwB,EAExBC,iBAAiB,QACZ,aAAa;AACpB,SAASC,gBAAgB,QAAQ,UAAU;AAG3C,SAASC,qBAAqB,QAAQ,SAAS;AAyD/C,OAAM,SAAUC,oBAAoBA,CAACC,EAAU;EAC7C,MAAM,CAACC,YAAY,EAAEC,iBAAiB,EAAEC,cAAc,CAAC,GAAGH,EAAE,CAACI,KAAK,CAAC,OAAO,CAAC;EAC3E,MAAMC,SAAS,GAAGC,eAAe,CAACL,YAAY,EAAEC,iBAAiB,EAAEC,cAAc,CAAC;EAClF,OAAOE,SAAS;AAClB;AASA,OAAM,SAAUE,cAAcA,CAC5BC,OAAe,EACfC,iBAA0B,EAC1BC,cAAuB;EAEvB,MAAMC,YAAY,GAAGF,iBAAiB,IAAI,CAAC;EAC3C,MAAMG,SAAS,GAAGF,cAAc,IAAIhB,uBAAuB;EAC3D,IAAII,qBAAqB,CAACU,OAAO,EAAEI,SAAS,CAAC,EAAE;IAC7C,MAAM,IAAIC,KAAK,CAAC,uCAAuCD,SAAS,EAAE,CAAC;;EAErE,OAAO;IACLE,IAAI,EAAElB,iBAAiB,CAACmB,oBAAoB;IAC5CP,OAAO;IACPC,iBAAiB,EAAEE,YAAY;IAC/BD,cAAc,EAAEE;GACjB;AACH;AAEA,OAAM,SAAUN,eAAeA,CAC7BU,aAAqB,EACrBC,YAAoB,EACpBC,SAAiB;EAEjB,OAAO;IACLJ,IAAI,EAAElB,iBAAiB,CAACuB,SAAS;IACjCC,OAAO,EAAEC,aAAa,CAACL,aAAa,CAAC;IACrCC,YAAY,EAAEV,cAAc,CAACU,YAAY,CAAC;IAC1CC,SAAS,EAAEX,cAAc,CAACW,SAAS;GACpC;AACH;AAEA,OAAM,SAAUG,aAAaA,CAACC,gBAAwB;EACpD,MAAMC,WAAW,GAAG1B,gBAAgB,CAACyB,gBAAgB,CAAC;EACtD,OAAO;IACLR,IAAI,EAAElB,iBAAiB,CAAC4B,OAAO;IAC/BC,OAAO,EAAEF,WAAW,CAAC,CAAC,CAAC;IACvBG,OAAO,EAAEH,WAAW,CAAC,CAAC;GACvB;AACH;AAQA,OAAM,SAAUI,oBAAoBA,CAClCC,eAAuB;EAEvB,IAAIA,eAAe,CAACC,QAAQ,CAAC,GAAG,CAAC,EAAE;IACjC,MAAM,CAACT,OAAO,EAAEH,YAAY,CAAC,GAAGW,eAAe,CAACxB,KAAK,CAAC,GAAG,CAAC;IAC1D,OAAO0B,uBAAuB,CAACV,OAAO,EAAEH,YAAY,CAAC;GACtD,MAAM;IACL,OAAOc,uBAAuB,CAACH,eAAe,CAAC;;AAEnD;AAEA,OAAM,SAAUE,uBAAuBA,CACrCd,aAAqB,EACrBC,YAAoB;EAEpB,MAAMe,IAAI,GAAGX,aAAa,CAACL,aAAa,CAAC;EACzC,MAAMiB,IAAI,GAAG1B,cAAc,CAACU,YAAY,CAAC;EACzC,OAAO;IACLH,IAAI,EAAElB,iBAAiB,CAACsC,SAAS;IACjCC,MAAM,EAAExC,wBAAwB,CAACyC,QAAQ;IACzChB,OAAO,EAAEY,IAAI;IACbf,YAAY,EAAEgB;GACf;AACH;AAEA,OAAM,SAAUF,uBAAuBA,CAACf,aAAqB;EAC3D,MAAMgB,IAAI,GAAGX,aAAa,CAACL,aAAa,CAAC;EACzC,OAAO;IACLF,IAAI,EAAElB,iBAAiB,CAACsC,SAAS;IACjCC,MAAM,EAAExC,wBAAwB,CAAC0C,QAAQ;IACzCjB,OAAO,EAAEY;GACV;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}