{"ast":null,"code":"import { concatArray, intToBigInt, intToBytes, writeUInt32BE } from '@stacks/common';\nimport { ClarityVersion, COINBASE_BYTES_LENGTH, PayloadType, StacksMessageType } from './constants';\nimport { deserializeCV, serializeCV } from './clarity/';\nimport { principalCV } from './clarity/types/principalCV';\nimport { createAddress, createLPString } from './postcondition-types';\nimport { codeBodyString, createMemoString, deserializeAddress, deserializeLPString, deserializeMemoString, serializeStacksMessage } from './types';\nexport function isTokenTransferPayload(p) {\n  return p.payloadType === PayloadType.TokenTransfer;\n}\nexport function isContractCallPayload(p) {\n  return p.payloadType === PayloadType.ContractCall;\n}\nexport function isSmartContractPayload(p) {\n  return p.payloadType === PayloadType.SmartContract;\n}\nexport function isPoisonPayload(p) {\n  return p.payloadType === PayloadType.PoisonMicroblock;\n}\nexport function isCoinbasePayload(p) {\n  return p.payloadType === PayloadType.Coinbase;\n}\nexport function createTokenTransferPayload(recipient, amount, memo) {\n  var _memo;\n  if (typeof recipient === 'string') {\n    recipient = principalCV(recipient);\n  }\n  if (typeof memo === 'string') {\n    memo = createMemoString(memo);\n  }\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.TokenTransfer,\n    recipient,\n    amount: intToBigInt(amount, false),\n    memo: (_memo = memo) !== null && _memo !== void 0 ? _memo : createMemoString('')\n  };\n}\nexport function createContractCallPayload(contractAddress, contractName, functionName, functionArgs) {\n  if (typeof contractAddress === 'string') {\n    contractAddress = createAddress(contractAddress);\n  }\n  if (typeof contractName === 'string') {\n    contractName = createLPString(contractName);\n  }\n  if (typeof functionName === 'string') {\n    functionName = createLPString(functionName);\n  }\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.ContractCall,\n    contractAddress,\n    contractName,\n    functionName,\n    functionArgs\n  };\n}\nexport function createSmartContractPayload(contractName, codeBody, clarityVersion) {\n  if (typeof contractName === 'string') {\n    contractName = createLPString(contractName);\n  }\n  if (typeof codeBody === 'string') {\n    codeBody = codeBodyString(codeBody);\n  }\n  if (typeof clarityVersion === 'number') {\n    return {\n      type: StacksMessageType.Payload,\n      payloadType: PayloadType.VersionedSmartContract,\n      clarityVersion,\n      contractName,\n      codeBody\n    };\n  }\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.SmartContract,\n    contractName,\n    codeBody\n  };\n}\nexport function createPoisonPayload() {\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.PoisonMicroblock\n  };\n}\nexport function createCoinbasePayload(coinbaseBytes, altRecipient) {\n  if (coinbaseBytes.byteLength != COINBASE_BYTES_LENGTH) {\n    throw Error(`Coinbase buffer size must be ${COINBASE_BYTES_LENGTH} bytes`);\n  }\n  if (altRecipient != undefined) {\n    return {\n      type: StacksMessageType.Payload,\n      payloadType: PayloadType.CoinbaseToAltRecipient,\n      coinbaseBytes,\n      recipient: altRecipient\n    };\n  }\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.Coinbase,\n    coinbaseBytes\n  };\n}\nexport function serializePayload(payload) {\n  const bytesArray = [];\n  bytesArray.push(payload.payloadType);\n  switch (payload.payloadType) {\n    case PayloadType.TokenTransfer:\n      bytesArray.push(serializeCV(payload.recipient));\n      bytesArray.push(intToBytes(payload.amount, false, 8));\n      bytesArray.push(serializeStacksMessage(payload.memo));\n      break;\n    case PayloadType.ContractCall:\n      bytesArray.push(serializeStacksMessage(payload.contractAddress));\n      bytesArray.push(serializeStacksMessage(payload.contractName));\n      bytesArray.push(serializeStacksMessage(payload.functionName));\n      const numArgs = new Uint8Array(4);\n      writeUInt32BE(numArgs, payload.functionArgs.length, 0);\n      bytesArray.push(numArgs);\n      payload.functionArgs.forEach(arg => {\n        bytesArray.push(serializeCV(arg));\n      });\n      break;\n    case PayloadType.SmartContract:\n      bytesArray.push(serializeStacksMessage(payload.contractName));\n      bytesArray.push(serializeStacksMessage(payload.codeBody));\n      break;\n    case PayloadType.VersionedSmartContract:\n      bytesArray.push(payload.clarityVersion);\n      bytesArray.push(serializeStacksMessage(payload.contractName));\n      bytesArray.push(serializeStacksMessage(payload.codeBody));\n      break;\n    case PayloadType.PoisonMicroblock:\n      break;\n    case PayloadType.Coinbase:\n      bytesArray.push(payload.coinbaseBytes);\n      break;\n    case PayloadType.CoinbaseToAltRecipient:\n      bytesArray.push(payload.coinbaseBytes);\n      bytesArray.push(serializeCV(payload.recipient));\n      break;\n  }\n  return concatArray(bytesArray);\n}\nexport function deserializePayload(bytesReader) {\n  const payloadType = bytesReader.readUInt8Enum(PayloadType, n => {\n    throw new Error(`Cannot recognize PayloadType: ${n}`);\n  });\n  switch (payloadType) {\n    case PayloadType.TokenTransfer:\n      const recipient = deserializeCV(bytesReader);\n      const amount = intToBigInt(bytesReader.readBytes(8), false);\n      const memo = deserializeMemoString(bytesReader);\n      return createTokenTransferPayload(recipient, amount, memo);\n    case PayloadType.ContractCall:\n      const contractAddress = deserializeAddress(bytesReader);\n      const contractCallName = deserializeLPString(bytesReader);\n      const functionName = deserializeLPString(bytesReader);\n      const functionArgs = [];\n      const numberOfArgs = bytesReader.readUInt32BE();\n      for (let i = 0; i < numberOfArgs; i++) {\n        const clarityValue = deserializeCV(bytesReader);\n        functionArgs.push(clarityValue);\n      }\n      return createContractCallPayload(contractAddress, contractCallName, functionName, functionArgs);\n    case PayloadType.SmartContract:\n      const smartContractName = deserializeLPString(bytesReader);\n      const codeBody = deserializeLPString(bytesReader, 4, 100000);\n      return createSmartContractPayload(smartContractName, codeBody);\n    case PayloadType.VersionedSmartContract:\n      {\n        const clarityVersion = bytesReader.readUInt8Enum(ClarityVersion, n => {\n          throw new Error(`Cannot recognize ClarityVersion: ${n}`);\n        });\n        const smartContractName = deserializeLPString(bytesReader);\n        const codeBody = deserializeLPString(bytesReader, 4, 100000);\n        return createSmartContractPayload(smartContractName, codeBody, clarityVersion);\n      }\n    case PayloadType.PoisonMicroblock:\n      return createPoisonPayload();\n    case PayloadType.Coinbase:\n      const coinbaseBytes = bytesReader.readBytes(COINBASE_BYTES_LENGTH);\n      return createCoinbasePayload(coinbaseBytes);\n    case PayloadType.CoinbaseToAltRecipient:\n      const coinbaseToAltRecipientBuffer = bytesReader.readBytes(COINBASE_BYTES_LENGTH);\n      const altRecipient = deserializeCV(bytesReader);\n      return createCoinbasePayload(coinbaseToAltRecipientBuffer, altRecipient);\n  }\n}","map":{"version":3,"names":["concatArray","intToBigInt","intToBytes","writeUInt32BE","ClarityVersion","COINBASE_BYTES_LENGTH","PayloadType","StacksMessageType","deserializeCV","serializeCV","principalCV","createAddress","createLPString","codeBodyString","createMemoString","deserializeAddress","deserializeLPString","deserializeMemoString","serializeStacksMessage","isTokenTransferPayload","p","payloadType","TokenTransfer","isContractCallPayload","ContractCall","isSmartContractPayload","SmartContract","isPoisonPayload","PoisonMicroblock","isCoinbasePayload","Coinbase","createTokenTransferPayload","recipient","amount","memo","_memo","type","Payload","createContractCallPayload","contractAddress","contractName","functionName","functionArgs","createSmartContractPayload","codeBody","clarityVersion","VersionedSmartContract","createPoisonPayload","createCoinbasePayload","coinbaseBytes","altRecipient","byteLength","Error","undefined","CoinbaseToAltRecipient","serializePayload","payload","bytesArray","push","numArgs","Uint8Array","length","forEach","arg","deserializePayload","bytesReader","readUInt8Enum","n","readBytes","contractCallName","numberOfArgs","readUInt32BE","i","clarityValue","smartContractName","coinbaseToAltRecipientBuffer"],"sources":["C:\\Users\\abasi\\Desktop\\web3-apps\\react-cra\\node_modules\\@stacks\\transactions\\src\\payload.ts"],"sourcesContent":["import { concatArray, IntegerType, intToBigInt, intToBytes, writeUInt32BE } from '@stacks/common';\nimport { ClarityVersion, COINBASE_BYTES_LENGTH, PayloadType, StacksMessageType } from './constants';\n\nimport { BytesReader } from './bytesReader';\nimport { ClarityValue, deserializeCV, serializeCV } from './clarity/';\nimport { PrincipalCV, principalCV } from './clarity/types/principalCV';\nimport { Address } from './common';\nimport { createAddress, createLPString, LengthPrefixedString } from './postcondition-types';\nimport {\n  codeBodyString,\n  createMemoString,\n  deserializeAddress,\n  deserializeLPString,\n  deserializeMemoString,\n  MemoString,\n  serializeStacksMessage,\n} from './types';\n\nexport type Payload =\n  | TokenTransferPayload\n  | ContractCallPayload\n  | SmartContractPayload\n  | VersionedSmartContractPayload\n  | PoisonPayload\n  | CoinbasePayload\n  | CoinbasePayloadToAltRecipient;\n\nexport function isTokenTransferPayload(p: Payload): p is TokenTransferPayload {\n  return p.payloadType === PayloadType.TokenTransfer;\n}\nexport function isContractCallPayload(p: Payload): p is ContractCallPayload {\n  return p.payloadType === PayloadType.ContractCall;\n}\nexport function isSmartContractPayload(p: Payload): p is SmartContractPayload {\n  return p.payloadType === PayloadType.SmartContract;\n}\nexport function isPoisonPayload(p: Payload): p is PoisonPayload {\n  return p.payloadType === PayloadType.PoisonMicroblock;\n}\nexport function isCoinbasePayload(p: Payload): p is CoinbasePayload {\n  return p.payloadType === PayloadType.Coinbase;\n}\n\nexport interface TokenTransferPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.TokenTransfer;\n  readonly recipient: PrincipalCV;\n  readonly amount: bigint;\n  readonly memo: MemoString;\n}\n\nexport type PayloadInput =\n  | (TokenTransferPayload | (Omit<TokenTransferPayload, 'amount'> & { amount: IntegerType }))\n  | ContractCallPayload\n  | SmartContractPayload\n  | VersionedSmartContractPayload\n  | PoisonPayload\n  | CoinbasePayload\n  | CoinbasePayloadToAltRecipient;\n\nexport function createTokenTransferPayload(\n  recipient: string | PrincipalCV,\n  amount: IntegerType,\n  memo?: string | MemoString\n): TokenTransferPayload {\n  if (typeof recipient === 'string') {\n    recipient = principalCV(recipient);\n  }\n  if (typeof memo === 'string') {\n    memo = createMemoString(memo);\n  }\n\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.TokenTransfer,\n    recipient,\n    amount: intToBigInt(amount, false),\n    memo: memo ?? createMemoString(''),\n  };\n}\n\nexport interface ContractCallPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.ContractCall;\n  readonly contractAddress: Address;\n  readonly contractName: LengthPrefixedString;\n  readonly functionName: LengthPrefixedString;\n  readonly functionArgs: ClarityValue[];\n}\n\nexport function createContractCallPayload(\n  contractAddress: string | Address,\n  contractName: string | LengthPrefixedString,\n  functionName: string | LengthPrefixedString,\n  functionArgs: ClarityValue[]\n): ContractCallPayload {\n  if (typeof contractAddress === 'string') {\n    contractAddress = createAddress(contractAddress);\n  }\n  if (typeof contractName === 'string') {\n    contractName = createLPString(contractName);\n  }\n  if (typeof functionName === 'string') {\n    functionName = createLPString(functionName);\n  }\n\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.ContractCall,\n    contractAddress,\n    contractName,\n    functionName,\n    functionArgs,\n  };\n}\n\nexport interface SmartContractPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.SmartContract;\n  readonly contractName: LengthPrefixedString;\n  readonly codeBody: LengthPrefixedString;\n}\n\nexport interface VersionedSmartContractPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.VersionedSmartContract;\n  readonly clarityVersion: ClarityVersion;\n  readonly contractName: LengthPrefixedString;\n  readonly codeBody: LengthPrefixedString;\n}\n\nexport function createSmartContractPayload(\n  contractName: string | LengthPrefixedString,\n  codeBody: string | LengthPrefixedString,\n  clarityVersion?: ClarityVersion\n): SmartContractPayload | VersionedSmartContractPayload {\n  if (typeof contractName === 'string') {\n    contractName = createLPString(contractName);\n  }\n  if (typeof codeBody === 'string') {\n    codeBody = codeBodyString(codeBody);\n  }\n\n  if (typeof clarityVersion === 'number') {\n    return {\n      type: StacksMessageType.Payload,\n      payloadType: PayloadType.VersionedSmartContract,\n      clarityVersion,\n      contractName,\n      codeBody,\n    };\n  }\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.SmartContract,\n    contractName,\n    codeBody,\n  };\n}\n\nexport interface PoisonPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.PoisonMicroblock;\n}\n\nexport function createPoisonPayload(): PoisonPayload {\n  return { type: StacksMessageType.Payload, payloadType: PayloadType.PoisonMicroblock };\n}\n\nexport interface CoinbasePayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.Coinbase;\n  readonly coinbaseBytes: Uint8Array;\n}\n\nexport interface CoinbasePayloadToAltRecipient {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.CoinbaseToAltRecipient;\n  readonly coinbaseBytes: Uint8Array;\n  readonly recipient: PrincipalCV;\n}\n\nexport function createCoinbasePayload(\n  coinbaseBytes: Uint8Array,\n  altRecipient?: PrincipalCV\n): CoinbasePayload | CoinbasePayloadToAltRecipient {\n  if (coinbaseBytes.byteLength != COINBASE_BYTES_LENGTH) {\n    throw Error(`Coinbase buffer size must be ${COINBASE_BYTES_LENGTH} bytes`);\n  }\n\n  if (altRecipient != undefined) {\n    return {\n      type: StacksMessageType.Payload,\n      payloadType: PayloadType.CoinbaseToAltRecipient,\n      coinbaseBytes,\n      recipient: altRecipient,\n    };\n  }\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.Coinbase,\n    coinbaseBytes,\n  };\n}\n\nexport function serializePayload(payload: PayloadInput): Uint8Array {\n  const bytesArray = [];\n  bytesArray.push(payload.payloadType);\n\n  switch (payload.payloadType) {\n    case PayloadType.TokenTransfer:\n      bytesArray.push(serializeCV(payload.recipient));\n      bytesArray.push(intToBytes(payload.amount, false, 8));\n      bytesArray.push(serializeStacksMessage(payload.memo));\n      break;\n    case PayloadType.ContractCall:\n      bytesArray.push(serializeStacksMessage(payload.contractAddress));\n      bytesArray.push(serializeStacksMessage(payload.contractName));\n      bytesArray.push(serializeStacksMessage(payload.functionName));\n      const numArgs = new Uint8Array(4);\n      writeUInt32BE(numArgs, payload.functionArgs.length, 0);\n      bytesArray.push(numArgs);\n      payload.functionArgs.forEach(arg => {\n        bytesArray.push(serializeCV(arg));\n      });\n      break;\n    case PayloadType.SmartContract:\n      bytesArray.push(serializeStacksMessage(payload.contractName));\n      bytesArray.push(serializeStacksMessage(payload.codeBody));\n      break;\n    case PayloadType.VersionedSmartContract:\n      bytesArray.push(payload.clarityVersion);\n      bytesArray.push(serializeStacksMessage(payload.contractName));\n      bytesArray.push(serializeStacksMessage(payload.codeBody));\n      break;\n    case PayloadType.PoisonMicroblock:\n      // TODO: implement\n      break;\n    case PayloadType.Coinbase:\n      bytesArray.push(payload.coinbaseBytes);\n      break;\n    case PayloadType.CoinbaseToAltRecipient:\n      bytesArray.push(payload.coinbaseBytes);\n      bytesArray.push(serializeCV(payload.recipient));\n      break;\n  }\n\n  return concatArray(bytesArray);\n}\n\nexport function deserializePayload(bytesReader: BytesReader): Payload {\n  const payloadType = bytesReader.readUInt8Enum(PayloadType, n => {\n    throw new Error(`Cannot recognize PayloadType: ${n}`);\n  });\n\n  switch (payloadType) {\n    case PayloadType.TokenTransfer:\n      const recipient = deserializeCV(bytesReader) as PrincipalCV;\n      const amount = intToBigInt(bytesReader.readBytes(8), false);\n      const memo = deserializeMemoString(bytesReader);\n      return createTokenTransferPayload(recipient, amount, memo);\n    case PayloadType.ContractCall:\n      const contractAddress = deserializeAddress(bytesReader);\n      const contractCallName = deserializeLPString(bytesReader);\n      const functionName = deserializeLPString(bytesReader);\n      const functionArgs: ClarityValue[] = [];\n      const numberOfArgs = bytesReader.readUInt32BE();\n      for (let i = 0; i < numberOfArgs; i++) {\n        const clarityValue = deserializeCV(bytesReader);\n        functionArgs.push(clarityValue);\n      }\n      return createContractCallPayload(\n        contractAddress,\n        contractCallName,\n        functionName,\n        functionArgs\n      );\n    case PayloadType.SmartContract:\n      const smartContractName = deserializeLPString(bytesReader);\n      const codeBody = deserializeLPString(bytesReader, 4, 100_000);\n      return createSmartContractPayload(smartContractName, codeBody);\n\n    case PayloadType.VersionedSmartContract: {\n      const clarityVersion = bytesReader.readUInt8Enum(ClarityVersion, n => {\n        throw new Error(`Cannot recognize ClarityVersion: ${n}`);\n      });\n      const smartContractName = deserializeLPString(bytesReader);\n      const codeBody = deserializeLPString(bytesReader, 4, 100_000);\n      return createSmartContractPayload(smartContractName, codeBody, clarityVersion);\n    }\n    case PayloadType.PoisonMicroblock:\n      // TODO: implement\n      return createPoisonPayload();\n    case PayloadType.Coinbase:\n      const coinbaseBytes = bytesReader.readBytes(COINBASE_BYTES_LENGTH);\n      return createCoinbasePayload(coinbaseBytes);\n    case PayloadType.CoinbaseToAltRecipient:\n      const coinbaseToAltRecipientBuffer = bytesReader.readBytes(COINBASE_BYTES_LENGTH);\n      const altRecipient = deserializeCV(bytesReader) as PrincipalCV;\n      return createCoinbasePayload(coinbaseToAltRecipientBuffer, altRecipient);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}