{"ast":null,"code":"import { utf8ToBytes, writeUInt32BE } from '@stacks/common';\nimport { getCryptoLib } from './cryptoUtils';\nexport class NodeCryptoPbkdf2 {\n  constructor(nodePbkdf2) {\n    this.nodePbkdf2 = nodePbkdf2;\n  }\n  async derive(password, salt, iterations, keyLength, digest) {\n    if (digest !== 'sha512' && digest !== 'sha256') {\n      throw new Error(`Unsupported digest \"${digest}\" for Pbkdf2`);\n    }\n    return new Promise((resolve, reject) => {\n      this.nodePbkdf2(password, salt, iterations, keyLength, digest, (error, result) => {\n        if (error) {\n          reject(error);\n        }\n        resolve(result);\n      });\n    });\n  }\n}\nexport class WebCryptoPbkdf2 {\n  constructor(subtleCrypto) {\n    this.subtleCrypto = subtleCrypto;\n  }\n  async derive(password, salt, iterations, keyLength, digest) {\n    let algo;\n    if (digest === 'sha256') {\n      algo = 'SHA-256';\n    } else if (digest === 'sha512') {\n      algo = 'SHA-512';\n    } else {\n      throw new Error(`Unsupported Pbkdf2 digest algorithm \"${digest}\"`);\n    }\n    const passwordBytes = utf8ToBytes(password);\n    try {\n      const key = await this.subtleCrypto.importKey('raw', passwordBytes, 'PBKDF2', false, ['deriveBits']);\n      const result = await this.subtleCrypto.deriveBits({\n        name: 'PBKDF2',\n        salt,\n        iterations,\n        hash: {\n          name: algo\n        }\n      }, key, keyLength * 8);\n      return new Uint8Array(result);\n    } catch (error) {\n      const partialWebCrypto = new WebCryptoPartialPbkdf2(this.subtleCrypto);\n      return partialWebCrypto.derive(password, salt, iterations, keyLength, digest);\n    }\n  }\n}\nexport class WebCryptoPartialPbkdf2 {\n  constructor(subtleCrypto) {\n    this.subtleCrypto = subtleCrypto;\n  }\n  async derive(password, salt, iterations, keyLength, digest) {\n    if (digest !== 'sha512' && digest !== 'sha256') {\n      throw new Error(`Unsupported digest \"${digest}\" for Pbkdf2`);\n    }\n    const passwordBytes = utf8ToBytes(password);\n    const algo = digest === 'sha512' ? 'SHA-512' : 'SHA-256';\n    const algoOpts = {\n      name: 'HMAC',\n      hash: algo\n    };\n    const hmacDigest = (key, data) => this.subtleCrypto.importKey('raw', key, algoOpts, true, ['sign']).then(cryptoKey => this.subtleCrypto.sign(algoOpts, cryptoKey, data)).then(result => new Uint8Array(result));\n    const DK = new Uint8Array(keyLength);\n    const saltLength = salt.length;\n    const block1 = new Uint8Array(saltLength + 4);\n    block1.set(salt);\n    let destPos = 0;\n    const hLen = digest === 'sha512' ? 64 : 32;\n    const l = Math.ceil(keyLength / hLen);\n    for (let i = 1; i <= l; i++) {\n      writeUInt32BE(block1, i, saltLength);\n      const T = await hmacDigest(passwordBytes, block1);\n      let U = T;\n      for (let j = 1; j < iterations; j++) {\n        U = await hmacDigest(passwordBytes, U);\n        for (let k = 0; k < hLen; k++) {\n          T[k] ^= U[k];\n        }\n      }\n      DK.set(T.subarray(0, DK.byteLength - destPos), destPos);\n      destPos += hLen;\n    }\n    return DK;\n  }\n}\nexport async function createPbkdf2() {\n  const cryptoLib = await getCryptoLib();\n  if (cryptoLib.name === 'subtleCrypto') {\n    return new WebCryptoPbkdf2(cryptoLib.lib);\n  }\n  return new NodeCryptoPbkdf2(cryptoLib.lib.pbkdf2);\n}","map":{"version":3,"names":["utf8ToBytes","writeUInt32BE","getCryptoLib","NodeCryptoPbkdf2","constructor","nodePbkdf2","derive","password","salt","iterations","keyLength","digest","Error","Promise","resolve","reject","error","result","WebCryptoPbkdf2","subtleCrypto","algo","passwordBytes","key","importKey","deriveBits","name","hash","Uint8Array","partialWebCrypto","WebCryptoPartialPbkdf2","algoOpts","hmacDigest","data","then","cryptoKey","sign","DK","saltLength","length","block1","set","destPos","hLen","l","Math","ceil","i","T","U","j","k","subarray","byteLength","createPbkdf2","cryptoLib","lib","pbkdf2"],"sources":["C:\\Users\\abasi\\Desktop\\web3-apps\\react-cra\\node_modules\\@stacks\\encryption\\src\\pbkdf2.ts"],"sourcesContent":["import { utf8ToBytes, writeUInt32BE } from '@stacks/common';\nimport { getCryptoLib } from './cryptoUtils';\n\nexport type Pbkdf2Digests = 'sha512' | 'sha256';\n\nexport interface Pbkdf2 {\n  derive(\n    password: string,\n    salt: Uint8Array,\n    iterations: number,\n    keyLength: number,\n    digest: Pbkdf2Digests\n  ): Promise<Uint8Array>;\n}\n\ntype NodePbkdf2Fn = typeof import('crypto').pbkdf2;\n\nexport class NodeCryptoPbkdf2 implements Pbkdf2 {\n  nodePbkdf2: NodePbkdf2Fn;\n\n  constructor(nodePbkdf2: NodePbkdf2Fn) {\n    this.nodePbkdf2 = nodePbkdf2;\n  }\n\n  async derive(\n    password: string,\n    salt: Uint8Array,\n    iterations: number,\n    keyLength: number,\n    digest: Pbkdf2Digests\n  ): Promise<Uint8Array> {\n    if (digest !== 'sha512' && digest !== 'sha256') {\n      throw new Error(`Unsupported digest \"${digest}\" for Pbkdf2`);\n    }\n    return new Promise((resolve, reject) => {\n      this.nodePbkdf2(password, salt, iterations, keyLength, digest, (error, result) => {\n        if (error) {\n          reject(error);\n        }\n        resolve(result);\n      });\n    });\n  }\n}\n\nexport class WebCryptoPbkdf2 implements Pbkdf2 {\n  subtleCrypto: SubtleCrypto;\n\n  constructor(subtleCrypto: SubtleCrypto) {\n    this.subtleCrypto = subtleCrypto;\n  }\n\n  async derive(\n    password: string,\n    salt: Uint8Array,\n    iterations: number,\n    keyLength: number,\n    digest: Pbkdf2Digests\n  ): Promise<Uint8Array> {\n    let algo: string;\n    if (digest === 'sha256') {\n      algo = 'SHA-256';\n    } else if (digest === 'sha512') {\n      algo = 'SHA-512';\n    } else {\n      throw new Error(`Unsupported Pbkdf2 digest algorithm \"${digest}\"`);\n    }\n\n    const passwordBytes = utf8ToBytes(password);\n    try {\n      const key = await this.subtleCrypto.importKey('raw', passwordBytes, 'PBKDF2', false, [\n        'deriveBits',\n      ]);\n      const result = await this.subtleCrypto.deriveBits(\n        {\n          name: 'PBKDF2',\n          salt,\n          iterations,\n          hash: { name: algo },\n        },\n        key,\n        keyLength * 8\n      );\n      return new Uint8Array(result);\n    } catch (error) {\n      // Browser appears to support WebCrypto but missing pbkdf2 support.\n      const partialWebCrypto = new WebCryptoPartialPbkdf2(this.subtleCrypto);\n      return partialWebCrypto.derive(password, salt, iterations, keyLength, digest);\n    }\n  }\n}\n\nexport class WebCryptoPartialPbkdf2 implements Pbkdf2 {\n  // An async implementation for browsers that support WebCrypto hmac\n  // but not pbkdf2. Extracted from crypto-browserify/pbkdf2 and modified to\n  // use WebCrypto for hmac operations.\n  // Original: https://github.com/crypto-browserify/pbkdf2/tree/v3.0.17/lib\n\n  subtleCrypto: SubtleCrypto;\n\n  constructor(subtleCrypto: SubtleCrypto) {\n    this.subtleCrypto = subtleCrypto;\n  }\n\n  async derive(\n    password: string,\n    salt: Uint8Array,\n    iterations: number,\n    keyLength: number,\n    digest: Pbkdf2Digests\n  ): Promise<Uint8Array> {\n    if (digest !== 'sha512' && digest !== 'sha256') {\n      throw new Error(`Unsupported digest \"${digest}\" for Pbkdf2`);\n    }\n    const passwordBytes = utf8ToBytes(password);\n    const algo = digest === 'sha512' ? 'SHA-512' : 'SHA-256';\n    const algoOpts = { name: 'HMAC', hash: algo };\n    const hmacDigest = (key: ArrayBuffer, data: ArrayBuffer) =>\n      this.subtleCrypto\n        .importKey('raw', key, algoOpts, true, ['sign'])\n        .then(cryptoKey => this.subtleCrypto.sign(algoOpts, cryptoKey, data))\n        .then(result => new Uint8Array(result));\n\n    const DK = new Uint8Array(keyLength);\n    const saltLength = salt.length;\n    const block1 = new Uint8Array(saltLength + 4);\n    block1.set(salt);\n    let destPos = 0;\n    const hLen = digest === 'sha512' ? 64 : 32;\n    const l = Math.ceil(keyLength / hLen);\n\n    for (let i = 1; i <= l; i++) {\n      writeUInt32BE(block1, i, saltLength);\n      const T = await hmacDigest(passwordBytes, block1);\n      let U = T;\n      for (let j = 1; j < iterations; j++) {\n        U = await hmacDigest(passwordBytes, U);\n        for (let k = 0; k < hLen; k++) {\n          T[k] ^= U[k];\n        }\n      }\n      DK.set(T.subarray(0, DK.byteLength - destPos), destPos);\n      destPos += hLen;\n    }\n    return DK;\n  }\n}\n\nexport async function createPbkdf2(): Promise<Pbkdf2> {\n  const cryptoLib = await getCryptoLib();\n  if (cryptoLib.name === 'subtleCrypto') {\n    return new WebCryptoPbkdf2(cryptoLib.lib);\n  }\n  return new NodeCryptoPbkdf2(cryptoLib.lib.pbkdf2);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}