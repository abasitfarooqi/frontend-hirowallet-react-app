{"ast":null,"code":"import { principalToString } from './types/principalCV';\nimport { ClarityType } from './constants';\nimport { asciiToBytes, bytesToAscii, bytesToHex, utf8ToBytes } from '@stacks/common';\nexport function cvToString(val) {\n  let encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'hex';\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n      return 'true';\n    case ClarityType.BoolFalse:\n      return 'false';\n    case ClarityType.Int:\n      return val.value.toString();\n    case ClarityType.UInt:\n      return `u${val.value.toString()}`;\n    case ClarityType.Buffer:\n      if (encoding === 'tryAscii') {\n        const str = bytesToAscii(val.buffer);\n        if (/[ -~]/.test(str)) {\n          return JSON.stringify(str);\n        }\n      }\n      return `0x${bytesToHex(val.buffer)}`;\n    case ClarityType.OptionalNone:\n      return 'none';\n    case ClarityType.OptionalSome:\n      return `(some ${cvToString(val.value, encoding)})`;\n    case ClarityType.ResponseErr:\n      return `(err ${cvToString(val.value, encoding)})`;\n    case ClarityType.ResponseOk:\n      return `(ok ${cvToString(val.value, encoding)})`;\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return principalToString(val);\n    case ClarityType.List:\n      return `(list ${val.list.map(v => cvToString(v, encoding)).join(' ')})`;\n    case ClarityType.Tuple:\n      return `(tuple ${Object.keys(val.data).map(key => `(${key} ${cvToString(val.data[key], encoding)})`).join(' ')})`;\n    case ClarityType.StringASCII:\n      return `\"${val.data}\"`;\n    case ClarityType.StringUTF8:\n      return `u\"${val.data}\"`;\n  }\n}\nexport function cvToValue(val) {\n  let strictJsonCompat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n      return true;\n    case ClarityType.BoolFalse:\n      return false;\n    case ClarityType.Int:\n    case ClarityType.UInt:\n      if (strictJsonCompat) {\n        return val.value.toString();\n      }\n      return val.value;\n    case ClarityType.Buffer:\n      return `0x${bytesToHex(val.buffer)}`;\n    case ClarityType.OptionalNone:\n      return null;\n    case ClarityType.OptionalSome:\n      return cvToJSON(val.value);\n    case ClarityType.ResponseErr:\n      return cvToJSON(val.value);\n    case ClarityType.ResponseOk:\n      return cvToJSON(val.value);\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return principalToString(val);\n    case ClarityType.List:\n      return val.list.map(v => cvToJSON(v));\n    case ClarityType.Tuple:\n      const result = {};\n      Object.keys(val.data).forEach(key => {\n        result[key] = cvToJSON(val.data[key]);\n      });\n      return result;\n    case ClarityType.StringASCII:\n      return val.data;\n    case ClarityType.StringUTF8:\n      return val.data;\n  }\n}\nexport function cvToJSON(val) {\n  switch (val.type) {\n    case ClarityType.ResponseErr:\n      return {\n        type: getCVTypeString(val),\n        value: cvToValue(val, true),\n        success: false\n      };\n    case ClarityType.ResponseOk:\n      return {\n        type: getCVTypeString(val),\n        value: cvToValue(val, true),\n        success: true\n      };\n    default:\n      return {\n        type: getCVTypeString(val),\n        value: cvToValue(val, true)\n      };\n  }\n}\nexport function getCVTypeString(val) {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return 'bool';\n    case ClarityType.Int:\n      return 'int';\n    case ClarityType.UInt:\n      return 'uint';\n    case ClarityType.Buffer:\n      return `(buff ${val.buffer.length})`;\n    case ClarityType.OptionalNone:\n      return '(optional none)';\n    case ClarityType.OptionalSome:\n      return `(optional ${getCVTypeString(val.value)})`;\n    case ClarityType.ResponseErr:\n      return `(response UnknownType ${getCVTypeString(val.value)})`;\n    case ClarityType.ResponseOk:\n      return `(response ${getCVTypeString(val.value)} UnknownType)`;\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return 'principal';\n    case ClarityType.List:\n      return `(list ${val.list.length} ${val.list.length ? getCVTypeString(val.list[0]) : 'UnknownType'})`;\n    case ClarityType.Tuple:\n      return `(tuple ${Object.keys(val.data).map(key => `(${key} ${getCVTypeString(val.data[key])})`).join(' ')})`;\n    case ClarityType.StringASCII:\n      return `(string-ascii ${asciiToBytes(val.data).length})`;\n    case ClarityType.StringUTF8:\n      return `(string-utf8 ${utf8ToBytes(val.data).length})`;\n  }\n}","map":{"version":3,"names":["principalToString","ClarityType","asciiToBytes","bytesToAscii","bytesToHex","utf8ToBytes","cvToString","val","encoding","arguments","length","undefined","type","BoolTrue","BoolFalse","Int","value","toString","UInt","Buffer","str","buffer","test","JSON","stringify","OptionalNone","OptionalSome","ResponseErr","ResponseOk","PrincipalStandard","PrincipalContract","List","list","map","v","join","Tuple","Object","keys","data","key","StringASCII","StringUTF8","cvToValue","strictJsonCompat","cvToJSON","result","forEach","getCVTypeString","success"],"sources":["C:\\Users\\abasi\\Desktop\\web3-apps\\react-cra\\node_modules\\@stacks\\transactions\\src\\clarity\\clarityValue.ts"],"sourcesContent":["import {\n  BooleanCV,\n  BufferCV,\n  IntCV,\n  UIntCV,\n  StandardPrincipalCV,\n  ContractPrincipalCV,\n  ResponseErrorCV,\n  ResponseOkCV,\n  ListCV,\n  TupleCV,\n  StringAsciiCV,\n  StringUtf8CV,\n  NoneCV,\n  SomeCV,\n} from '.';\n\nimport { principalToString } from './types/principalCV';\nimport { ClarityType } from './constants';\nimport { asciiToBytes, bytesToAscii, bytesToHex, utf8ToBytes } from '@stacks/common';\n\nexport type ClarityValue =\n  | BooleanCV\n  | BufferCV\n  | IntCV\n  | UIntCV\n  | StandardPrincipalCV\n  | ContractPrincipalCV\n  | ResponseErrorCV\n  | ResponseOkCV\n  | NoneCV\n  | SomeCV\n  | ListCV\n  | TupleCV\n  | StringAsciiCV\n  | StringUtf8CV;\n\nexport function cvToString(val: ClarityValue, encoding: 'tryAscii' | 'hex' = 'hex'): string {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n      return 'true';\n    case ClarityType.BoolFalse:\n      return 'false';\n    case ClarityType.Int:\n      return val.value.toString();\n    case ClarityType.UInt:\n      return `u${val.value.toString()}`;\n    case ClarityType.Buffer:\n      if (encoding === 'tryAscii') {\n        const str = bytesToAscii(val.buffer);\n        if (/[ -~]/.test(str)) {\n          return JSON.stringify(str);\n        }\n      }\n      return `0x${bytesToHex(val.buffer)}`;\n    case ClarityType.OptionalNone:\n      return 'none';\n    case ClarityType.OptionalSome:\n      return `(some ${cvToString(val.value, encoding)})`;\n    case ClarityType.ResponseErr:\n      return `(err ${cvToString(val.value, encoding)})`;\n    case ClarityType.ResponseOk:\n      return `(ok ${cvToString(val.value, encoding)})`;\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return principalToString(val);\n    case ClarityType.List:\n      return `(list ${val.list.map(v => cvToString(v, encoding)).join(' ')})`;\n    case ClarityType.Tuple:\n      return `(tuple ${Object.keys(val.data)\n        .map(key => `(${key} ${cvToString(val.data[key], encoding)})`)\n        .join(' ')})`;\n    case ClarityType.StringASCII:\n      return `\"${val.data}\"`;\n    case ClarityType.StringUTF8:\n      return `u\"${val.data}\"`;\n  }\n}\n\n/**\n * @param strictJsonCompat If true then ints and uints are returned as JSON serializable numbers when\n * less than or equal to 53 bit length, otherwise string wrapped integers when larger than 53 bits.\n * If false, they are returned as js native `bigint`s which are _not_ JSON serializable.\n */\nexport function cvToValue(val: ClarityValue, strictJsonCompat: boolean = false): any {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n      return true;\n    case ClarityType.BoolFalse:\n      return false;\n    case ClarityType.Int:\n    case ClarityType.UInt:\n      if (strictJsonCompat) {\n        return val.value.toString();\n      }\n      return val.value;\n    case ClarityType.Buffer:\n      return `0x${bytesToHex(val.buffer)}`;\n    case ClarityType.OptionalNone:\n      return null;\n    case ClarityType.OptionalSome:\n      return cvToJSON(val.value);\n    case ClarityType.ResponseErr:\n      return cvToJSON(val.value);\n    case ClarityType.ResponseOk:\n      return cvToJSON(val.value);\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return principalToString(val);\n    case ClarityType.List:\n      return val.list.map(v => cvToJSON(v));\n    case ClarityType.Tuple:\n      const result: { [key: string]: any } = {};\n      Object.keys(val.data).forEach(key => {\n        result[key] = cvToJSON(val.data[key]);\n      });\n      return result;\n    case ClarityType.StringASCII:\n      return val.data;\n    case ClarityType.StringUTF8:\n      return val.data;\n  }\n}\n\nexport function cvToJSON(val: ClarityValue): any {\n  switch (val.type) {\n    case ClarityType.ResponseErr:\n      return { type: getCVTypeString(val), value: cvToValue(val, true), success: false };\n    case ClarityType.ResponseOk:\n      return { type: getCVTypeString(val), value: cvToValue(val, true), success: true };\n    default:\n      return { type: getCVTypeString(val), value: cvToValue(val, true) };\n  }\n}\n\nexport function getCVTypeString(val: ClarityValue): string {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return 'bool';\n    case ClarityType.Int:\n      return 'int';\n    case ClarityType.UInt:\n      return 'uint';\n    case ClarityType.Buffer:\n      return `(buff ${val.buffer.length})`;\n    case ClarityType.OptionalNone:\n      return '(optional none)';\n    case ClarityType.OptionalSome:\n      return `(optional ${getCVTypeString(val.value)})`;\n    case ClarityType.ResponseErr:\n      return `(response UnknownType ${getCVTypeString(val.value)})`;\n    case ClarityType.ResponseOk:\n      return `(response ${getCVTypeString(val.value)} UnknownType)`;\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return 'principal';\n    case ClarityType.List:\n      return `(list ${val.list.length} ${\n        val.list.length ? getCVTypeString(val.list[0]) : 'UnknownType'\n      })`;\n    case ClarityType.Tuple:\n      return `(tuple ${Object.keys(val.data)\n        .map(key => `(${key} ${getCVTypeString(val.data[key])})`)\n        .join(' ')})`;\n    case ClarityType.StringASCII:\n      return `(string-ascii ${asciiToBytes(val.data).length})`;\n    case ClarityType.StringUTF8:\n      return `(string-utf8 ${utf8ToBytes(val.data).length})`;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}