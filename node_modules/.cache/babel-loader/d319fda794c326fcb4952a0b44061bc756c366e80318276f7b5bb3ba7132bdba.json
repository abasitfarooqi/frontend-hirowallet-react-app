{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.c32checkDecode = exports.c32checkEncode = void 0;\nconst sha256_1 = require(\"@noble/hashes/sha256\");\nconst utils_1 = require(\"@noble/hashes/utils\");\nconst encoding_1 = require(\"./encoding\");\n/**\n * Get the c32check checksum of a hex-encoded string\n * @param {string} dataHex - the hex string\n * @returns {string} the c32 checksum, as a bin-encoded string\n */\nfunction c32checksum(dataHex) {\n  const dataHash = (0, sha256_1.sha256)((0, sha256_1.sha256)((0, utils_1.hexToBytes)(dataHex)));\n  const checksum = (0, utils_1.bytesToHex)(dataHash.slice(0, 4));\n  return checksum;\n}\n/**\n * Encode a hex string as a c32check string.  This is a lot like how\n * base58check works in Bitcoin-land, but this algorithm uses the\n * z-base-32 alphabet instead of the base58 alphabet.  The algorithm\n * is as follows:\n * * calculate the c32checksum of version + data\n * * c32encode version + data + c32checksum\n * @param {number} version - the version string (between 0 and 31)\n * @param {string} data - the data to encode\n * @returns {string} the c32check representation\n */\nfunction c32checkEncode(version, data) {\n  if (version < 0 || version >= 32) {\n    throw new Error('Invalid version (must be between 0 and 31)');\n  }\n  if (!data.match(/^[0-9a-fA-F]*$/)) {\n    throw new Error('Invalid data (not a hex string)');\n  }\n  data = data.toLowerCase();\n  if (data.length % 2 !== 0) {\n    data = `0${data}`;\n  }\n  let versionHex = version.toString(16);\n  if (versionHex.length === 1) {\n    versionHex = `0${versionHex}`;\n  }\n  const checksumHex = c32checksum(`${versionHex}${data}`);\n  const c32str = (0, encoding_1.c32encode)(`${data}${checksumHex}`);\n  return `${encoding_1.c32[version]}${c32str}`;\n}\nexports.c32checkEncode = c32checkEncode;\n/*\n * Decode a c32check string back into its version and data payload.  This is\n * a lot like how base58check works in Bitcoin-land, but this algorithm uses\n * the z-base-32 alphabet instead of the base58 alphabet.  The algorithm\n * is as follows:\n * * extract the version, data, and checksum\n * * verify the checksum matches c32checksum(version + data)\n * * return data\n * @param {string} c32data - the c32check-encoded string\n * @returns {array} [version (number), data (string)].  The returned data\n * will be a hex string.  Throws an exception if the checksum does not match.\n */\nfunction c32checkDecode(c32data) {\n  c32data = (0, encoding_1.c32normalize)(c32data);\n  const dataHex = (0, encoding_1.c32decode)(c32data.slice(1));\n  const versionChar = c32data[0];\n  const version = encoding_1.c32.indexOf(versionChar);\n  const checksum = dataHex.slice(-8);\n  let versionHex = version.toString(16);\n  if (versionHex.length === 1) {\n    versionHex = `0${versionHex}`;\n  }\n  if (c32checksum(`${versionHex}${dataHex.substring(0, dataHex.length - 8)}`) !== checksum) {\n    throw new Error('Invalid c32check string: checksum mismatch');\n  }\n  return [version, dataHex.substring(0, dataHex.length - 8)];\n}\nexports.c32checkDecode = c32checkDecode;","map":{"version":3,"names":["Object","defineProperty","exports","value","c32checkDecode","c32checkEncode","sha256_1","require","utils_1","encoding_1","c32checksum","dataHex","dataHash","sha256","hexToBytes","checksum","bytesToHex","slice","version","data","Error","match","toLowerCase","length","versionHex","toString","checksumHex","c32str","c32encode","c32","c32data","c32normalize","c32decode","versionChar","indexOf","substring"],"sources":["C:/Users/abasi/Desktop/web3-apps/react-cra/node_modules/c32check/lib/checksum.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.c32checkDecode = exports.c32checkEncode = void 0;\nconst sha256_1 = require(\"@noble/hashes/sha256\");\nconst utils_1 = require(\"@noble/hashes/utils\");\nconst encoding_1 = require(\"./encoding\");\n/**\n * Get the c32check checksum of a hex-encoded string\n * @param {string} dataHex - the hex string\n * @returns {string} the c32 checksum, as a bin-encoded string\n */\nfunction c32checksum(dataHex) {\n    const dataHash = (0, sha256_1.sha256)((0, sha256_1.sha256)((0, utils_1.hexToBytes)(dataHex)));\n    const checksum = (0, utils_1.bytesToHex)(dataHash.slice(0, 4));\n    return checksum;\n}\n/**\n * Encode a hex string as a c32check string.  This is a lot like how\n * base58check works in Bitcoin-land, but this algorithm uses the\n * z-base-32 alphabet instead of the base58 alphabet.  The algorithm\n * is as follows:\n * * calculate the c32checksum of version + data\n * * c32encode version + data + c32checksum\n * @param {number} version - the version string (between 0 and 31)\n * @param {string} data - the data to encode\n * @returns {string} the c32check representation\n */\nfunction c32checkEncode(version, data) {\n    if (version < 0 || version >= 32) {\n        throw new Error('Invalid version (must be between 0 and 31)');\n    }\n    if (!data.match(/^[0-9a-fA-F]*$/)) {\n        throw new Error('Invalid data (not a hex string)');\n    }\n    data = data.toLowerCase();\n    if (data.length % 2 !== 0) {\n        data = `0${data}`;\n    }\n    let versionHex = version.toString(16);\n    if (versionHex.length === 1) {\n        versionHex = `0${versionHex}`;\n    }\n    const checksumHex = c32checksum(`${versionHex}${data}`);\n    const c32str = (0, encoding_1.c32encode)(`${data}${checksumHex}`);\n    return `${encoding_1.c32[version]}${c32str}`;\n}\nexports.c32checkEncode = c32checkEncode;\n/*\n * Decode a c32check string back into its version and data payload.  This is\n * a lot like how base58check works in Bitcoin-land, but this algorithm uses\n * the z-base-32 alphabet instead of the base58 alphabet.  The algorithm\n * is as follows:\n * * extract the version, data, and checksum\n * * verify the checksum matches c32checksum(version + data)\n * * return data\n * @param {string} c32data - the c32check-encoded string\n * @returns {array} [version (number), data (string)].  The returned data\n * will be a hex string.  Throws an exception if the checksum does not match.\n */\nfunction c32checkDecode(c32data) {\n    c32data = (0, encoding_1.c32normalize)(c32data);\n    const dataHex = (0, encoding_1.c32decode)(c32data.slice(1));\n    const versionChar = c32data[0];\n    const version = encoding_1.c32.indexOf(versionChar);\n    const checksum = dataHex.slice(-8);\n    let versionHex = version.toString(16);\n    if (versionHex.length === 1) {\n        versionHex = `0${versionHex}`;\n    }\n    if (c32checksum(`${versionHex}${dataHex.substring(0, dataHex.length - 8)}`) !== checksum) {\n        throw new Error('Invalid c32check string: checksum mismatch');\n    }\n    return [version, dataHex.substring(0, dataHex.length - 8)];\n}\nexports.c32checkDecode = c32checkDecode;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}