{"ast":null,"code":"import { bytesToHex, concatArray, hexToBytes, intToBigInt, writeUInt32BE } from '@stacks/common';\nimport { AnchorMode, anchorModeFromNameOrValue, AuthType, DEFAULT_CHAIN_ID, PayloadType, PostConditionMode, PubKeyEncoding, StacksMessageType, TransactionVersion } from './constants';\nimport { deserializeAuthorization, intoInitialSighashAuth, isSingleSig, nextSignature, serializeAuthorization, setFee, setNonce, setSponsor, setSponsorNonce, verifyOrigin } from './authorization';\nimport { createTransactionAuthField } from './signature';\nimport { cloneDeep, txidFromData } from './utils';\nimport { deserializePayload, serializePayload } from './payload';\nimport { createLPList, deserializeLPList, serializeLPList } from './types';\nimport { isCompressed } from './keys';\nimport { BytesReader } from './bytesReader';\nimport { SerializationError, SigningError } from './errors';\nexport class StacksTransaction {\n  constructor(version, auth, payload, postConditions, postConditionMode, anchorMode, chainId) {\n    this.version = version;\n    this.auth = auth;\n    if ('amount' in payload) {\n      this.payload = {\n        ...payload,\n        amount: intToBigInt(payload.amount, false)\n      };\n    } else {\n      this.payload = payload;\n    }\n    this.chainId = chainId ?? DEFAULT_CHAIN_ID;\n    this.postConditionMode = postConditionMode ?? PostConditionMode.Deny;\n    this.postConditions = postConditions ?? createLPList([]);\n    if (anchorMode) {\n      this.anchorMode = anchorModeFromNameOrValue(anchorMode);\n    } else {\n      switch (payload.payloadType) {\n        case PayloadType.Coinbase:\n        case PayloadType.CoinbaseToAltRecipient:\n        case PayloadType.PoisonMicroblock:\n          {\n            this.anchorMode = AnchorMode.OnChainOnly;\n            break;\n          }\n        case PayloadType.ContractCall:\n        case PayloadType.SmartContract:\n        case PayloadType.VersionedSmartContract:\n        case PayloadType.TokenTransfer:\n          {\n            this.anchorMode = AnchorMode.Any;\n            break;\n          }\n      }\n    }\n  }\n  signBegin() {\n    const tx = cloneDeep(this);\n    tx.auth = intoInitialSighashAuth(tx.auth);\n    return tx.txid();\n  }\n  verifyBegin() {\n    const tx = cloneDeep(this);\n    tx.auth = intoInitialSighashAuth(tx.auth);\n    return tx.txid();\n  }\n  verifyOrigin() {\n    return verifyOrigin(this.auth, this.verifyBegin());\n  }\n  signNextOrigin(sigHash, privateKey) {\n    if (this.auth.spendingCondition === undefined) {\n      throw new Error('\"auth.spendingCondition\" is undefined');\n    }\n    if (this.auth.authType === undefined) {\n      throw new Error('\"auth.authType\" is undefined');\n    }\n    return this.signAndAppend(this.auth.spendingCondition, sigHash, AuthType.Standard, privateKey);\n  }\n  signNextSponsor(sigHash, privateKey) {\n    if (this.auth.authType === AuthType.Sponsored) {\n      return this.signAndAppend(this.auth.sponsorSpendingCondition, sigHash, AuthType.Sponsored, privateKey);\n    } else {\n      throw new Error('\"auth.sponsorSpendingCondition\" is undefined');\n    }\n  }\n  appendPubkey(publicKey) {\n    const cond = this.auth.spendingCondition;\n    if (cond && !isSingleSig(cond)) {\n      const compressed = isCompressed(publicKey);\n      cond.fields.push(createTransactionAuthField(compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed, publicKey));\n    } else {\n      throw new Error(`Can't append public key to a singlesig condition`);\n    }\n  }\n  signAndAppend(condition, curSigHash, authType, privateKey) {\n    const {\n      nextSig,\n      nextSigHash\n    } = nextSignature(curSigHash, authType, condition.fee, condition.nonce, privateKey);\n    if (isSingleSig(condition)) {\n      condition.signature = nextSig;\n    } else {\n      const compressed = bytesToHex(privateKey.data).endsWith('01');\n      condition.fields.push(createTransactionAuthField(compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed, nextSig));\n    }\n    return nextSigHash;\n  }\n  txid() {\n    const serialized = this.serialize();\n    return txidFromData(serialized);\n  }\n  setSponsor(sponsorSpendingCondition) {\n    if (this.auth.authType != AuthType.Sponsored) {\n      throw new SigningError('Cannot sponsor sign a non-sponsored transaction');\n    }\n    this.auth = setSponsor(this.auth, sponsorSpendingCondition);\n  }\n  setFee(amount) {\n    this.auth = setFee(this.auth, amount);\n  }\n  setNonce(nonce) {\n    this.auth = setNonce(this.auth, nonce);\n  }\n  setSponsorNonce(nonce) {\n    if (this.auth.authType != AuthType.Sponsored) {\n      throw new SigningError('Cannot sponsor sign a non-sponsored transaction');\n    }\n    this.auth = setSponsorNonce(this.auth, nonce);\n  }\n  serialize() {\n    if (this.version === undefined) {\n      throw new SerializationError('\"version\" is undefined');\n    }\n    if (this.chainId === undefined) {\n      throw new SerializationError('\"chainId\" is undefined');\n    }\n    if (this.auth === undefined) {\n      throw new SerializationError('\"auth\" is undefined');\n    }\n    if (this.anchorMode === undefined) {\n      throw new SerializationError('\"anchorMode\" is undefined');\n    }\n    if (this.payload === undefined) {\n      throw new SerializationError('\"payload\" is undefined');\n    }\n    const bytesArray = [];\n    bytesArray.push(this.version);\n    const chainIdBytes = new Uint8Array(4);\n    writeUInt32BE(chainIdBytes, this.chainId, 0);\n    bytesArray.push(chainIdBytes);\n    bytesArray.push(serializeAuthorization(this.auth));\n    bytesArray.push(this.anchorMode);\n    bytesArray.push(this.postConditionMode);\n    bytesArray.push(serializeLPList(this.postConditions));\n    bytesArray.push(serializePayload(this.payload));\n    return concatArray(bytesArray);\n  }\n}\nexport function deserializeTransaction(data) {\n  let bytesReader;\n  if (typeof data === 'string') {\n    if (data.slice(0, 2).toLowerCase() === '0x') {\n      bytesReader = new BytesReader(hexToBytes(data.slice(2)));\n    } else {\n      bytesReader = new BytesReader(hexToBytes(data));\n    }\n  } else if (data instanceof Uint8Array) {\n    bytesReader = new BytesReader(data);\n  } else {\n    bytesReader = data;\n  }\n  const version = bytesReader.readUInt8Enum(TransactionVersion, n => {\n    throw new Error(`Could not parse ${n} as TransactionVersion`);\n  });\n  const chainId = bytesReader.readUInt32BE();\n  const auth = deserializeAuthorization(bytesReader);\n  const anchorMode = bytesReader.readUInt8Enum(AnchorMode, n => {\n    throw new Error(`Could not parse ${n} as AnchorMode`);\n  });\n  const postConditionMode = bytesReader.readUInt8Enum(PostConditionMode, n => {\n    throw new Error(`Could not parse ${n} as PostConditionMode`);\n  });\n  const postConditions = deserializeLPList(bytesReader, StacksMessageType.PostCondition);\n  const payload = deserializePayload(bytesReader);\n  return new StacksTransaction(version, auth, payload, postConditions, postConditionMode, anchorMode, chainId);\n}","map":{"version":3,"names":["bytesToHex","concatArray","hexToBytes","intToBigInt","writeUInt32BE","AnchorMode","anchorModeFromNameOrValue","AuthType","DEFAULT_CHAIN_ID","PayloadType","PostConditionMode","PubKeyEncoding","StacksMessageType","TransactionVersion","deserializeAuthorization","intoInitialSighashAuth","isSingleSig","nextSignature","serializeAuthorization","setFee","setNonce","setSponsor","setSponsorNonce","verifyOrigin","createTransactionAuthField","cloneDeep","txidFromData","deserializePayload","serializePayload","createLPList","deserializeLPList","serializeLPList","isCompressed","BytesReader","SerializationError","SigningError","StacksTransaction","constructor","version","auth","payload","postConditions","postConditionMode","anchorMode","chainId","amount","Deny","payloadType","Coinbase","CoinbaseToAltRecipient","PoisonMicroblock","OnChainOnly","ContractCall","SmartContract","VersionedSmartContract","TokenTransfer","Any","signBegin","tx","txid","verifyBegin","signNextOrigin","sigHash","privateKey","spendingCondition","undefined","Error","authType","signAndAppend","Standard","signNextSponsor","Sponsored","sponsorSpendingCondition","appendPubkey","publicKey","cond","compressed","fields","push","Compressed","Uncompressed","condition","curSigHash","nextSig","nextSigHash","fee","nonce","signature","data","endsWith","serialized","serialize","bytesArray","chainIdBytes","Uint8Array","deserializeTransaction","bytesReader","slice","toLowerCase","readUInt8Enum","n","readUInt32BE","PostCondition"],"sources":["C:\\Users\\abasi\\Desktop\\web3-apps\\react-cra\\node_modules\\@stacks\\transactions\\src\\transaction.ts"],"sourcesContent":["import {\n  bytesToHex,\n  concatArray,\n  hexToBytes,\n  IntegerType,\n  intToBigInt,\n  writeUInt32BE,\n} from '@stacks/common';\nimport {\n  AnchorMode,\n  anchorModeFromNameOrValue,\n  AnchorModeName,\n  AuthType,\n  ChainID,\n  DEFAULT_CHAIN_ID,\n  PayloadType,\n  PostConditionMode,\n  PubKeyEncoding,\n  StacksMessageType,\n  TransactionVersion,\n} from './constants';\n\nimport {\n  Authorization,\n  deserializeAuthorization,\n  intoInitialSighashAuth,\n  isSingleSig,\n  nextSignature,\n  serializeAuthorization,\n  setFee,\n  setNonce,\n  setSponsor,\n  setSponsorNonce,\n  SpendingConditionOpts,\n  verifyOrigin,\n} from './authorization';\nimport { createTransactionAuthField } from './signature';\n\nimport { cloneDeep, txidFromData } from './utils';\n\nimport { deserializePayload, Payload, PayloadInput, serializePayload } from './payload';\n\nimport { createLPList, deserializeLPList, LengthPrefixedList, serializeLPList } from './types';\n\nimport { isCompressed, StacksPrivateKey, StacksPublicKey } from './keys';\n\nimport { BytesReader } from './bytesReader';\n\nimport { SerializationError, SigningError } from './errors';\n\nexport class StacksTransaction {\n  version: TransactionVersion;\n  chainId: ChainID;\n  auth: Authorization;\n  anchorMode: AnchorMode;\n  payload: Payload;\n  postConditionMode: PostConditionMode;\n  postConditions: LengthPrefixedList;\n\n  constructor(\n    version: TransactionVersion,\n    auth: Authorization,\n    payload: PayloadInput,\n    postConditions?: LengthPrefixedList,\n    postConditionMode?: PostConditionMode,\n    anchorMode?: AnchorModeName | AnchorMode,\n    chainId?: ChainID\n  ) {\n    this.version = version;\n    this.auth = auth;\n    if ('amount' in payload) {\n      this.payload = {\n        ...payload,\n        amount: intToBigInt(payload.amount, false),\n      };\n    } else {\n      this.payload = payload;\n    }\n    this.chainId = chainId ?? DEFAULT_CHAIN_ID;\n    this.postConditionMode = postConditionMode ?? PostConditionMode.Deny;\n    this.postConditions = postConditions ?? createLPList([]);\n\n    if (anchorMode) {\n      this.anchorMode = anchorModeFromNameOrValue(anchorMode);\n    } else {\n      switch (payload.payloadType) {\n        case PayloadType.Coinbase:\n        case PayloadType.CoinbaseToAltRecipient:\n        case PayloadType.PoisonMicroblock: {\n          this.anchorMode = AnchorMode.OnChainOnly;\n          break;\n        }\n        case PayloadType.ContractCall:\n        case PayloadType.SmartContract:\n        case PayloadType.VersionedSmartContract:\n        case PayloadType.TokenTransfer: {\n          this.anchorMode = AnchorMode.Any;\n          break;\n        }\n      }\n    }\n  }\n\n  signBegin() {\n    const tx = cloneDeep(this);\n    tx.auth = intoInitialSighashAuth(tx.auth);\n    return tx.txid();\n  }\n\n  verifyBegin() {\n    const tx = cloneDeep(this);\n    tx.auth = intoInitialSighashAuth(tx.auth);\n    return tx.txid();\n  }\n\n  verifyOrigin(): string {\n    return verifyOrigin(this.auth, this.verifyBegin());\n  }\n\n  signNextOrigin(sigHash: string, privateKey: StacksPrivateKey): string {\n    if (this.auth.spendingCondition === undefined) {\n      throw new Error('\"auth.spendingCondition\" is undefined');\n    }\n    if (this.auth.authType === undefined) {\n      throw new Error('\"auth.authType\" is undefined');\n    }\n    return this.signAndAppend(this.auth.spendingCondition, sigHash, AuthType.Standard, privateKey);\n  }\n\n  signNextSponsor(sigHash: string, privateKey: StacksPrivateKey): string {\n    if (this.auth.authType === AuthType.Sponsored) {\n      return this.signAndAppend(\n        this.auth.sponsorSpendingCondition,\n        sigHash,\n        AuthType.Sponsored,\n        privateKey\n      );\n    } else {\n      throw new Error('\"auth.sponsorSpendingCondition\" is undefined');\n    }\n  }\n\n  appendPubkey(publicKey: StacksPublicKey) {\n    const cond = this.auth.spendingCondition;\n    if (cond && !isSingleSig(cond)) {\n      const compressed = isCompressed(publicKey);\n      cond.fields.push(\n        createTransactionAuthField(\n          compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed,\n          publicKey\n        )\n      );\n    } else {\n      throw new Error(`Can't append public key to a singlesig condition`);\n    }\n  }\n\n  signAndAppend(\n    condition: SpendingConditionOpts,\n    curSigHash: string,\n    authType: AuthType,\n    privateKey: StacksPrivateKey\n  ): string {\n    const { nextSig, nextSigHash } = nextSignature(\n      curSigHash,\n      authType,\n      condition.fee,\n      condition.nonce,\n      privateKey\n    );\n    if (isSingleSig(condition)) {\n      condition.signature = nextSig;\n    } else {\n      const compressed = bytesToHex(privateKey.data).endsWith('01');\n      condition.fields.push(\n        createTransactionAuthField(\n          compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed,\n          nextSig\n        )\n      );\n    }\n\n    return nextSigHash;\n  }\n\n  txid(): string {\n    const serialized = this.serialize();\n    return txidFromData(serialized);\n  }\n\n  setSponsor(sponsorSpendingCondition: SpendingConditionOpts) {\n    if (this.auth.authType != AuthType.Sponsored) {\n      throw new SigningError('Cannot sponsor sign a non-sponsored transaction');\n    }\n\n    this.auth = setSponsor(this.auth, sponsorSpendingCondition);\n  }\n\n  /**\n   * Set the total fee to be paid for this transaction\n   *\n   * @param fee - the fee amount in microstacks\n   */\n  setFee(amount: IntegerType) {\n    this.auth = setFee(this.auth, amount);\n  }\n\n  /**\n   * Set the transaction nonce\n   *\n   * @param nonce - the nonce value\n   */\n  setNonce(nonce: IntegerType) {\n    this.auth = setNonce(this.auth, nonce);\n  }\n\n  /**\n   * Set the transaction sponsor nonce\n   *\n   * @param nonce - the sponsor nonce value\n   */\n  setSponsorNonce(nonce: IntegerType) {\n    if (this.auth.authType != AuthType.Sponsored) {\n      throw new SigningError('Cannot sponsor sign a non-sponsored transaction');\n    }\n\n    this.auth = setSponsorNonce(this.auth, nonce);\n  }\n\n  serialize(): Uint8Array {\n    if (this.version === undefined) {\n      throw new SerializationError('\"version\" is undefined');\n    }\n    if (this.chainId === undefined) {\n      throw new SerializationError('\"chainId\" is undefined');\n    }\n    if (this.auth === undefined) {\n      throw new SerializationError('\"auth\" is undefined');\n    }\n    if (this.anchorMode === undefined) {\n      throw new SerializationError('\"anchorMode\" is undefined');\n    }\n    if (this.payload === undefined) {\n      throw new SerializationError('\"payload\" is undefined');\n    }\n\n    const bytesArray = [];\n\n    bytesArray.push(this.version);\n    const chainIdBytes = new Uint8Array(4);\n    writeUInt32BE(chainIdBytes, this.chainId, 0);\n    bytesArray.push(chainIdBytes);\n    bytesArray.push(serializeAuthorization(this.auth));\n    bytesArray.push(this.anchorMode);\n    bytesArray.push(this.postConditionMode);\n    bytesArray.push(serializeLPList(this.postConditions));\n    bytesArray.push(serializePayload(this.payload));\n\n    return concatArray(bytesArray);\n  }\n}\n\n/**\n * @param data Uint8Array or hex string\n */\nexport function deserializeTransaction(data: BytesReader | Uint8Array | string) {\n  let bytesReader: BytesReader;\n  if (typeof data === 'string') {\n    if (data.slice(0, 2).toLowerCase() === '0x') {\n      bytesReader = new BytesReader(hexToBytes(data.slice(2)));\n    } else {\n      bytesReader = new BytesReader(hexToBytes(data));\n    }\n  } else if (data instanceof Uint8Array) {\n    bytesReader = new BytesReader(data);\n  } else {\n    bytesReader = data;\n  }\n  const version = bytesReader.readUInt8Enum(TransactionVersion, n => {\n    throw new Error(`Could not parse ${n} as TransactionVersion`);\n  });\n  const chainId = bytesReader.readUInt32BE();\n  const auth = deserializeAuthorization(bytesReader);\n  const anchorMode = bytesReader.readUInt8Enum(AnchorMode, n => {\n    throw new Error(`Could not parse ${n} as AnchorMode`);\n  });\n  const postConditionMode = bytesReader.readUInt8Enum(PostConditionMode, n => {\n    throw new Error(`Could not parse ${n} as PostConditionMode`);\n  });\n  const postConditions = deserializeLPList(bytesReader, StacksMessageType.PostCondition);\n  const payload = deserializePayload(bytesReader);\n\n  return new StacksTransaction(\n    version,\n    auth,\n    payload,\n    postConditions,\n    postConditionMode,\n    anchorMode,\n    chainId\n  );\n}\n"],"mappings":"AAAA,SACEA,UAAU,EACVC,WAAW,EACXC,UAAU,EAEVC,WAAW,EACXC,aAAa,QACR,gBAAgB;AACvB,SACEC,UAAU,EACVC,yBAAyB,EAEzBC,QAAQ,EAERC,gBAAgB,EAChBC,WAAW,EACXC,iBAAiB,EACjBC,cAAc,EACdC,iBAAiB,EACjBC,kBAAkB,QACb,aAAa;AAEpB,SAEEC,wBAAwB,EACxBC,sBAAsB,EACtBC,WAAW,EACXC,aAAa,EACbC,sBAAsB,EACtBC,MAAM,EACNC,QAAQ,EACRC,UAAU,EACVC,eAAe,EAEfC,YAAY,QACP,iBAAiB;AACxB,SAASC,0BAA0B,QAAQ,aAAa;AAExD,SAASC,SAAS,EAAEC,YAAY,QAAQ,SAAS;AAEjD,SAASC,kBAAkB,EAAyBC,gBAAgB,QAAQ,WAAW;AAEvF,SAASC,YAAY,EAAEC,iBAAiB,EAAsBC,eAAe,QAAQ,SAAS;AAE9F,SAASC,YAAY,QAA2C,QAAQ;AAExE,SAASC,WAAW,QAAQ,eAAe;AAE3C,SAASC,kBAAkB,EAAEC,YAAY,QAAQ,UAAU;AAE3D,OAAM,MAAOC,iBAAiB;EAS5BC,YACEC,OAA2B,EAC3BC,IAAmB,EACnBC,OAAqB,EACrBC,cAAmC,EACnCC,iBAAqC,EACrCC,UAAwC,EACxCC,OAAiB;IAEjB,IAAI,CAACN,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,IAAI,GAAGA,IAAI;IAChB,IAAI,QAAQ,IAAIC,OAAO,EAAE;MACvB,IAAI,CAACA,OAAO,GAAG;QACb,GAAGA,OAAO;QACVK,MAAM,EAAE1C,WAAW,CAACqC,OAAO,CAACK,MAAM,EAAE,KAAK;OAC1C;KACF,MAAM;MACL,IAAI,CAACL,OAAO,GAAGA,OAAO;;IAExB,IAAI,CAACI,OAAO,GAAGA,OAAO,IAAIpC,gBAAgB;IAC1C,IAAI,CAACkC,iBAAiB,GAAGA,iBAAiB,IAAIhC,iBAAiB,CAACoC,IAAI;IACpE,IAAI,CAACL,cAAc,GAAGA,cAAc,IAAIZ,YAAY,CAAC,EAAE,CAAC;IAExD,IAAIc,UAAU,EAAE;MACd,IAAI,CAACA,UAAU,GAAGrC,yBAAyB,CAACqC,UAAU,CAAC;KACxD,MAAM;MACL,QAAQH,OAAO,CAACO,WAAW;QACzB,KAAKtC,WAAW,CAACuC,QAAQ;QACzB,KAAKvC,WAAW,CAACwC,sBAAsB;QACvC,KAAKxC,WAAW,CAACyC,gBAAgB;UAAE;YACjC,IAAI,CAACP,UAAU,GAAGtC,UAAU,CAAC8C,WAAW;YACxC;;QAEF,KAAK1C,WAAW,CAAC2C,YAAY;QAC7B,KAAK3C,WAAW,CAAC4C,aAAa;QAC9B,KAAK5C,WAAW,CAAC6C,sBAAsB;QACvC,KAAK7C,WAAW,CAAC8C,aAAa;UAAE;YAC9B,IAAI,CAACZ,UAAU,GAAGtC,UAAU,CAACmD,GAAG;YAChC;;;;EAIR;EAEAC,SAASA,CAAA;IACP,MAAMC,EAAE,GAAGjC,SAAS,CAAC,IAAI,CAAC;IAC1BiC,EAAE,CAACnB,IAAI,GAAGxB,sBAAsB,CAAC2C,EAAE,CAACnB,IAAI,CAAC;IACzC,OAAOmB,EAAE,CAACC,IAAI,EAAE;EAClB;EAEAC,WAAWA,CAAA;IACT,MAAMF,EAAE,GAAGjC,SAAS,CAAC,IAAI,CAAC;IAC1BiC,EAAE,CAACnB,IAAI,GAAGxB,sBAAsB,CAAC2C,EAAE,CAACnB,IAAI,CAAC;IACzC,OAAOmB,EAAE,CAACC,IAAI,EAAE;EAClB;EAEApC,YAAYA,CAAA;IACV,OAAOA,YAAY,CAAC,IAAI,CAACgB,IAAI,EAAE,IAAI,CAACqB,WAAW,EAAE,CAAC;EACpD;EAEAC,cAAcA,CAACC,OAAe,EAAEC,UAA4B;IAC1D,IAAI,IAAI,CAACxB,IAAI,CAACyB,iBAAiB,KAAKC,SAAS,EAAE;MAC7C,MAAM,IAAIC,KAAK,CAAC,uCAAuC,CAAC;;IAE1D,IAAI,IAAI,CAAC3B,IAAI,CAAC4B,QAAQ,KAAKF,SAAS,EAAE;MACpC,MAAM,IAAIC,KAAK,CAAC,8BAA8B,CAAC;;IAEjD,OAAO,IAAI,CAACE,aAAa,CAAC,IAAI,CAAC7B,IAAI,CAACyB,iBAAiB,EAAEF,OAAO,EAAEvD,QAAQ,CAAC8D,QAAQ,EAAEN,UAAU,CAAC;EAChG;EAEAO,eAAeA,CAACR,OAAe,EAAEC,UAA4B;IAC3D,IAAI,IAAI,CAACxB,IAAI,CAAC4B,QAAQ,KAAK5D,QAAQ,CAACgE,SAAS,EAAE;MAC7C,OAAO,IAAI,CAACH,aAAa,CACvB,IAAI,CAAC7B,IAAI,CAACiC,wBAAwB,EAClCV,OAAO,EACPvD,QAAQ,CAACgE,SAAS,EAClBR,UAAU,CACX;KACF,MAAM;MACL,MAAM,IAAIG,KAAK,CAAC,8CAA8C,CAAC;;EAEnE;EAEAO,YAAYA,CAACC,SAA0B;IACrC,MAAMC,IAAI,GAAG,IAAI,CAACpC,IAAI,CAACyB,iBAAiB;IACxC,IAAIW,IAAI,IAAI,CAAC3D,WAAW,CAAC2D,IAAI,CAAC,EAAE;MAC9B,MAAMC,UAAU,GAAG5C,YAAY,CAAC0C,SAAS,CAAC;MAC1CC,IAAI,CAACE,MAAM,CAACC,IAAI,CACdtD,0BAA0B,CACxBoD,UAAU,GAAGjE,cAAc,CAACoE,UAAU,GAAGpE,cAAc,CAACqE,YAAY,EACpEN,SAAS,CACV,CACF;KACF,MAAM;MACL,MAAM,IAAIR,KAAK,CAAC,kDAAkD,CAAC;;EAEvE;EAEAE,aAAaA,CACXa,SAAgC,EAChCC,UAAkB,EAClBf,QAAkB,EAClBJ,UAA4B;IAE5B,MAAM;MAAEoB,OAAO;MAAEC;IAAW,CAAE,GAAGnE,aAAa,CAC5CiE,UAAU,EACVf,QAAQ,EACRc,SAAS,CAACI,GAAG,EACbJ,SAAS,CAACK,KAAK,EACfvB,UAAU,CACX;IACD,IAAI/C,WAAW,CAACiE,SAAS,CAAC,EAAE;MAC1BA,SAAS,CAACM,SAAS,GAAGJ,OAAO;KAC9B,MAAM;MACL,MAAMP,UAAU,GAAG5E,UAAU,CAAC+D,UAAU,CAACyB,IAAI,CAAC,CAACC,QAAQ,CAAC,IAAI,CAAC;MAC7DR,SAAS,CAACJ,MAAM,CAACC,IAAI,CACnBtD,0BAA0B,CACxBoD,UAAU,GAAGjE,cAAc,CAACoE,UAAU,GAAGpE,cAAc,CAACqE,YAAY,EACpEG,OAAO,CACR,CACF;;IAGH,OAAOC,WAAW;EACpB;EAEAzB,IAAIA,CAAA;IACF,MAAM+B,UAAU,GAAG,IAAI,CAACC,SAAS,EAAE;IACnC,OAAOjE,YAAY,CAACgE,UAAU,CAAC;EACjC;EAEArE,UAAUA,CAACmD,wBAA+C;IACxD,IAAI,IAAI,CAACjC,IAAI,CAAC4B,QAAQ,IAAI5D,QAAQ,CAACgE,SAAS,EAAE;MAC5C,MAAM,IAAIpC,YAAY,CAAC,iDAAiD,CAAC;;IAG3E,IAAI,CAACI,IAAI,GAAGlB,UAAU,CAAC,IAAI,CAACkB,IAAI,EAAEiC,wBAAwB,CAAC;EAC7D;EAOArD,MAAMA,CAAC0B,MAAmB;IACxB,IAAI,CAACN,IAAI,GAAGpB,MAAM,CAAC,IAAI,CAACoB,IAAI,EAAEM,MAAM,CAAC;EACvC;EAOAzB,QAAQA,CAACkE,KAAkB;IACzB,IAAI,CAAC/C,IAAI,GAAGnB,QAAQ,CAAC,IAAI,CAACmB,IAAI,EAAE+C,KAAK,CAAC;EACxC;EAOAhE,eAAeA,CAACgE,KAAkB;IAChC,IAAI,IAAI,CAAC/C,IAAI,CAAC4B,QAAQ,IAAI5D,QAAQ,CAACgE,SAAS,EAAE;MAC5C,MAAM,IAAIpC,YAAY,CAAC,iDAAiD,CAAC;;IAG3E,IAAI,CAACI,IAAI,GAAGjB,eAAe,CAAC,IAAI,CAACiB,IAAI,EAAE+C,KAAK,CAAC;EAC/C;EAEAK,SAASA,CAAA;IACP,IAAI,IAAI,CAACrD,OAAO,KAAK2B,SAAS,EAAE;MAC9B,MAAM,IAAI/B,kBAAkB,CAAC,wBAAwB,CAAC;;IAExD,IAAI,IAAI,CAACU,OAAO,KAAKqB,SAAS,EAAE;MAC9B,MAAM,IAAI/B,kBAAkB,CAAC,wBAAwB,CAAC;;IAExD,IAAI,IAAI,CAACK,IAAI,KAAK0B,SAAS,EAAE;MAC3B,MAAM,IAAI/B,kBAAkB,CAAC,qBAAqB,CAAC;;IAErD,IAAI,IAAI,CAACS,UAAU,KAAKsB,SAAS,EAAE;MACjC,MAAM,IAAI/B,kBAAkB,CAAC,2BAA2B,CAAC;;IAE3D,IAAI,IAAI,CAACM,OAAO,KAAKyB,SAAS,EAAE;MAC9B,MAAM,IAAI/B,kBAAkB,CAAC,wBAAwB,CAAC;;IAGxD,MAAM0D,UAAU,GAAG,EAAE;IAErBA,UAAU,CAACd,IAAI,CAAC,IAAI,CAACxC,OAAO,CAAC;IAC7B,MAAMuD,YAAY,GAAG,IAAIC,UAAU,CAAC,CAAC,CAAC;IACtC1F,aAAa,CAACyF,YAAY,EAAE,IAAI,CAACjD,OAAO,EAAE,CAAC,CAAC;IAC5CgD,UAAU,CAACd,IAAI,CAACe,YAAY,CAAC;IAC7BD,UAAU,CAACd,IAAI,CAAC5D,sBAAsB,CAAC,IAAI,CAACqB,IAAI,CAAC,CAAC;IAClDqD,UAAU,CAACd,IAAI,CAAC,IAAI,CAACnC,UAAU,CAAC;IAChCiD,UAAU,CAACd,IAAI,CAAC,IAAI,CAACpC,iBAAiB,CAAC;IACvCkD,UAAU,CAACd,IAAI,CAAC/C,eAAe,CAAC,IAAI,CAACU,cAAc,CAAC,CAAC;IACrDmD,UAAU,CAACd,IAAI,CAAClD,gBAAgB,CAAC,IAAI,CAACY,OAAO,CAAC,CAAC;IAE/C,OAAOvC,WAAW,CAAC2F,UAAU,CAAC;EAChC;;AAMF,OAAM,SAAUG,sBAAsBA,CAACP,IAAuC;EAC5E,IAAIQ,WAAwB;EAC5B,IAAI,OAAOR,IAAI,KAAK,QAAQ,EAAE;IAC5B,IAAIA,IAAI,CAACS,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAACC,WAAW,EAAE,KAAK,IAAI,EAAE;MAC3CF,WAAW,GAAG,IAAI/D,WAAW,CAAC/B,UAAU,CAACsF,IAAI,CAACS,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;KACzD,MAAM;MACLD,WAAW,GAAG,IAAI/D,WAAW,CAAC/B,UAAU,CAACsF,IAAI,CAAC,CAAC;;GAElD,MAAM,IAAIA,IAAI,YAAYM,UAAU,EAAE;IACrCE,WAAW,GAAG,IAAI/D,WAAW,CAACuD,IAAI,CAAC;GACpC,MAAM;IACLQ,WAAW,GAAGR,IAAI;;EAEpB,MAAMlD,OAAO,GAAG0D,WAAW,CAACG,aAAa,CAACtF,kBAAkB,EAAEuF,CAAC,IAAG;IAChE,MAAM,IAAIlC,KAAK,CAAC,mBAAmBkC,CAAC,wBAAwB,CAAC;EAC/D,CAAC,CAAC;EACF,MAAMxD,OAAO,GAAGoD,WAAW,CAACK,YAAY,EAAE;EAC1C,MAAM9D,IAAI,GAAGzB,wBAAwB,CAACkF,WAAW,CAAC;EAClD,MAAMrD,UAAU,GAAGqD,WAAW,CAACG,aAAa,CAAC9F,UAAU,EAAE+F,CAAC,IAAG;IAC3D,MAAM,IAAIlC,KAAK,CAAC,mBAAmBkC,CAAC,gBAAgB,CAAC;EACvD,CAAC,CAAC;EACF,MAAM1D,iBAAiB,GAAGsD,WAAW,CAACG,aAAa,CAACzF,iBAAiB,EAAE0F,CAAC,IAAG;IACzE,MAAM,IAAIlC,KAAK,CAAC,mBAAmBkC,CAAC,uBAAuB,CAAC;EAC9D,CAAC,CAAC;EACF,MAAM3D,cAAc,GAAGX,iBAAiB,CAACkE,WAAW,EAAEpF,iBAAiB,CAAC0F,aAAa,CAAC;EACtF,MAAM9D,OAAO,GAAGb,kBAAkB,CAACqE,WAAW,CAAC;EAE/C,OAAO,IAAI5D,iBAAiB,CAC1BE,OAAO,EACPC,IAAI,EACJC,OAAO,EACPC,cAAc,EACdC,iBAAiB,EACjBC,UAAU,EACVC,OAAO,CACR;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}