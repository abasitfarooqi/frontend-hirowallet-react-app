{"ast":null,"code":"import { bytesToHex, bytesToUtf8, getGlobalObject, hexToBytes, makeUUID4, nextMonth, utf8ToBytes } from '@stacks/common';\nimport { decryptECIES, encryptECIES, makeECPrivateKey, publicKeyToBtcAddress } from '@stacks/encryption';\nimport { SECP256K1Client, TokenSigner } from 'jsontokens';\nimport { DEFAULT_SCOPE } from './constants';\nimport { makeDIDFromAddress } from './dids';\nconst VERSION = '1.4.0';\nexport function generateTransitKey() {\n  const transitKey = makeECPrivateKey();\n  return transitKey;\n}\nexport const makeAuthRequest = makeAuthRequestToken;\nexport function makeAuthRequestToken(transitPrivateKey, redirectURI, manifestURI) {\n  let scopes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_SCOPE.slice();\n  let appDomain = arguments.length > 4 ? arguments[4] : undefined;\n  let expiresAt = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : nextMonth().getTime();\n  let extraParams = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n  const getWindowOrigin = paramName => {\n    const location = getGlobalObject('location', {\n      throwIfUnavailable: true,\n      usageDesc: `makeAuthRequest([${paramName}=undefined])`\n    });\n    return location?.origin;\n  };\n  if (!redirectURI) {\n    redirectURI = `${getWindowOrigin('redirectURI')}/`;\n  }\n  if (!manifestURI) {\n    manifestURI = `${getWindowOrigin('manifestURI')}/manifest.json`;\n  }\n  if (!appDomain) {\n    appDomain = getWindowOrigin('appDomain');\n  }\n  const payload = Object.assign({}, extraParams, {\n    jti: makeUUID4(),\n    iat: Math.floor(new Date().getTime() / 1000),\n    exp: Math.floor(expiresAt / 1000),\n    iss: null,\n    public_keys: [],\n    domain_name: appDomain,\n    manifest_uri: manifestURI,\n    redirect_uri: redirectURI,\n    version: VERSION,\n    do_not_include_profile: true,\n    supports_hub_url: true,\n    scopes\n  });\n  const publicKey = SECP256K1Client.derivePublicKey(transitPrivateKey);\n  payload.public_keys = [publicKey];\n  const address = publicKeyToBtcAddress(publicKey);\n  payload.iss = makeDIDFromAddress(address);\n  const tokenSigner = new TokenSigner('ES256k', transitPrivateKey);\n  const token = tokenSigner.sign(payload);\n  return token;\n}\nexport async function encryptPrivateKey(publicKey, privateKey) {\n  const encryptedObj = await encryptECIES(publicKey, utf8ToBytes(privateKey), true);\n  const encryptedJSON = JSON.stringify(encryptedObj);\n  return bytesToHex(utf8ToBytes(encryptedJSON));\n}\nexport async function decryptPrivateKey(privateKey, hexedEncrypted) {\n  const unhexedString = bytesToUtf8(hexToBytes(hexedEncrypted));\n  const encryptedObj = JSON.parse(unhexedString);\n  const decrypted = await decryptECIES(privateKey, encryptedObj);\n  if (typeof decrypted !== 'string') {\n    throw new Error('Unable to correctly decrypt private key');\n  } else {\n    return decrypted;\n  }\n}\nexport async function makeAuthResponse(privateKey) {\n  let profile = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let metadata = arguments.length > 2 ? arguments[2] : undefined;\n  let coreToken = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  let appPrivateKey = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  let expiresAt = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : nextMonth().getTime();\n  let transitPublicKey = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  let hubUrl = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n  let blockstackAPIUrl = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;\n  let associationToken = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;\n  let appPrivateKeyFromWalletSalt = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : null;\n  const publicKey = SECP256K1Client.derivePublicKey(privateKey);\n  const address = publicKeyToBtcAddress(publicKey);\n  let privateKeyPayload = appPrivateKey;\n  let coreTokenPayload = coreToken;\n  let additionalProperties = {};\n  if (appPrivateKey !== undefined && appPrivateKey !== null) {\n    if (transitPublicKey !== undefined && transitPublicKey !== null) {\n      privateKeyPayload = await encryptPrivateKey(transitPublicKey, appPrivateKey);\n      if (coreToken !== undefined && coreToken !== null) {\n        coreTokenPayload = await encryptPrivateKey(transitPublicKey, coreToken);\n      }\n    }\n    additionalProperties = {\n      email: metadata?.email ? metadata.email : null,\n      profile_url: metadata?.profileUrl ? metadata.profileUrl : null,\n      hubUrl,\n      blockstackAPIUrl,\n      associationToken,\n      version: VERSION\n    };\n  } else {}\n  const payload = Object.assign({}, {\n    jti: makeUUID4(),\n    iat: Math.floor(new Date().getTime() / 1000),\n    exp: Math.floor(expiresAt / 1000),\n    iss: makeDIDFromAddress(address),\n    private_key: privateKeyPayload,\n    public_keys: [publicKey],\n    appPrivateKeyFromWalletSalt,\n    profile,\n    core_token: coreTokenPayload\n  }, additionalProperties);\n  const tokenSigner = new TokenSigner('ES256k', privateKey);\n  return tokenSigner.sign(payload);\n}","map":{"version":3,"names":["bytesToHex","bytesToUtf8","getGlobalObject","hexToBytes","makeUUID4","nextMonth","utf8ToBytes","decryptECIES","encryptECIES","makeECPrivateKey","publicKeyToBtcAddress","SECP256K1Client","TokenSigner","DEFAULT_SCOPE","makeDIDFromAddress","VERSION","generateTransitKey","transitKey","makeAuthRequest","makeAuthRequestToken","transitPrivateKey","redirectURI","manifestURI","scopes","arguments","length","undefined","slice","appDomain","expiresAt","getTime","extraParams","getWindowOrigin","paramName","location","throwIfUnavailable","usageDesc","origin","payload","Object","assign","jti","iat","Math","floor","Date","exp","iss","public_keys","domain_name","manifest_uri","redirect_uri","version","do_not_include_profile","supports_hub_url","publicKey","derivePublicKey","address","tokenSigner","token","sign","encryptPrivateKey","privateKey","encryptedObj","encryptedJSON","JSON","stringify","decryptPrivateKey","hexedEncrypted","unhexedString","parse","decrypted","Error","makeAuthResponse","profile","metadata","coreToken","appPrivateKey","transitPublicKey","hubUrl","blockstackAPIUrl","associationToken","appPrivateKeyFromWalletSalt","privateKeyPayload","coreTokenPayload","additionalProperties","email","profile_url","profileUrl","private_key","core_token"],"sources":["C:\\Users\\abasi\\Desktop\\web3-apps\\react-cra\\node_modules\\@stacks\\auth\\src\\messages.ts"],"sourcesContent":["import {\n  bytesToHex,\n  bytesToUtf8,\n  getGlobalObject,\n  hexToBytes,\n  makeUUID4,\n  nextMonth,\n  utf8ToBytes,\n} from '@stacks/common';\nimport {\n  decryptECIES,\n  encryptECIES,\n  makeECPrivateKey,\n  publicKeyToBtcAddress,\n} from '@stacks/encryption';\nimport { SECP256K1Client, TokenSigner } from 'jsontokens';\nimport { AuthScope, DEFAULT_SCOPE } from './constants';\nimport { makeDIDFromAddress } from './dids';\n\nconst VERSION = '1.4.0';\n\ntype AuthMetadata = {\n  email?: string;\n  profileUrl?: string;\n};\n\n/**\n * Generates a ECDSA keypair to\n * use as the ephemeral app transit private key\n * @param {SessionData} session - session object in which key will be stored\n * @return {String} the hex encoded private key\n * @private\n * @ignore\n */\nexport function generateTransitKey() {\n  const transitKey = makeECPrivateKey();\n  return transitKey;\n}\n\n/** @deprecated {@link makeAuthRequest} was renamed to {@link makeAuthRequestToken} */\nexport const makeAuthRequest = makeAuthRequestToken;\n\n/**\n * Generates an authentication request that can be sent to the Blockstack\n * browser for the user to approve sign in. This authentication request can\n * then be used for sign in by passing it to the `redirectToSignInWithAuthRequest`\n * method.\n *\n * *Note: This method should only be used if you want to roll your own authentication\n * flow. Typically you'd use `redirectToSignIn` which takes care of this\n * under the hood.*\n *\n * @param  {String} transitPrivateKey - hex encoded transit private key\n * @param {String} redirectURI - location to redirect user to after sign in approval\n * @param {String} manifestURI - location of this app's manifest file\n * @param {(AuthScope | string)[]} scopes - the permissions this app is requesting\n * @param {String} appDomain - the origin of this app\n * @param {Number} expiresAt - the time at which this request is no longer valid\n * @param {Object} extraParams - Any extra parameters you'd like to pass to the authenticator.\n * Use this to pass options that aren't part of the Blockstack auth spec, but might be supported\n * by special authenticators.\n * @return {String} the authentication request\n */\nexport function makeAuthRequestToken(\n  transitPrivateKey: string,\n  redirectURI?: string,\n  manifestURI?: string,\n  scopes: (AuthScope | string)[] = DEFAULT_SCOPE.slice(),\n  appDomain?: string,\n  expiresAt: number = nextMonth().getTime(),\n  extraParams: any = {}\n): string {\n  const getWindowOrigin = (paramName: string) => {\n    const location = getGlobalObject('location', {\n      throwIfUnavailable: true,\n      usageDesc: `makeAuthRequest([${paramName}=undefined])`,\n    });\n    return location?.origin;\n  };\n\n  if (!redirectURI) {\n    redirectURI = `${getWindowOrigin('redirectURI')}/`;\n  }\n  if (!manifestURI) {\n    manifestURI = `${getWindowOrigin('manifestURI')}/manifest.json`;\n  }\n  if (!appDomain) {\n    appDomain = getWindowOrigin('appDomain');\n  }\n\n  /* Create the payload */\n  const payload = Object.assign({}, extraParams, {\n    jti: makeUUID4(),\n    iat: Math.floor(new Date().getTime() / 1000), // JWT times are in seconds\n    exp: Math.floor(expiresAt / 1000), // JWT times are in seconds\n    iss: null,\n    public_keys: [],\n    domain_name: appDomain,\n    manifest_uri: manifestURI,\n    redirect_uri: redirectURI,\n    version: VERSION,\n    do_not_include_profile: true,\n    supports_hub_url: true,\n    scopes,\n  });\n\n  // Logger.info(`blockstack.js: generating v${VERSION} auth request`)\n\n  /* Convert the private key to a public key to an issuer */\n  const publicKey = SECP256K1Client.derivePublicKey(transitPrivateKey);\n  payload.public_keys = [publicKey];\n  const address = publicKeyToBtcAddress(publicKey);\n  payload.iss = makeDIDFromAddress(address);\n\n  /* Sign and return the token */\n  const tokenSigner = new TokenSigner('ES256k', transitPrivateKey);\n  const token = tokenSigner.sign(payload);\n\n  return token;\n}\n\n/**\n * Encrypts the private key for decryption by the given\n * public key.\n * @param  {String} publicKey  [description]\n * @param  {String} privateKey [description]\n * @return {String} hex encoded ciphertext\n * @private\n * @ignore\n */\nexport async function encryptPrivateKey(publicKey: string, privateKey: string): Promise<string> {\n  const encryptedObj = await encryptECIES(publicKey, utf8ToBytes(privateKey), true);\n  const encryptedJSON = JSON.stringify(encryptedObj);\n  return bytesToHex(utf8ToBytes(encryptedJSON));\n}\n\n/**\n * Decrypts the hex encrypted private key\n * @param  {String} privateKey  the private key corresponding to the public\n * key for which the ciphertext was encrypted\n * @param  {String} hexedEncrypted the ciphertext\n * @return {String}  the decrypted private key\n * @throws {Error} if unable to decrypt\n *\n * @private\n * @ignore\n */\nexport async function decryptPrivateKey(\n  privateKey: string,\n  hexedEncrypted: string\n): Promise<string | null> {\n  const unhexedString = bytesToUtf8(hexToBytes(hexedEncrypted));\n  const encryptedObj = JSON.parse(unhexedString);\n  const decrypted = await decryptECIES(privateKey, encryptedObj);\n  if (typeof decrypted !== 'string') {\n    throw new Error('Unable to correctly decrypt private key');\n  } else {\n    return decrypted;\n  }\n}\n\n/**\n * Generates a signed authentication response token for an app. This\n * token is sent back to apps which use contents to access the\n * resources and data requested by the app.\n *\n * @param  {String} privateKey the identity key of the Blockstack ID generating\n * the authentication response\n * @param  {Object} profile the profile object for the Blockstack ID\n * @param  {AuthMetadata} metadata an object containing metadata sent as part of the authentication\n * response including `email` if requested and available and a URL to the profile\n * @param  {String} coreToken core session token when responding to a legacy auth request\n * or `null` for current direct to gaia authentication requests\n * @param  {String} appPrivateKey the application private key. This private key is\n * unique and specific for every Blockstack ID and application combination.\n * @param  {Number} expiresAt an integer in the same format as\n * `new Date().getTime()`, milliseconds since the Unix epoch\n * @param {String} transitPublicKey the public key provide by the app\n * in its authentication request with which secrets will be encrypted\n * @param {String} hubUrl URL to the write path of the user's Gaia hub\n * @param {String} blockstackAPIUrl URL to the API endpoint to use\n * @param {String} associationToken JWT that binds the app key to the identity key\n * @return {String} signed and encoded authentication response token\n * @private\n * @ignore\n */\nexport async function makeAuthResponse(\n  privateKey: string,\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  profile: {} = {},\n  metadata: AuthMetadata | null,\n  coreToken: string | null = null,\n  appPrivateKey: string | null = null,\n  expiresAt: number = nextMonth().getTime(),\n  transitPublicKey: string | null = null,\n  hubUrl: string | null = null,\n  blockstackAPIUrl: string | null = null,\n  associationToken: string | null = null,\n  appPrivateKeyFromWalletSalt: string | null = null\n): Promise<string> {\n  /* Convert the private key to a public key to an issuer */\n  const publicKey = SECP256K1Client.derivePublicKey(privateKey);\n  const address = publicKeyToBtcAddress(publicKey);\n\n  /* See if we should encrypt with the transit key */\n  let privateKeyPayload = appPrivateKey;\n  let coreTokenPayload = coreToken;\n  let additionalProperties = {};\n  if (appPrivateKey !== undefined && appPrivateKey !== null) {\n    // Logger.info(`blockstack.js: generating v${VERSION} auth response`)\n    if (transitPublicKey !== undefined && transitPublicKey !== null) {\n      privateKeyPayload = await encryptPrivateKey(transitPublicKey, appPrivateKey);\n      if (coreToken !== undefined && coreToken !== null) {\n        coreTokenPayload = await encryptPrivateKey(transitPublicKey, coreToken);\n      }\n    }\n    additionalProperties = {\n      email: metadata?.email ? metadata.email : null,\n      profile_url: metadata?.profileUrl ? metadata.profileUrl : null,\n      hubUrl,\n      blockstackAPIUrl,\n      associationToken,\n      version: VERSION,\n    };\n  } else {\n    // Logger.info('blockstack.js: generating legacy auth response')\n  }\n\n  /* Create the payload */\n  const payload = Object.assign(\n    {},\n    {\n      jti: makeUUID4(),\n      iat: Math.floor(new Date().getTime() / 1000), // JWT times are in seconds\n      exp: Math.floor(expiresAt / 1000), // JWT times are in seconds\n      iss: makeDIDFromAddress(address),\n      private_key: privateKeyPayload,\n      public_keys: [publicKey],\n      appPrivateKeyFromWalletSalt,\n      profile,\n      core_token: coreTokenPayload,\n    },\n    additionalProperties\n  );\n\n  /* Sign and return the token */\n  const tokenSigner = new TokenSigner('ES256k', privateKey);\n  return tokenSigner.sign(payload);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}