{"ast":null,"code":"import { hmac } from '@noble/hashes/hmac';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { getPublicKey, getSharedSecret, Point, Signature, signSync, utils, verify } from '@noble/secp256k1';\nimport { bigIntToBytes, bytesToHex, bytesToUtf8, concatBytes, FailedDecryptionError, hexToBigInt, hexToBytes, parseRecoverableSignatureVrs, signatureRsvToVrs, utf8ToBytes } from '@stacks/common';\nimport { fromByteArray, toByteArray } from 'base64-js';\nimport { createCipher } from './aesCipher';\nimport { getPublicKeyFromPrivate } from './keys';\nimport { encodeMessage, hashMessage } from './messageSignature';\nimport { hashSha256Sync, hashSha512Sync } from './sha2Hash';\nimport { getAesCbcOutputLength, getBase64OutputLength } from './utils';\nutils.hmacSha256Sync = function (key) {\n  const h = hmac.create(sha256, key);\n  for (var _len = arguments.length, msgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    msgs[_key - 1] = arguments[_key];\n  }\n  msgs.forEach(msg => h.update(msg));\n  return h.digest();\n};\nexport var InvalidPublicKeyReason;\n(function (InvalidPublicKeyReason) {\n  InvalidPublicKeyReason[\"InvalidFormat\"] = \"InvalidFormat\";\n  InvalidPublicKeyReason[\"IsNotPoint\"] = \"IsNotPoint\";\n})(InvalidPublicKeyReason || (InvalidPublicKeyReason = {}));\nexport async function aes256CbcEncrypt(iv, key, plaintext) {\n  const cipher = await createCipher();\n  return await cipher.encrypt('aes-256-cbc', key, iv, plaintext);\n}\nasync function aes256CbcDecrypt(iv, key, ciphertext) {\n  const cipher = await createCipher();\n  return await cipher.decrypt('aes-256-cbc', key, iv, ciphertext);\n}\nexport function hmacSha256(key, content) {\n  return hmac(sha256, key, content);\n}\nfunction equalsConstTime(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  let res = 0;\n  for (let i = 0; i < a.length; i++) {\n    res |= a[i] ^ b[i];\n  }\n  return res === 0;\n}\nfunction sharedSecretToKeys(sharedSecret) {\n  const hashedSecret = hashSha512Sync(sharedSecret);\n  return {\n    encryptionKey: hashedSecret.slice(0, 32),\n    hmacKey: hashedSecret.slice(32)\n  };\n}\nfunction allHexChars(maybe) {\n  return maybe.match(/^[0-9a-f]+$/i) !== null;\n}\nfunction isValidPublicKey(pub) {\n  const invalidFormat = {\n    result: false,\n    reason_data: 'Invalid public key format',\n    reason: InvalidPublicKeyReason.InvalidFormat\n  };\n  const invalidPoint = {\n    result: false,\n    reason_data: 'Public key is not a point',\n    reason: InvalidPublicKeyReason.IsNotPoint\n  };\n  if (pub.length !== 66 && pub.length !== 130) return invalidFormat;\n  const firstByte = pub.slice(0, 2);\n  if (pub.length === 130 && firstByte !== '04') return invalidFormat;\n  if (pub.length === 66 && firstByte !== '02' && firstByte !== '03') return invalidFormat;\n  if (!allHexChars(pub)) return invalidFormat;\n  try {\n    const point = Point.fromHex(pub);\n    point.assertValidity();\n    return {\n      result: true,\n      reason_data: null,\n      reason: null\n    };\n  } catch (e) {\n    return invalidPoint;\n  }\n}\nexport function getHexFromBN(bnInput) {\n  const hexOut = bnInput.toString(16);\n  if (hexOut.length === 64) {\n    return hexOut;\n  } else if (hexOut.length < 64) {\n    const padding = '0'.repeat(64 - hexOut.length);\n    return `${padding}${hexOut}`;\n  } else {\n    throw new Error('Generated a > 32-byte BN for encryption. Failing.');\n  }\n}\nexport function getBytesFromBN(bnInput) {\n  const result = bigIntToBytes(bnInput, 32);\n  if (result.byteLength !== 32) {\n    throw new Error('Failed to generate a 32-byte Uint8Array');\n  }\n  return result;\n}\nexport function getCipherObjectWrapper(opts) {\n  const shell = {\n    iv: '',\n    ephemeralPK: '',\n    mac: '',\n    cipherText: '',\n    wasString: !!opts.wasString\n  };\n  if (opts.cipherTextEncoding === 'base64') {\n    shell.cipherTextEncoding = 'base64';\n  }\n  const ivLength = 32;\n  const ephemeralPKLength = 66;\n  const macLength = 64;\n  return {\n    payloadValuesLength: ivLength + ephemeralPKLength + macLength,\n    payloadShell: JSON.stringify(shell)\n  };\n}\nexport function getSignedCipherObjectWrapper(payloadShell) {\n  const shell = {\n    signature: '',\n    publicKey: '',\n    cipherText: payloadShell\n  };\n  const signatureLength = 144;\n  const publicKeyLength = 66;\n  return {\n    signedPayloadValuesLength: signatureLength + publicKeyLength,\n    signedPayloadShell: JSON.stringify(shell)\n  };\n}\nexport function eciesGetJsonStringLength(opts) {\n  const {\n    payloadShell,\n    payloadValuesLength\n  } = getCipherObjectWrapper(opts);\n  const cipherTextLength = getAesCbcOutputLength(opts.contentLength);\n  let encodedCipherTextLength;\n  if (!opts.cipherTextEncoding || opts.cipherTextEncoding === 'hex') {\n    encodedCipherTextLength = cipherTextLength * 2;\n  } else if (opts.cipherTextEncoding === 'base64') {\n    encodedCipherTextLength = getBase64OutputLength(cipherTextLength);\n  } else {\n    throw new Error(`Unexpected cipherTextEncoding \"${opts.cipherTextEncoding}\"`);\n  }\n  if (!opts.sign) {\n    return payloadShell.length + payloadValuesLength + encodedCipherTextLength;\n  } else {\n    const {\n      signedPayloadShell,\n      signedPayloadValuesLength\n    } = getSignedCipherObjectWrapper(payloadShell);\n    return signedPayloadShell.length + signedPayloadValuesLength + payloadValuesLength + encodedCipherTextLength;\n  }\n}\nexport async function encryptECIES(publicKey, content, wasString, cipherTextEncoding) {\n  const validity = isValidPublicKey(publicKey);\n  if (!validity.result) {\n    throw validity;\n  }\n  const ephemeralPrivateKey = utils.randomPrivateKey();\n  const ephemeralPublicKey = getPublicKey(ephemeralPrivateKey, true);\n  let sharedSecret = getSharedSecret(ephemeralPrivateKey, publicKey, true);\n  sharedSecret = sharedSecret.slice(1);\n  const sharedKeys = sharedSecretToKeys(sharedSecret);\n  const initializationVector = utils.randomBytes(16);\n  const cipherText = await aes256CbcEncrypt(initializationVector, sharedKeys.encryptionKey, content);\n  const macData = concatBytes(initializationVector, ephemeralPublicKey, cipherText);\n  const mac = hmacSha256(sharedKeys.hmacKey, macData);\n  let cipherTextString;\n  if (!cipherTextEncoding || cipherTextEncoding === 'hex') {\n    cipherTextString = bytesToHex(cipherText);\n  } else if (cipherTextEncoding === 'base64') {\n    cipherTextString = fromByteArray(cipherText);\n  } else {\n    throw new Error(`Unexpected cipherTextEncoding \"${cipherTextEncoding}\"`);\n  }\n  const result = {\n    iv: bytesToHex(initializationVector),\n    ephemeralPK: bytesToHex(ephemeralPublicKey),\n    cipherText: cipherTextString,\n    mac: bytesToHex(mac),\n    wasString\n  };\n  if (cipherTextEncoding && cipherTextEncoding !== 'hex') {\n    result.cipherTextEncoding = cipherTextEncoding;\n  }\n  return result;\n}\nexport async function decryptECIES(privateKey, cipherObject) {\n  if (!cipherObject.ephemeralPK) {\n    throw new FailedDecryptionError('Unable to get public key from cipher object. ' + 'You might be trying to decrypt an unencrypted object.');\n  }\n  const ephemeralPK = cipherObject.ephemeralPK;\n  let sharedSecret = getSharedSecret(privateKey, ephemeralPK, true);\n  sharedSecret = sharedSecret.slice(1);\n  const sharedKeys = sharedSecretToKeys(sharedSecret);\n  const ivBytes = hexToBytes(cipherObject.iv);\n  let cipherTextBytes;\n  if (!cipherObject.cipherTextEncoding || cipherObject.cipherTextEncoding === 'hex') {\n    cipherTextBytes = hexToBytes(cipherObject.cipherText);\n  } else if (cipherObject.cipherTextEncoding === 'base64') {\n    cipherTextBytes = toByteArray(cipherObject.cipherText);\n  } else {\n    throw new Error(`Unexpected cipherTextEncoding \"${cipherObject.cipherText}\"`);\n  }\n  const macData = concatBytes(ivBytes, hexToBytes(ephemeralPK), cipherTextBytes);\n  const actualMac = hmacSha256(sharedKeys.hmacKey, macData);\n  const expectedMac = hexToBytes(cipherObject.mac);\n  if (!equalsConstTime(expectedMac, actualMac)) {\n    throw new FailedDecryptionError('Decryption failed: failure in MAC check');\n  }\n  const plainText = await aes256CbcDecrypt(ivBytes, sharedKeys.encryptionKey, cipherTextBytes);\n  if (cipherObject.wasString) {\n    return bytesToUtf8(plainText);\n  }\n  return plainText;\n}\nexport function signECDSA(privateKey, content) {\n  const contentBytes = typeof content === 'string' ? utf8ToBytes(content) : content;\n  const publicKey = getPublicKeyFromPrivate(privateKey);\n  const contentHash = hashSha256Sync(contentBytes);\n  const signature = signSync(contentHash, privateKey);\n  return {\n    signature: bytesToHex(signature),\n    publicKey\n  };\n}\nexport function verifyECDSA(content, publicKey, signature) {\n  const contentBytes = typeof content === 'string' ? utf8ToBytes(content) : content;\n  const contentHash = hashSha256Sync(contentBytes);\n  return verify(signature, contentHash, publicKey, {\n    strict: false\n  });\n}\nexport function verifyMessageSignature(_ref) {\n  let {\n    signature,\n    message,\n    publicKey\n  } = _ref;\n  const {\n    r,\n    s\n  } = parseRecoverableSignatureVrs(signature);\n  const sig = new Signature(hexToBigInt(r), hexToBigInt(s));\n  const hashedMsg = typeof message === 'string' ? hashMessage(message) : message;\n  const verificationResult = verify(sig, hashedMsg, publicKey, {\n    strict: false\n  });\n  if (verificationResult || typeof message !== 'string') return verificationResult;\n  const LEGACY_PREFIX = '\\x18Stacks Message Signing:\\n';\n  const legacyHash = sha256(encodeMessage(message, LEGACY_PREFIX));\n  return verify(sig, legacyHash, publicKey, {\n    strict: false\n  });\n}\nexport function verifyMessageSignatureRsv(_ref2) {\n  let {\n    signature,\n    message,\n    publicKey\n  } = _ref2;\n  return verifyMessageSignature({\n    signature: signatureRsvToVrs(signature),\n    message,\n    publicKey\n  });\n}","map":{"version":3,"names":["hmac","sha256","getPublicKey","getSharedSecret","Point","Signature","signSync","utils","verify","bigIntToBytes","bytesToHex","bytesToUtf8","concatBytes","FailedDecryptionError","hexToBigInt","hexToBytes","parseRecoverableSignatureVrs","signatureRsvToVrs","utf8ToBytes","fromByteArray","toByteArray","createCipher","getPublicKeyFromPrivate","encodeMessage","hashMessage","hashSha256Sync","hashSha512Sync","getAesCbcOutputLength","getBase64OutputLength","hmacSha256Sync","key","h","create","_len","arguments","length","msgs","Array","_key","forEach","msg","update","digest","InvalidPublicKeyReason","aes256CbcEncrypt","iv","plaintext","cipher","encrypt","aes256CbcDecrypt","ciphertext","decrypt","hmacSha256","content","equalsConstTime","a","b","res","i","sharedSecretToKeys","sharedSecret","hashedSecret","encryptionKey","slice","hmacKey","allHexChars","maybe","match","isValidPublicKey","pub","invalidFormat","result","reason_data","reason","InvalidFormat","invalidPoint","IsNotPoint","firstByte","point","fromHex","assertValidity","e","getHexFromBN","bnInput","hexOut","toString","padding","repeat","Error","getBytesFromBN","byteLength","getCipherObjectWrapper","opts","shell","ephemeralPK","mac","cipherText","wasString","cipherTextEncoding","ivLength","ephemeralPKLength","macLength","payloadValuesLength","payloadShell","JSON","stringify","getSignedCipherObjectWrapper","signature","publicKey","signatureLength","publicKeyLength","signedPayloadValuesLength","signedPayloadShell","eciesGetJsonStringLength","cipherTextLength","contentLength","encodedCipherTextLength","sign","encryptECIES","validity","ephemeralPrivateKey","randomPrivateKey","ephemeralPublicKey","sharedKeys","initializationVector","randomBytes","macData","cipherTextString","decryptECIES","privateKey","cipherObject","ivBytes","cipherTextBytes","actualMac","expectedMac","plainText","signECDSA","contentBytes","contentHash","verifyECDSA","strict","verifyMessageSignature","_ref","message","r","s","sig","hashedMsg","verificationResult","LEGACY_PREFIX","legacyHash","verifyMessageSignatureRsv","_ref2"],"sources":["C:\\Users\\abasi\\Desktop\\web3-apps\\react-cra\\node_modules\\@stacks\\encryption\\src\\ec.ts"],"sourcesContent":["import { hmac } from '@noble/hashes/hmac';\nimport { sha256 } from '@noble/hashes/sha256';\nimport {\n  getPublicKey,\n  getSharedSecret,\n  Point,\n  Signature,\n  signSync,\n  utils,\n  verify,\n} from '@noble/secp256k1';\nimport {\n  bigIntToBytes,\n  bytesToHex,\n  bytesToUtf8,\n  concatBytes,\n  FailedDecryptionError,\n  hexToBigInt,\n  hexToBytes,\n  parseRecoverableSignatureVrs,\n  signatureRsvToVrs,\n  utf8ToBytes,\n} from '@stacks/common';\nimport { fromByteArray, toByteArray } from 'base64-js';\nimport { createCipher } from './aesCipher';\nimport { getPublicKeyFromPrivate } from './keys';\nimport { encodeMessage, hashMessage } from './messageSignature';\nimport { hashSha256Sync, hashSha512Sync } from './sha2Hash';\nimport { getAesCbcOutputLength, getBase64OutputLength } from './utils';\n\n/**\n * To use secp256k1.signSync set utils.hmacSha256Sync to a function using noble-hashes\n * secp256k1.signSync is the counter part of secp256k1.sign (async version)\n * secp256k1.signSync is used within signECDSA in this file\n * secp256k1.signSync is used to maintain the semantics of signECDSA while migrating from elliptic lib\n * utils.hmacSha256Sync docs: https://github.com/paulmillr/noble-secp256k1 readme file\n */\nutils.hmacSha256Sync = (key: Uint8Array, ...msgs: Uint8Array[]) => {\n  const h = hmac.create(sha256, key);\n  msgs.forEach(msg => h.update(msg));\n  return h.digest();\n};\n\n/**\n * Controls how the encrypted data bytes will be encoded as a string in the JSON payload.\n * Options:\n *    `hex` -- the legacy default, file size increase 100% (2x).\n *    `base64` -- file size increased ~33%.\n * @ignore\n */\nexport type CipherTextEncoding = 'hex' | 'base64';\n\n/**\n * @ignore\n */\nexport type CipherObject = {\n  iv: string;\n  ephemeralPK: string;\n  cipherText: string;\n  /** If undefined then hex encoding is used for the `cipherText` string. */\n  cipherTextEncoding?: CipherTextEncoding;\n  mac: string;\n  wasString: boolean;\n};\n\n/**\n * @ignore\n */\nexport type SignedCipherObject = {\n  /** Hex encoded DER signature (up to 144 chars) */\n  signature: string;\n  /** Hex encoded public key (66 char length) */\n  publicKey: string;\n  /** The stringified json of a `CipherObject` */\n  cipherText: string;\n};\n\n/**\n * @ignore\n */\nexport enum InvalidPublicKeyReason {\n  InvalidFormat = 'InvalidFormat',\n  IsNotPoint = 'IsNotPoint',\n}\n\n/**\n * @ignore\n */\nexport async function aes256CbcEncrypt(\n  iv: Uint8Array,\n  key: Uint8Array,\n  plaintext: Uint8Array\n): Promise<Uint8Array> {\n  const cipher = await createCipher();\n  return await cipher.encrypt('aes-256-cbc', key, iv, plaintext);\n}\n\n/**\n * @ignore\n */\nasync function aes256CbcDecrypt(\n  iv: Uint8Array,\n  key: Uint8Array,\n  ciphertext: Uint8Array\n): Promise<Uint8Array> {\n  const cipher = await createCipher();\n  return await cipher.decrypt('aes-256-cbc', key, iv, ciphertext);\n}\n\n/**\n * @ignore\n */\nexport function hmacSha256(key: Uint8Array, content: Uint8Array): Uint8Array {\n  return hmac(sha256, key, content);\n}\n\n/**\n * @ignore\n */\nfunction equalsConstTime(a: Uint8Array, b: Uint8Array) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  let res = 0;\n  for (let i = 0; i < a.length; i++) {\n    res |= a[i] ^ b[i];\n  }\n  return res === 0;\n}\n\n/**\n * @ignore\n */\nfunction sharedSecretToKeys(sharedSecret: Uint8Array): {\n  encryptionKey: Uint8Array;\n  hmacKey: Uint8Array;\n} {\n  // generate mac and encryption key from shared secret\n  const hashedSecret = hashSha512Sync(sharedSecret);\n  return {\n    encryptionKey: hashedSecret.slice(0, 32),\n    hmacKey: hashedSecret.slice(32),\n  };\n}\n\n/**\n * @ignore\n */\nfunction allHexChars(maybe: string): boolean {\n  return maybe.match(/^[0-9a-f]+$/i) !== null;\n}\n\n/**\n * @ignore\n */\nfunction isValidPublicKey(pub: string): {\n  result: boolean;\n  reason: string | null;\n  reason_data: string | null;\n} {\n  const invalidFormat = {\n    result: false,\n    reason_data: 'Invalid public key format',\n    reason: InvalidPublicKeyReason.InvalidFormat,\n  };\n  const invalidPoint = {\n    result: false,\n    reason_data: 'Public key is not a point',\n    reason: InvalidPublicKeyReason.IsNotPoint,\n  };\n  if (pub.length !== 66 && pub.length !== 130) return invalidFormat;\n\n  const firstByte = pub.slice(0, 2);\n\n  // uncompressed public key\n  if (pub.length === 130 && firstByte !== '04') return invalidFormat;\n\n  // compressed public key\n  if (pub.length === 66 && firstByte !== '02' && firstByte !== '03') return invalidFormat;\n\n  if (!allHexChars(pub)) return invalidFormat;\n\n  try {\n    // Converts public key to Point\n    const point = Point.fromHex(pub);\n\n    // Verify point on curve is valid if it conforms to equation\n    // Validate the public key\n    // Throws: Point is not on elliptic curve if point is not on curve\n    point.assertValidity();\n\n    // Validation passed\n    return {\n      result: true,\n      reason_data: null,\n      reason: null,\n    };\n  } catch (e) {\n    return invalidPoint;\n  }\n}\n\n/**\n * Hex encodes a 32-byte bigint instance.\n * The result string is zero padded and always 64 characters in length.\n * @ignore\n */\nexport function getHexFromBN(bnInput: bigint): string {\n  const hexOut = bnInput.toString(16);\n  if (hexOut.length === 64) {\n    return hexOut;\n  } else if (hexOut.length < 64) {\n    // pad with leading zeros\n    // the padStart function would require node 9\n    const padding = '0'.repeat(64 - hexOut.length);\n    return `${padding}${hexOut}`;\n  } else {\n    throw new Error('Generated a > 32-byte BN for encryption. Failing.');\n  }\n}\n\n/**\n * Converts to zero padded 32 bytes\n * @ignore\n */\nexport function getBytesFromBN(bnInput: bigint): Uint8Array {\n  // todo: remove method?\n  const result = bigIntToBytes(bnInput, 32);\n  if (result.byteLength !== 32) {\n    throw new Error('Failed to generate a 32-byte Uint8Array');\n  }\n  return result;\n}\n\n/**\n * Get details about the JSON envelope size overhead for ciphertext payloads.\n * @ignore\n */\nexport function getCipherObjectWrapper(opts: {\n  wasString: boolean;\n  cipherTextEncoding: CipherTextEncoding;\n}): {\n  /** The stringified JSON string of an empty `CipherObject`. */\n  payloadShell: string;\n  /** Total string length of all the `CipherObject` values that always have constant lengths. */\n  payloadValuesLength: number;\n} {\n  // Placeholder structure of the ciphertext payload, used to determine the\n  // stringified JSON overhead length.\n  const shell: CipherObject = {\n    iv: '',\n    ephemeralPK: '',\n    mac: '',\n    cipherText: '',\n    wasString: !!opts.wasString,\n  };\n  if (opts.cipherTextEncoding === 'base64') {\n    shell.cipherTextEncoding = 'base64';\n  }\n  // Hex encoded 16 bytes.\n  const ivLength = 32;\n  // Hex encoded, compressed EC pubkey of 33 bytes.\n  const ephemeralPKLength = 66;\n  // Hex encoded 32 byte hmac-sha256.\n  const macLength = 64;\n  return {\n    payloadValuesLength: ivLength + ephemeralPKLength + macLength,\n    payloadShell: JSON.stringify(shell),\n  };\n}\n\n/**\n * Get details about the JSON envelope size overhead for signed ciphertext payloads.\n * @param payloadShell - The JSON stringified empty `CipherObject`\n * @ignore\n */\nexport function getSignedCipherObjectWrapper(payloadShell: string): {\n  /** The stringified JSON string of an empty `SignedCipherObject`. */\n  signedPayloadValuesLength: number;\n  /** Total string length of all the `SignedCipherObject` values\n   * that always have constant lengths */\n  signedPayloadShell: string;\n} {\n  // Placeholder structure of the signed ciphertext payload, used to determine the\n  // stringified JSON overhead length.\n  const shell: SignedCipherObject = {\n    signature: '',\n    publicKey: '',\n    cipherText: payloadShell,\n  };\n  // Hex encoded DER signature, up to 72 byte length.\n  const signatureLength = 144;\n  // Hex encoded 33 byte public key.\n  const publicKeyLength = 66;\n  return {\n    signedPayloadValuesLength: signatureLength + publicKeyLength,\n    signedPayloadShell: JSON.stringify(shell),\n  };\n}\n\n/**\n * Fast function that determines the final ASCII string byte length of the\n * JSON stringified ECIES encrypted payload.\n * @ignore\n */\nexport function eciesGetJsonStringLength(opts: {\n  contentLength: number;\n  wasString: boolean;\n  sign: boolean;\n  cipherTextEncoding: CipherTextEncoding;\n}): number {\n  const { payloadShell, payloadValuesLength } = getCipherObjectWrapper(opts);\n\n  // Calculate the AES output length given the input length.\n  const cipherTextLength = getAesCbcOutputLength(opts.contentLength);\n\n  // Get the encoded string length of the cipherText.\n  let encodedCipherTextLength: number;\n  if (!opts.cipherTextEncoding || opts.cipherTextEncoding === 'hex') {\n    encodedCipherTextLength = cipherTextLength * 2;\n  } else if (opts.cipherTextEncoding === 'base64') {\n    encodedCipherTextLength = getBase64OutputLength(cipherTextLength);\n  } else {\n    throw new Error(`Unexpected cipherTextEncoding \"${opts.cipherTextEncoding}\"`);\n  }\n\n  if (!opts.sign) {\n    // Add the length of the JSON envelope, ciphertext length, and length of const values.\n    return payloadShell.length + payloadValuesLength + encodedCipherTextLength;\n  } else {\n    // Get the signed version of the JSON envelope\n    const { signedPayloadShell, signedPayloadValuesLength } =\n      getSignedCipherObjectWrapper(payloadShell);\n    // Add length of the JSON envelope, ciphertext length, and length of the const values.\n    return (\n      signedPayloadShell.length +\n      signedPayloadValuesLength +\n      payloadValuesLength +\n      encodedCipherTextLength\n    );\n  }\n}\n\n// todo: simplify and remove wasstring\n/**\n * Encrypt content to elliptic curve publicKey using ECIES\n * @param publicKey - secp256k1 public key hex string\n * @param content - content to encrypt\n * @return Object containing:\n *  iv (initialization vector, hex encoding),\n *  cipherText (cipher text either hex or base64 encoded),\n *  mac (message authentication code, hex encoded),\n *  ephemeral public key (hex encoded),\n *  wasString (boolean indicating with or not to return a Uint8Array or string on decrypt)\n * @ignore\n */\nexport async function encryptECIES(\n  publicKey: string,\n  content: Uint8Array,\n  wasString: boolean,\n  cipherTextEncoding?: CipherTextEncoding\n): Promise<CipherObject> {\n  const validity = isValidPublicKey(publicKey);\n  if (!validity.result) {\n    throw validity;\n  }\n  const ephemeralPrivateKey = utils.randomPrivateKey();\n  const ephemeralPublicKey = getPublicKey(ephemeralPrivateKey, true);\n  let sharedSecret = getSharedSecret(ephemeralPrivateKey, publicKey, true);\n  // Trim the compressed mode prefix byte\n  sharedSecret = sharedSecret.slice(1);\n  const sharedKeys = sharedSecretToKeys(sharedSecret);\n  const initializationVector = utils.randomBytes(16);\n\n  const cipherText = await aes256CbcEncrypt(\n    initializationVector,\n    sharedKeys.encryptionKey,\n    content\n  );\n\n  const macData = concatBytes(initializationVector, ephemeralPublicKey, cipherText);\n  const mac = hmacSha256(sharedKeys.hmacKey, macData);\n\n  let cipherTextString: string;\n\n  if (!cipherTextEncoding || cipherTextEncoding === 'hex') {\n    cipherTextString = bytesToHex(cipherText);\n  } else if (cipherTextEncoding === 'base64') {\n    cipherTextString = fromByteArray(cipherText);\n  } else {\n    throw new Error(`Unexpected cipherTextEncoding \"${cipherTextEncoding}\"`);\n  }\n\n  const result: CipherObject = {\n    iv: bytesToHex(initializationVector),\n    ephemeralPK: bytesToHex(ephemeralPublicKey),\n    cipherText: cipherTextString,\n    mac: bytesToHex(mac),\n    wasString,\n  };\n  if (cipherTextEncoding && cipherTextEncoding !== 'hex') {\n    result.cipherTextEncoding = cipherTextEncoding;\n  }\n  return result;\n}\n\n/**\n * Decrypt content encrypted using ECIES\n * @param {String} privateKey - secp256k1 private key hex string\n * @param {Object} cipherObject - object to decrypt, should contain:\n *  iv (initialization vector), cipherText (cipher text),\n *  mac (message authentication code), ephemeralPublicKey\n *  wasString (boolean indicating with or not to return bytes or string on decrypt)\n * @return {Uint8Array} plaintext\n * @throws {FailedDecryptionError} if unable to decrypt\n * @ignore\n */\nexport async function decryptECIES(\n  privateKey: string,\n  cipherObject: CipherObject\n): Promise<Uint8Array | string> {\n  if (!cipherObject.ephemeralPK) {\n    throw new FailedDecryptionError(\n      'Unable to get public key from cipher object. ' +\n        'You might be trying to decrypt an unencrypted object.'\n    );\n  }\n  const ephemeralPK = cipherObject.ephemeralPK;\n  let sharedSecret = getSharedSecret(privateKey, ephemeralPK, true);\n  // Trim the compressed mode prefix byte\n  sharedSecret = sharedSecret.slice(1);\n  const sharedKeys = sharedSecretToKeys(sharedSecret);\n  const ivBytes = hexToBytes(cipherObject.iv);\n\n  let cipherTextBytes: Uint8Array;\n\n  if (!cipherObject.cipherTextEncoding || cipherObject.cipherTextEncoding === 'hex') {\n    cipherTextBytes = hexToBytes(cipherObject.cipherText);\n  } else if (cipherObject.cipherTextEncoding === 'base64') {\n    cipherTextBytes = toByteArray(cipherObject.cipherText);\n  } else {\n    throw new Error(`Unexpected cipherTextEncoding \"${cipherObject.cipherText}\"`);\n  }\n\n  const macData = concatBytes(ivBytes, hexToBytes(ephemeralPK), cipherTextBytes);\n  const actualMac = hmacSha256(sharedKeys.hmacKey, macData);\n  const expectedMac = hexToBytes(cipherObject.mac);\n\n  if (!equalsConstTime(expectedMac, actualMac)) {\n    throw new FailedDecryptionError('Decryption failed: failure in MAC check');\n  }\n  const plainText = await aes256CbcDecrypt(ivBytes, sharedKeys.encryptionKey, cipherTextBytes);\n\n  if (cipherObject.wasString) {\n    return bytesToUtf8(plainText);\n  }\n  return plainText;\n}\n\n/**\n * Sign content using ECDSA\n *\n * @param {string} privateKey - secp256k1 private key hex string\n * @param {string | Uint8Array} content - content to sign\n * @return {Object} contains:\n * signature - Hex encoded DER signature\n * public key - Hex encoded private string taken from privateKey\n * @ignore\n */\nexport function signECDSA(\n  privateKey: string,\n  content: string | Uint8Array\n): {\n  publicKey: string;\n  signature: string;\n} {\n  const contentBytes = typeof content === 'string' ? utf8ToBytes(content) : content;\n  const publicKey = getPublicKeyFromPrivate(privateKey);\n  const contentHash = hashSha256Sync(contentBytes);\n  const signature = signSync(contentHash, privateKey);\n\n  return {\n    signature: bytesToHex(signature),\n    publicKey,\n  };\n}\n\n/**\n * Verify content using ECDSA\n * @param {String | Uint8Array} content - Content to verify was signed\n * @param {String} publicKey - secp256k1 private key hex string\n * @param {String} signature - Hex encoded DER signature\n * @return {Boolean} returns true when signature matches publickey + content, false if not\n * @ignore\n */\nexport function verifyECDSA(\n  content: string | Uint8Array,\n  publicKey: string,\n  signature: string\n): boolean {\n  const contentBytes = typeof content === 'string' ? utf8ToBytes(content) : content;\n  const contentHash = hashSha256Sync(contentBytes);\n  // verify() is strict: true by default. High-s signatures are rejected, which mirrors libsecp behavior\n  // Set verify options to strict: false, to support the legacy stacks implementations\n  // Reference: https://github.com/paulmillr/noble-secp256k1/releases/tag/1.4.0\n  return verify(signature, contentHash, publicKey, { strict: false });\n}\n\ninterface VerifyMessageSignatureArgs {\n  signature: string;\n  message: string | Uint8Array;\n  publicKey: string;\n}\n\n/**\n * Verify message signature (VRS format) with recoverable public key\n * @deprecated The Clarity compatible {@link verifyMessageSignatureRsv} is preferred\n */\nexport function verifyMessageSignature({\n  signature,\n  message,\n  publicKey,\n}: VerifyMessageSignatureArgs): boolean {\n  // todo: remove method and pull body to `verifyMessageSignatureRsv`\n  const { r, s } = parseRecoverableSignatureVrs(signature);\n  const sig = new Signature(hexToBigInt(r), hexToBigInt(s));\n  const hashedMsg = typeof message === 'string' ? hashMessage(message) : message;\n  // verify() is strict: true by default. High-s signatures are rejected, which mirrors libsecp behavior\n  // Set verify options to strict: false, to support the legacy stacks implementations\n  // Reference: https://github.com/paulmillr/noble-secp256k1/releases/tag/1.4.0\n  const verificationResult = verify(sig, hashedMsg, publicKey, { strict: false });\n\n  // Additional Check for Legacy Prefix ++++++++++++++++++++++++++++++++++++++++\n  if (verificationResult || typeof message !== 'string') return verificationResult;\n\n  const LEGACY_PREFIX = '\\x18Stacks Message Signing:\\n';\n  const legacyHash = sha256(encodeMessage(message, LEGACY_PREFIX));\n  return verify(sig, legacyHash, publicKey, { strict: false });\n  // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n}\n\n/**\n * Verifies a Clarity compatible signed message using a public key. The\n * `signature` option needs to be in RSV format.\n */\nexport function verifyMessageSignatureRsv({\n  signature,\n  message,\n  publicKey,\n}: VerifyMessageSignatureArgs): boolean {\n  return verifyMessageSignature({\n    signature: signatureRsvToVrs(signature),\n    message,\n    publicKey,\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}