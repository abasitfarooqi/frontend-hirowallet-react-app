{"ast":null,"code":"import { hmac } from '@noble/hashes/hmac';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { getPublicKey as nobleGetPublicKey, Point, Signature, signSync, utils } from '@noble/secp256k1';\nimport { bytesToHex, concatArray, hexToBigInt, hexToBytes, intToHex, parseRecoverableSignatureVrs, privateKeyToBytes, PRIVATE_KEY_COMPRESSED_LENGTH, signatureRsvToVrs, signatureVrsToRsv } from '@stacks/common';\nimport { c32address } from 'c32check';\nimport { addressFromVersionHash, addressHashModeToVersion, addressToString, createMessageSignature } from './common';\nimport { AddressHashMode, COMPRESSED_PUBKEY_LENGTH_BYTES, PubKeyEncoding, StacksMessageType, TransactionVersion, UNCOMPRESSED_PUBKEY_LENGTH_BYTES } from './constants';\nimport { hash160, hashP2PKH } from './utils';\nutils.hmacSha256Sync = function (key) {\n  const h = hmac.create(sha256, key);\n  for (var _len = arguments.length, msgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    msgs[_key - 1] = arguments[_key];\n  }\n  msgs.forEach(msg => h.update(msg));\n  return h.digest();\n};\nexport function getAddressFromPrivateKey(privateKey) {\n  let transactionVersion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TransactionVersion.Mainnet;\n  const pubKey = pubKeyfromPrivKey(privateKey);\n  return getAddressFromPublicKey(pubKey.data, transactionVersion);\n}\nexport function getAddressFromPublicKey(publicKey) {\n  let transactionVersion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TransactionVersion.Mainnet;\n  publicKey = typeof publicKey === 'string' ? publicKey : bytesToHex(publicKey);\n  const addrVer = addressHashModeToVersion(AddressHashMode.SerializeP2PKH, transactionVersion);\n  const addr = addressFromVersionHash(addrVer, hashP2PKH(hexToBytes(publicKey)));\n  const addrString = addressToString(addr);\n  return addrString;\n}\nexport function createStacksPublicKey(key) {\n  return {\n    type: StacksMessageType.PublicKey,\n    data: hexToBytes(key)\n  };\n}\nexport function publicKeyFromSignatureVrs(messageHash, messageSignature) {\n  let pubKeyEncoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PubKeyEncoding.Compressed;\n  const parsedSignature = parseRecoverableSignatureVrs(messageSignature.data);\n  const signature = new Signature(hexToBigInt(parsedSignature.r), hexToBigInt(parsedSignature.s));\n  const point = Point.fromSignature(messageHash, signature, parsedSignature.recoveryId);\n  const compressed = pubKeyEncoding === PubKeyEncoding.Compressed;\n  return point.toHex(compressed);\n}\nexport function publicKeyFromSignatureRsv(messageHash, messageSignature) {\n  let pubKeyEncoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PubKeyEncoding.Compressed;\n  return publicKeyFromSignatureVrs(messageHash, {\n    ...messageSignature,\n    data: signatureRsvToVrs(messageSignature.data)\n  }, pubKeyEncoding);\n}\nexport function publicKeyFromBytes(data) {\n  return {\n    type: StacksMessageType.PublicKey,\n    data\n  };\n}\nexport function isCompressed(key) {\n  return !bytesToHex(key.data).startsWith('04');\n}\nexport function publicKeyToString(key) {\n  return bytesToHex(key.data);\n}\nexport function serializePublicKey(key) {\n  return key.data.slice();\n}\nexport function pubKeyfromPrivKey(privateKey) {\n  const privKey = createStacksPrivateKey(privateKey);\n  const publicKey = nobleGetPublicKey(privKey.data.slice(0, 32), privKey.compressed);\n  return createStacksPublicKey(bytesToHex(publicKey));\n}\nexport function compressPublicKey(publicKey) {\n  const hex = typeof publicKey === 'string' ? publicKey : bytesToHex(publicKey);\n  const compressed = Point.fromHex(hex).toHex(true);\n  return createStacksPublicKey(compressed);\n}\nexport function deserializePublicKey(bytesReader) {\n  const fieldId = bytesReader.readUInt8();\n  const keyLength = fieldId !== 4 ? COMPRESSED_PUBKEY_LENGTH_BYTES : UNCOMPRESSED_PUBKEY_LENGTH_BYTES;\n  return publicKeyFromBytes(concatArray([fieldId, bytesReader.readBytes(keyLength)]));\n}\nexport function createStacksPrivateKey(key) {\n  const data = privateKeyToBytes(key);\n  const compressed = data.length == PRIVATE_KEY_COMPRESSED_LENGTH;\n  return {\n    data,\n    compressed\n  };\n}\nexport function makeRandomPrivKey() {\n  return createStacksPrivateKey(utils.randomPrivateKey());\n}\nexport function signWithKey(privateKey, messageHash) {\n  const [rawSignature, recoveryId] = signSync(messageHash, privateKey.data.slice(0, 32), {\n    canonical: true,\n    recovered: true\n  });\n  if (recoveryId == null) {\n    throw new Error('No signature recoveryId received');\n  }\n  const recoveryIdHex = intToHex(recoveryId, 1);\n  const recoverableSignatureString = recoveryIdHex + Signature.fromHex(rawSignature).toCompactHex();\n  return createMessageSignature(recoverableSignatureString);\n}\nexport function signMessageHashRsv(_ref) {\n  let {\n    messageHash,\n    privateKey\n  } = _ref;\n  const messageSignature = signWithKey(privateKey, messageHash);\n  return {\n    ...messageSignature,\n    data: signatureVrsToRsv(messageSignature.data)\n  };\n}\nexport function getPublicKey(privateKey) {\n  return pubKeyfromPrivKey(privateKey.data);\n}\nexport function privateKeyToString(privateKey) {\n  return bytesToHex(privateKey.data);\n}\nexport function publicKeyToAddress(version, publicKey) {\n  return c32address(version, bytesToHex(hash160(publicKey.data)));\n}","map":{"version":3,"names":["hmac","sha256","getPublicKey","nobleGetPublicKey","Point","Signature","signSync","utils","bytesToHex","concatArray","hexToBigInt","hexToBytes","intToHex","parseRecoverableSignatureVrs","privateKeyToBytes","PRIVATE_KEY_COMPRESSED_LENGTH","signatureRsvToVrs","signatureVrsToRsv","c32address","addressFromVersionHash","addressHashModeToVersion","addressToString","createMessageSignature","AddressHashMode","COMPRESSED_PUBKEY_LENGTH_BYTES","PubKeyEncoding","StacksMessageType","TransactionVersion","UNCOMPRESSED_PUBKEY_LENGTH_BYTES","hash160","hashP2PKH","hmacSha256Sync","key","h","create","_len","arguments","length","msgs","Array","_key","forEach","msg","update","digest","getAddressFromPrivateKey","privateKey","transactionVersion","undefined","Mainnet","pubKey","pubKeyfromPrivKey","getAddressFromPublicKey","data","publicKey","addrVer","SerializeP2PKH","addr","addrString","createStacksPublicKey","type","PublicKey","publicKeyFromSignatureVrs","messageHash","messageSignature","pubKeyEncoding","Compressed","parsedSignature","signature","r","s","point","fromSignature","recoveryId","compressed","toHex","publicKeyFromSignatureRsv","publicKeyFromBytes","isCompressed","startsWith","publicKeyToString","serializePublicKey","slice","privKey","createStacksPrivateKey","compressPublicKey","hex","fromHex","deserializePublicKey","bytesReader","fieldId","readUInt8","keyLength","readBytes","makeRandomPrivKey","randomPrivateKey","signWithKey","rawSignature","canonical","recovered","Error","recoveryIdHex","recoverableSignatureString","toCompactHex","signMessageHashRsv","_ref","privateKeyToString","publicKeyToAddress","version"],"sources":["C:\\Users\\abasi\\Desktop\\web3-apps\\react-cra\\node_modules\\@stacks\\transactions\\src\\keys.ts"],"sourcesContent":["import { hmac } from '@noble/hashes/hmac';\nimport { sha256 } from '@noble/hashes/sha256';\nimport {\n  getPublicKey as nobleGetPublicKey,\n  Point,\n  Signature,\n  signSync,\n  utils,\n} from '@noble/secp256k1';\nimport {\n  bytesToHex,\n  concatArray,\n  hexToBigInt,\n  hexToBytes,\n  intToHex,\n  parseRecoverableSignatureVrs,\n  privateKeyToBytes,\n  PRIVATE_KEY_COMPRESSED_LENGTH,\n  signatureRsvToVrs,\n  signatureVrsToRsv,\n} from '@stacks/common';\nimport { c32address } from 'c32check';\nimport { BytesReader } from './bytesReader';\nimport {\n  addressFromVersionHash,\n  addressHashModeToVersion,\n  addressToString,\n  createMessageSignature,\n  MessageSignature,\n} from './common';\nimport {\n  AddressHashMode,\n  AddressVersion,\n  COMPRESSED_PUBKEY_LENGTH_BYTES,\n  PubKeyEncoding,\n  StacksMessageType,\n  TransactionVersion,\n  UNCOMPRESSED_PUBKEY_LENGTH_BYTES,\n} from './constants';\nimport { hash160, hashP2PKH } from './utils';\n\n/**\n * To use secp256k1.signSync set utils.hmacSha256Sync to a function using noble-hashes\n * secp256k1.signSync is the counter part of secp256k1.sign (async version)\n * secp256k1.signSync is used within signWithKey in this file\n * secp256k1.signSync is used to maintain the semantics of signWithKey while migrating from elliptic lib\n * utils.hmacSha256Sync docs: https://github.com/paulmillr/noble-secp256k1 readme file\n */\nutils.hmacSha256Sync = (key: Uint8Array, ...msgs: Uint8Array[]) => {\n  const h = hmac.create(sha256, key);\n  msgs.forEach(msg => h.update(msg));\n  return h.digest();\n};\n\nexport interface StacksPublicKey {\n  readonly type: StacksMessageType.PublicKey;\n  readonly data: Uint8Array;\n}\n\n/** Creates a P2PKH address string from the given private key and tx version. */\nexport function getAddressFromPrivateKey(\n  /** Private key bytes or hex string */\n  privateKey: string | Uint8Array,\n  transactionVersion = TransactionVersion.Mainnet\n): string {\n  const pubKey = pubKeyfromPrivKey(privateKey);\n  return getAddressFromPublicKey(pubKey.data, transactionVersion);\n}\n\n/** Creates a P2PKH address string from the given public key and tx version. */\nexport function getAddressFromPublicKey(\n  /** Public key bytes or hex string */\n  publicKey: string | Uint8Array,\n  transactionVersion = TransactionVersion.Mainnet\n): string {\n  publicKey = typeof publicKey === 'string' ? publicKey : bytesToHex(publicKey);\n  const addrVer = addressHashModeToVersion(AddressHashMode.SerializeP2PKH, transactionVersion);\n  const addr = addressFromVersionHash(addrVer, hashP2PKH(hexToBytes(publicKey)));\n  const addrString = addressToString(addr);\n  return addrString;\n}\n\nexport function createStacksPublicKey(key: string): StacksPublicKey {\n  return {\n    type: StacksMessageType.PublicKey,\n    data: hexToBytes(key),\n  };\n}\n\nexport function publicKeyFromSignatureVrs(\n  messageHash: string,\n  messageSignature: MessageSignature,\n  pubKeyEncoding = PubKeyEncoding.Compressed\n): string {\n  const parsedSignature = parseRecoverableSignatureVrs(messageSignature.data);\n  const signature = new Signature(hexToBigInt(parsedSignature.r), hexToBigInt(parsedSignature.s));\n  const point = Point.fromSignature(messageHash, signature, parsedSignature.recoveryId);\n  const compressed = pubKeyEncoding === PubKeyEncoding.Compressed;\n  return point.toHex(compressed);\n}\n\nexport function publicKeyFromSignatureRsv(\n  messageHash: string,\n  messageSignature: MessageSignature,\n  pubKeyEncoding = PubKeyEncoding.Compressed\n): string {\n  return publicKeyFromSignatureVrs(\n    messageHash,\n    { ...messageSignature, data: signatureRsvToVrs(messageSignature.data) },\n    pubKeyEncoding\n  );\n}\n\nexport function publicKeyFromBytes(data: Uint8Array): StacksPublicKey {\n  return { type: StacksMessageType.PublicKey, data };\n}\n\nexport function isCompressed(key: StacksPublicKey): boolean {\n  return !bytesToHex(key.data).startsWith('04');\n}\n\nexport function publicKeyToString(key: StacksPublicKey): string {\n  return bytesToHex(key.data);\n}\n\nexport function serializePublicKey(key: StacksPublicKey): Uint8Array {\n  return key.data.slice();\n}\n\nexport function pubKeyfromPrivKey(privateKey: string | Uint8Array): StacksPublicKey {\n  const privKey = createStacksPrivateKey(privateKey);\n  const publicKey = nobleGetPublicKey(privKey.data.slice(0, 32), privKey.compressed);\n  return createStacksPublicKey(bytesToHex(publicKey));\n}\n\nexport function compressPublicKey(publicKey: string | Uint8Array): StacksPublicKey {\n  const hex = typeof publicKey === 'string' ? publicKey : bytesToHex(publicKey);\n  const compressed = Point.fromHex(hex).toHex(true);\n  return createStacksPublicKey(compressed);\n}\n\nexport function deserializePublicKey(bytesReader: BytesReader): StacksPublicKey {\n  const fieldId = bytesReader.readUInt8();\n  const keyLength =\n    fieldId !== 4 ? COMPRESSED_PUBKEY_LENGTH_BYTES : UNCOMPRESSED_PUBKEY_LENGTH_BYTES;\n  return publicKeyFromBytes(concatArray([fieldId, bytesReader.readBytes(keyLength)]));\n}\n\nexport interface StacksPrivateKey {\n  // \"compressed\" private key is a misnomer: https://web.archive.org/web/20220131144208/https://www.oreilly.com/library/view/mastering-bitcoin/9781491902639/ch04.html#comp_priv\n  // it actually means: should public keys be generated as \"compressed\" or \"uncompressed\" from this private key\n  compressed: boolean;\n  data: Uint8Array;\n}\n\nexport function createStacksPrivateKey(key: string | Uint8Array): StacksPrivateKey {\n  const data = privateKeyToBytes(key);\n  const compressed = data.length == PRIVATE_KEY_COMPRESSED_LENGTH;\n  return { data, compressed };\n}\n\nexport function makeRandomPrivKey(): StacksPrivateKey {\n  return createStacksPrivateKey(utils.randomPrivateKey());\n}\n\n/**\n * @deprecated The Clarity compatible {@link signMessageHashRsv} is preferred, but differs in signature format\n * @returns A recoverable signature (in VRS order)\n */\nexport function signWithKey(privateKey: StacksPrivateKey, messageHash: string): MessageSignature {\n  const [rawSignature, recoveryId] = signSync(messageHash, privateKey.data.slice(0, 32), {\n    canonical: true,\n    recovered: true,\n  });\n  if (recoveryId == null) {\n    throw new Error('No signature recoveryId received');\n  }\n  const recoveryIdHex = intToHex(recoveryId, 1);\n  const recoverableSignatureString = recoveryIdHex + Signature.fromHex(rawSignature).toCompactHex(); // V + RS\n  return createMessageSignature(recoverableSignatureString);\n}\n\n/**\n * Signs a message using a private key. The resulting signature along with the\n * original message can be verified using {@link verifyMessageSignatureRsv}\n * @returns A recoverable signature (in RSV order)\n */\nexport function signMessageHashRsv({\n  messageHash,\n  privateKey,\n}: {\n  messageHash: string;\n  privateKey: StacksPrivateKey;\n}): MessageSignature {\n  const messageSignature = signWithKey(privateKey, messageHash);\n  return { ...messageSignature, data: signatureVrsToRsv(messageSignature.data) };\n}\n\nexport function getPublicKey(privateKey: StacksPrivateKey): StacksPublicKey {\n  return pubKeyfromPrivKey(privateKey.data);\n}\n\nexport function privateKeyToString(privateKey: StacksPrivateKey): string {\n  return bytesToHex(privateKey.data);\n}\n\nexport function publicKeyToAddress(version: AddressVersion, publicKey: StacksPublicKey): string {\n  return c32address(version, bytesToHex(hash160(publicKey.data)));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}