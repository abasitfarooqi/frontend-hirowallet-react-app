{"ast":null,"code":"import { bytesToHex, bytesToUtf8, concatArray, hexToBytes, hexToInt, intToBytes, intToHex, utf8ToBytes } from '@stacks/common';\nimport { MEMO_MAX_LENGTH_BYTES, AddressHashMode, AddressVersion, StacksMessageType, PostConditionPrincipalID, PostConditionType, FungibleConditionCode, NonFungibleConditionCode } from './constants';\nimport { serializePublicKey, deserializePublicKey, isCompressed } from './keys';\nimport { exceedsMaxLengthBytes, hashP2PKH, rightPadHexToLength, hashP2SH, hashP2WSH, hashP2WPKH } from './utils';\nimport { createLPString } from './postcondition-types';\nimport { deserializePayload, serializePayload } from './payload';\nimport { DeserializationError } from './errors';\nimport { deserializeTransactionAuthField, deserializeMessageSignature, serializeMessageSignature, serializeTransactionAuthField } from './signature';\nimport { addressHashModeToVersion, addressFromVersionHash } from './common';\nimport { deserializeCV, serializeCV } from './clarity';\nexport function serializeStacksMessage(message) {\n  switch (message.type) {\n    case StacksMessageType.Address:\n      return serializeAddress(message);\n    case StacksMessageType.Principal:\n      return serializePrincipal(message);\n    case StacksMessageType.LengthPrefixedString:\n      return serializeLPString(message);\n    case StacksMessageType.MemoString:\n      return serializeMemoString(message);\n    case StacksMessageType.AssetInfo:\n      return serializeAssetInfo(message);\n    case StacksMessageType.PostCondition:\n      return serializePostCondition(message);\n    case StacksMessageType.PublicKey:\n      return serializePublicKey(message);\n    case StacksMessageType.LengthPrefixedList:\n      return serializeLPList(message);\n    case StacksMessageType.Payload:\n      return serializePayload(message);\n    case StacksMessageType.TransactionAuthField:\n      return serializeTransactionAuthField(message);\n    case StacksMessageType.MessageSignature:\n      return serializeMessageSignature(message);\n  }\n}\nexport function deserializeStacksMessage(bytesReader, type, listType) {\n  switch (type) {\n    case StacksMessageType.Address:\n      return deserializeAddress(bytesReader);\n    case StacksMessageType.Principal:\n      return deserializePrincipal(bytesReader);\n    case StacksMessageType.LengthPrefixedString:\n      return deserializeLPString(bytesReader);\n    case StacksMessageType.MemoString:\n      return deserializeMemoString(bytesReader);\n    case StacksMessageType.AssetInfo:\n      return deserializeAssetInfo(bytesReader);\n    case StacksMessageType.PostCondition:\n      return deserializePostCondition(bytesReader);\n    case StacksMessageType.PublicKey:\n      return deserializePublicKey(bytesReader);\n    case StacksMessageType.Payload:\n      return deserializePayload(bytesReader);\n    case StacksMessageType.LengthPrefixedList:\n      if (!listType) {\n        throw new DeserializationError('No List Type specified');\n      }\n      return deserializeLPList(bytesReader, listType);\n    case StacksMessageType.MessageSignature:\n      return deserializeMessageSignature(bytesReader);\n    default:\n      throw new Error('Could not recognize StacksMessageType');\n  }\n}\nexport function createEmptyAddress() {\n  return {\n    type: StacksMessageType.Address,\n    version: AddressVersion.MainnetSingleSig,\n    hash160: '0'.repeat(40)\n  };\n}\nexport function addressFromHashMode(hashMode, txVersion, data) {\n  const version = addressHashModeToVersion(hashMode, txVersion);\n  return addressFromVersionHash(version, data);\n}\nexport function addressFromPublicKeys(version, hashMode, numSigs, publicKeys) {\n  if (publicKeys.length === 0) {\n    throw Error('Invalid number of public keys');\n  }\n  if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {\n    if (publicKeys.length !== 1 || numSigs !== 1) {\n      throw Error('Invalid number of public keys or signatures');\n    }\n  }\n  if (hashMode === AddressHashMode.SerializeP2WPKH || hashMode === AddressHashMode.SerializeP2WSH) {\n    for (let i = 0; i < publicKeys.length; i++) {\n      if (!isCompressed(publicKeys[i])) {\n        throw Error('Public keys must be compressed for segwit');\n      }\n    }\n  }\n  switch (hashMode) {\n    case AddressHashMode.SerializeP2PKH:\n      return addressFromVersionHash(version, hashP2PKH(publicKeys[0].data));\n    case AddressHashMode.SerializeP2WPKH:\n      return addressFromVersionHash(version, hashP2WPKH(publicKeys[0].data));\n    case AddressHashMode.SerializeP2SH:\n      return addressFromVersionHash(version, hashP2SH(numSigs, publicKeys.map(serializePublicKey)));\n    case AddressHashMode.SerializeP2WSH:\n      return addressFromVersionHash(version, hashP2WSH(numSigs, publicKeys.map(serializePublicKey)));\n  }\n}\nexport function serializeAddress(address) {\n  const bytesArray = [];\n  bytesArray.push(hexToBytes(intToHex(address.version, 1)));\n  bytesArray.push(hexToBytes(address.hash160));\n  return concatArray(bytesArray);\n}\nexport function deserializeAddress(bytesReader) {\n  const version = hexToInt(bytesToHex(bytesReader.readBytes(1)));\n  const data = bytesToHex(bytesReader.readBytes(20));\n  return {\n    type: StacksMessageType.Address,\n    version,\n    hash160: data\n  };\n}\nexport function serializePrincipal(principal) {\n  const bytesArray = [];\n  bytesArray.push(principal.prefix);\n  bytesArray.push(serializeAddress(principal.address));\n  if (principal.prefix === PostConditionPrincipalID.Contract) {\n    bytesArray.push(serializeLPString(principal.contractName));\n  }\n  return concatArray(bytesArray);\n}\nexport function deserializePrincipal(bytesReader) {\n  const prefix = bytesReader.readUInt8Enum(PostConditionPrincipalID, n => {\n    throw new DeserializationError(`Unexpected Principal payload type: ${n}`);\n  });\n  const address = deserializeAddress(bytesReader);\n  if (prefix === PostConditionPrincipalID.Standard) {\n    return {\n      type: StacksMessageType.Principal,\n      prefix,\n      address\n    };\n  }\n  const contractName = deserializeLPString(bytesReader);\n  return {\n    type: StacksMessageType.Principal,\n    prefix,\n    address,\n    contractName\n  };\n}\nexport function serializeLPString(lps) {\n  const bytesArray = [];\n  const contentBytes = utf8ToBytes(lps.content);\n  const length = contentBytes.byteLength;\n  bytesArray.push(hexToBytes(intToHex(length, lps.lengthPrefixBytes)));\n  bytesArray.push(contentBytes);\n  return concatArray(bytesArray);\n}\nexport function deserializeLPString(bytesReader, prefixBytes, maxLength) {\n  prefixBytes = prefixBytes ? prefixBytes : 1;\n  const length = hexToInt(bytesToHex(bytesReader.readBytes(prefixBytes)));\n  const content = bytesToUtf8(bytesReader.readBytes(length));\n  return createLPString(content, prefixBytes, maxLength ?? 128);\n}\nexport function codeBodyString(content) {\n  return createLPString(content, 4, 100000);\n}\nexport function createMemoString(content) {\n  if (content && exceedsMaxLengthBytes(content, MEMO_MAX_LENGTH_BYTES)) {\n    throw new Error(`Memo exceeds maximum length of ${MEMO_MAX_LENGTH_BYTES} bytes`);\n  }\n  return {\n    type: StacksMessageType.MemoString,\n    content\n  };\n}\nexport function serializeMemoString(memoString) {\n  const bytesArray = [];\n  const contentBytes = utf8ToBytes(memoString.content);\n  const paddedContent = rightPadHexToLength(bytesToHex(contentBytes), MEMO_MAX_LENGTH_BYTES * 2);\n  bytesArray.push(hexToBytes(paddedContent));\n  return concatArray(bytesArray);\n}\nexport function deserializeMemoString(bytesReader) {\n  const content = bytesToUtf8(bytesReader.readBytes(MEMO_MAX_LENGTH_BYTES));\n  return {\n    type: StacksMessageType.MemoString,\n    content\n  };\n}\nexport function serializeAssetInfo(info) {\n  const bytesArray = [];\n  bytesArray.push(serializeAddress(info.address));\n  bytesArray.push(serializeLPString(info.contractName));\n  bytesArray.push(serializeLPString(info.assetName));\n  return concatArray(bytesArray);\n}\nexport function deserializeAssetInfo(bytesReader) {\n  return {\n    type: StacksMessageType.AssetInfo,\n    address: deserializeAddress(bytesReader),\n    contractName: deserializeLPString(bytesReader),\n    assetName: deserializeLPString(bytesReader)\n  };\n}\nexport function createLPList(values, lengthPrefixBytes) {\n  return {\n    type: StacksMessageType.LengthPrefixedList,\n    lengthPrefixBytes: lengthPrefixBytes || 4,\n    values\n  };\n}\nexport function serializeLPList(lpList) {\n  const list = lpList.values;\n  const bytesArray = [];\n  bytesArray.push(hexToBytes(intToHex(list.length, lpList.lengthPrefixBytes)));\n  for (const l of list) {\n    bytesArray.push(serializeStacksMessage(l));\n  }\n  return concatArray(bytesArray);\n}\nexport function deserializeLPList(bytesReader, type, lengthPrefixBytes) {\n  const length = hexToInt(bytesToHex(bytesReader.readBytes(lengthPrefixBytes || 4)));\n  const l = [];\n  for (let index = 0; index < length; index++) {\n    switch (type) {\n      case StacksMessageType.Address:\n        l.push(deserializeAddress(bytesReader));\n        break;\n      case StacksMessageType.LengthPrefixedString:\n        l.push(deserializeLPString(bytesReader));\n        break;\n      case StacksMessageType.MemoString:\n        l.push(deserializeMemoString(bytesReader));\n        break;\n      case StacksMessageType.AssetInfo:\n        l.push(deserializeAssetInfo(bytesReader));\n        break;\n      case StacksMessageType.PostCondition:\n        l.push(deserializePostCondition(bytesReader));\n        break;\n      case StacksMessageType.PublicKey:\n        l.push(deserializePublicKey(bytesReader));\n        break;\n      case StacksMessageType.TransactionAuthField:\n        l.push(deserializeTransactionAuthField(bytesReader));\n        break;\n    }\n  }\n  return createLPList(l, lengthPrefixBytes);\n}\nexport function serializePostCondition(postCondition) {\n  const bytesArray = [];\n  bytesArray.push(postCondition.conditionType);\n  bytesArray.push(serializePrincipal(postCondition.principal));\n  if (postCondition.conditionType === PostConditionType.Fungible || postCondition.conditionType === PostConditionType.NonFungible) {\n    bytesArray.push(serializeAssetInfo(postCondition.assetInfo));\n  }\n  if (postCondition.conditionType === PostConditionType.NonFungible) {\n    bytesArray.push(serializeCV(postCondition.assetName));\n  }\n  bytesArray.push(postCondition.conditionCode);\n  if (postCondition.conditionType === PostConditionType.STX || postCondition.conditionType === PostConditionType.Fungible) {\n    bytesArray.push(intToBytes(postCondition.amount, false, 8));\n  }\n  return concatArray(bytesArray);\n}\nexport function deserializePostCondition(bytesReader) {\n  const postConditionType = bytesReader.readUInt8Enum(PostConditionType, n => {\n    throw new DeserializationError(`Could not read ${n} as PostConditionType`);\n  });\n  const principal = deserializePrincipal(bytesReader);\n  let conditionCode;\n  let assetInfo;\n  let amount;\n  switch (postConditionType) {\n    case PostConditionType.STX:\n      conditionCode = bytesReader.readUInt8Enum(FungibleConditionCode, n => {\n        throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);\n      });\n      amount = BigInt(`0x${bytesToHex(bytesReader.readBytes(8))}`);\n      return {\n        type: StacksMessageType.PostCondition,\n        conditionType: PostConditionType.STX,\n        principal,\n        conditionCode,\n        amount\n      };\n    case PostConditionType.Fungible:\n      assetInfo = deserializeAssetInfo(bytesReader);\n      conditionCode = bytesReader.readUInt8Enum(FungibleConditionCode, n => {\n        throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);\n      });\n      amount = BigInt(`0x${bytesToHex(bytesReader.readBytes(8))}`);\n      return {\n        type: StacksMessageType.PostCondition,\n        conditionType: PostConditionType.Fungible,\n        principal,\n        conditionCode,\n        amount,\n        assetInfo\n      };\n    case PostConditionType.NonFungible:\n      assetInfo = deserializeAssetInfo(bytesReader);\n      const assetName = deserializeCV(bytesReader);\n      conditionCode = bytesReader.readUInt8Enum(NonFungibleConditionCode, n => {\n        throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);\n      });\n      return {\n        type: StacksMessageType.PostCondition,\n        conditionType: PostConditionType.NonFungible,\n        principal,\n        conditionCode,\n        assetInfo,\n        assetName\n      };\n  }\n}","map":{"version":3,"names":["bytesToHex","bytesToUtf8","concatArray","hexToBytes","hexToInt","intToBytes","intToHex","utf8ToBytes","MEMO_MAX_LENGTH_BYTES","AddressHashMode","AddressVersion","StacksMessageType","PostConditionPrincipalID","PostConditionType","FungibleConditionCode","NonFungibleConditionCode","serializePublicKey","deserializePublicKey","isCompressed","exceedsMaxLengthBytes","hashP2PKH","rightPadHexToLength","hashP2SH","hashP2WSH","hashP2WPKH","createLPString","deserializePayload","serializePayload","DeserializationError","deserializeTransactionAuthField","deserializeMessageSignature","serializeMessageSignature","serializeTransactionAuthField","addressHashModeToVersion","addressFromVersionHash","deserializeCV","serializeCV","serializeStacksMessage","message","type","Address","serializeAddress","Principal","serializePrincipal","LengthPrefixedString","serializeLPString","MemoString","serializeMemoString","AssetInfo","serializeAssetInfo","PostCondition","serializePostCondition","PublicKey","LengthPrefixedList","serializeLPList","Payload","TransactionAuthField","MessageSignature","deserializeStacksMessage","bytesReader","listType","deserializeAddress","deserializePrincipal","deserializeLPString","deserializeMemoString","deserializeAssetInfo","deserializePostCondition","deserializeLPList","Error","createEmptyAddress","version","MainnetSingleSig","hash160","repeat","addressFromHashMode","hashMode","txVersion","data","addressFromPublicKeys","numSigs","publicKeys","length","SerializeP2PKH","SerializeP2WPKH","SerializeP2WSH","i","SerializeP2SH","map","address","bytesArray","push","readBytes","principal","prefix","Contract","contractName","readUInt8Enum","n","Standard","lps","contentBytes","content","byteLength","lengthPrefixBytes","prefixBytes","maxLength","codeBodyString","createMemoString","memoString","paddedContent","info","assetName","createLPList","values","lpList","list","l","index","postCondition","conditionType","Fungible","NonFungible","assetInfo","conditionCode","STX","amount","postConditionType","BigInt"],"sources":["C:\\Users\\abasi\\Desktop\\web3-apps\\react-cra\\node_modules\\@stacks\\transactions\\src\\types.ts"],"sourcesContent":["import {\n  bytesToHex,\n  bytesToUtf8,\n  concatArray,\n  hexToBytes,\n  hexToInt,\n  intToBytes,\n  intToHex,\n  utf8ToBytes,\n} from '@stacks/common';\nimport {\n  MEMO_MAX_LENGTH_BYTES,\n  AddressHashMode,\n  AddressVersion,\n  TransactionVersion,\n  StacksMessageType,\n  PostConditionPrincipalID,\n  PostConditionType,\n  FungibleConditionCode,\n  NonFungibleConditionCode,\n} from './constants';\n\nimport { StacksPublicKey, serializePublicKey, deserializePublicKey, isCompressed } from './keys';\n\nimport {\n  exceedsMaxLengthBytes,\n  hashP2PKH,\n  rightPadHexToLength,\n  hashP2SH,\n  hashP2WSH,\n  hashP2WPKH,\n} from './utils';\n\nimport { BytesReader } from './bytesReader';\nimport {\n  PostCondition,\n  StandardPrincipal,\n  ContractPrincipal,\n  PostConditionPrincipal,\n  LengthPrefixedString,\n  AssetInfo,\n  createLPString,\n} from './postcondition-types';\nimport { Payload, deserializePayload, serializePayload } from './payload';\nimport { DeserializationError } from './errors';\nimport {\n  deserializeTransactionAuthField,\n  deserializeMessageSignature,\n  serializeMessageSignature,\n  serializeTransactionAuthField,\n  TransactionAuthField,\n} from './signature';\nimport {\n  MessageSignature,\n  Address,\n  addressHashModeToVersion,\n  addressFromVersionHash,\n} from './common';\nimport { deserializeCV, serializeCV } from './clarity';\nexport type StacksMessage =\n  | Address\n  | PostConditionPrincipal\n  | LengthPrefixedString\n  | LengthPrefixedList\n  | Payload\n  | MemoString\n  | AssetInfo\n  | PostCondition\n  | StacksPublicKey\n  | TransactionAuthField\n  | MessageSignature;\n\nexport function serializeStacksMessage(message: StacksMessage): Uint8Array {\n  switch (message.type) {\n    case StacksMessageType.Address:\n      return serializeAddress(message);\n    case StacksMessageType.Principal:\n      return serializePrincipal(message);\n    case StacksMessageType.LengthPrefixedString:\n      return serializeLPString(message);\n    case StacksMessageType.MemoString:\n      return serializeMemoString(message);\n    case StacksMessageType.AssetInfo:\n      return serializeAssetInfo(message);\n    case StacksMessageType.PostCondition:\n      return serializePostCondition(message);\n    case StacksMessageType.PublicKey:\n      return serializePublicKey(message);\n    case StacksMessageType.LengthPrefixedList:\n      return serializeLPList(message);\n    case StacksMessageType.Payload:\n      return serializePayload(message);\n    case StacksMessageType.TransactionAuthField:\n      return serializeTransactionAuthField(message);\n    case StacksMessageType.MessageSignature:\n      return serializeMessageSignature(message);\n  }\n}\n\nexport function deserializeStacksMessage(\n  bytesReader: BytesReader,\n  type: StacksMessageType,\n  listType?: StacksMessageType\n): StacksMessage {\n  switch (type) {\n    case StacksMessageType.Address:\n      return deserializeAddress(bytesReader);\n    case StacksMessageType.Principal:\n      return deserializePrincipal(bytesReader);\n    case StacksMessageType.LengthPrefixedString:\n      return deserializeLPString(bytesReader);\n    case StacksMessageType.MemoString:\n      return deserializeMemoString(bytesReader);\n    case StacksMessageType.AssetInfo:\n      return deserializeAssetInfo(bytesReader);\n    case StacksMessageType.PostCondition:\n      return deserializePostCondition(bytesReader);\n    case StacksMessageType.PublicKey:\n      return deserializePublicKey(bytesReader);\n    case StacksMessageType.Payload:\n      return deserializePayload(bytesReader);\n    case StacksMessageType.LengthPrefixedList:\n      if (!listType) {\n        throw new DeserializationError('No List Type specified');\n      }\n      return deserializeLPList(bytesReader, listType);\n    case StacksMessageType.MessageSignature:\n      return deserializeMessageSignature(bytesReader);\n    default:\n      throw new Error('Could not recognize StacksMessageType');\n  }\n}\n\nexport function createEmptyAddress(): Address {\n  return {\n    type: StacksMessageType.Address,\n    version: AddressVersion.MainnetSingleSig,\n    hash160: '0'.repeat(40),\n  };\n}\n\nexport function addressFromHashMode(\n  hashMode: AddressHashMode,\n  txVersion: TransactionVersion,\n  data: string\n): Address {\n  const version = addressHashModeToVersion(hashMode, txVersion);\n  return addressFromVersionHash(version, data);\n}\n\nexport function addressFromPublicKeys(\n  version: AddressVersion,\n  hashMode: AddressHashMode,\n  numSigs: number,\n  publicKeys: StacksPublicKey[]\n): Address {\n  if (publicKeys.length === 0) {\n    throw Error('Invalid number of public keys');\n  }\n\n  if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {\n    if (publicKeys.length !== 1 || numSigs !== 1) {\n      throw Error('Invalid number of public keys or signatures');\n    }\n  }\n\n  if (hashMode === AddressHashMode.SerializeP2WPKH || hashMode === AddressHashMode.SerializeP2WSH) {\n    for (let i = 0; i < publicKeys.length; i++) {\n      if (!isCompressed(publicKeys[i])) {\n        throw Error('Public keys must be compressed for segwit');\n      }\n    }\n  }\n\n  switch (hashMode) {\n    case AddressHashMode.SerializeP2PKH:\n      return addressFromVersionHash(version, hashP2PKH(publicKeys[0].data));\n    case AddressHashMode.SerializeP2WPKH:\n      return addressFromVersionHash(version, hashP2WPKH(publicKeys[0].data));\n    case AddressHashMode.SerializeP2SH:\n      return addressFromVersionHash(version, hashP2SH(numSigs, publicKeys.map(serializePublicKey)));\n    case AddressHashMode.SerializeP2WSH:\n      return addressFromVersionHash(\n        version,\n        hashP2WSH(numSigs, publicKeys.map(serializePublicKey))\n      );\n  }\n}\n\nexport function serializeAddress(address: Address): Uint8Array {\n  const bytesArray = [];\n  bytesArray.push(hexToBytes(intToHex(address.version, 1)));\n  bytesArray.push(hexToBytes(address.hash160));\n  return concatArray(bytesArray);\n}\n\nexport function deserializeAddress(bytesReader: BytesReader): Address {\n  const version = hexToInt(bytesToHex(bytesReader.readBytes(1)));\n  const data = bytesToHex(bytesReader.readBytes(20));\n\n  return { type: StacksMessageType.Address, version, hash160: data };\n}\n\nexport function serializePrincipal(principal: PostConditionPrincipal): Uint8Array {\n  const bytesArray = [];\n  bytesArray.push(principal.prefix);\n  bytesArray.push(serializeAddress(principal.address));\n  if (principal.prefix === PostConditionPrincipalID.Contract) {\n    bytesArray.push(serializeLPString(principal.contractName));\n  }\n  return concatArray(bytesArray);\n}\n\nexport function deserializePrincipal(bytesReader: BytesReader): PostConditionPrincipal {\n  const prefix = bytesReader.readUInt8Enum(PostConditionPrincipalID, n => {\n    throw new DeserializationError(`Unexpected Principal payload type: ${n}`);\n  });\n  const address = deserializeAddress(bytesReader);\n  if (prefix === PostConditionPrincipalID.Standard) {\n    return { type: StacksMessageType.Principal, prefix, address } as StandardPrincipal;\n  }\n  const contractName = deserializeLPString(bytesReader);\n  return {\n    type: StacksMessageType.Principal,\n    prefix,\n    address,\n    contractName,\n  } as ContractPrincipal;\n}\n\nexport function serializeLPString(lps: LengthPrefixedString) {\n  const bytesArray = [];\n  const contentBytes = utf8ToBytes(lps.content);\n  const length = contentBytes.byteLength;\n  bytesArray.push(hexToBytes(intToHex(length, lps.lengthPrefixBytes)));\n  bytesArray.push(contentBytes);\n  return concatArray(bytesArray);\n}\n\nexport function deserializeLPString(\n  bytesReader: BytesReader,\n  prefixBytes?: number,\n  maxLength?: number\n): LengthPrefixedString {\n  prefixBytes = prefixBytes ? prefixBytes : 1;\n  const length = hexToInt(bytesToHex(bytesReader.readBytes(prefixBytes)));\n  const content = bytesToUtf8(bytesReader.readBytes(length));\n  return createLPString(content, prefixBytes, maxLength ?? 128);\n}\n\nexport function codeBodyString(content: string): LengthPrefixedString {\n  return createLPString(content, 4, 100_000);\n}\n\nexport interface MemoString {\n  readonly type: StacksMessageType.MemoString;\n  readonly content: string;\n}\n\nexport function createMemoString(content: string): MemoString {\n  if (content && exceedsMaxLengthBytes(content, MEMO_MAX_LENGTH_BYTES)) {\n    throw new Error(`Memo exceeds maximum length of ${MEMO_MAX_LENGTH_BYTES} bytes`);\n  }\n  return { type: StacksMessageType.MemoString, content };\n}\n\nexport function serializeMemoString(memoString: MemoString): Uint8Array {\n  const bytesArray = [];\n  const contentBytes = utf8ToBytes(memoString.content);\n  const paddedContent = rightPadHexToLength(bytesToHex(contentBytes), MEMO_MAX_LENGTH_BYTES * 2);\n  bytesArray.push(hexToBytes(paddedContent));\n  return concatArray(bytesArray);\n}\n\nexport function deserializeMemoString(bytesReader: BytesReader): MemoString {\n  const content = bytesToUtf8(bytesReader.readBytes(MEMO_MAX_LENGTH_BYTES));\n  return { type: StacksMessageType.MemoString, content };\n}\n\nexport function serializeAssetInfo(info: AssetInfo): Uint8Array {\n  const bytesArray = [];\n  bytesArray.push(serializeAddress(info.address));\n  bytesArray.push(serializeLPString(info.contractName));\n  bytesArray.push(serializeLPString(info.assetName));\n  return concatArray(bytesArray);\n}\n\nexport function deserializeAssetInfo(bytesReader: BytesReader): AssetInfo {\n  return {\n    type: StacksMessageType.AssetInfo,\n    address: deserializeAddress(bytesReader),\n    contractName: deserializeLPString(bytesReader),\n    assetName: deserializeLPString(bytesReader),\n  };\n}\n\nexport interface LengthPrefixedList {\n  readonly type: StacksMessageType.LengthPrefixedList;\n  readonly lengthPrefixBytes: number;\n  readonly values: StacksMessage[];\n}\n\nexport function createLPList<T extends StacksMessage>(\n  values: T[],\n  lengthPrefixBytes?: number\n): LengthPrefixedList {\n  return {\n    type: StacksMessageType.LengthPrefixedList,\n    lengthPrefixBytes: lengthPrefixBytes || 4,\n    values,\n  };\n}\n\nexport function serializeLPList(lpList: LengthPrefixedList): Uint8Array {\n  const list = lpList.values;\n  const bytesArray = [];\n  bytesArray.push(hexToBytes(intToHex(list.length, lpList.lengthPrefixBytes)));\n  for (const l of list) {\n    bytesArray.push(serializeStacksMessage(l));\n  }\n  return concatArray(bytesArray);\n}\n\nexport function deserializeLPList(\n  bytesReader: BytesReader,\n  type: StacksMessageType,\n  lengthPrefixBytes?: number\n): LengthPrefixedList {\n  const length = hexToInt(bytesToHex(bytesReader.readBytes(lengthPrefixBytes || 4)));\n\n  const l: StacksMessage[] = [];\n  for (let index = 0; index < length; index++) {\n    switch (type) {\n      case StacksMessageType.Address:\n        l.push(deserializeAddress(bytesReader));\n        break;\n      case StacksMessageType.LengthPrefixedString:\n        l.push(deserializeLPString(bytesReader));\n        break;\n      case StacksMessageType.MemoString:\n        l.push(deserializeMemoString(bytesReader));\n        break;\n      case StacksMessageType.AssetInfo:\n        l.push(deserializeAssetInfo(bytesReader));\n        break;\n      case StacksMessageType.PostCondition:\n        l.push(deserializePostCondition(bytesReader));\n        break;\n      case StacksMessageType.PublicKey:\n        l.push(deserializePublicKey(bytesReader));\n        break;\n      case StacksMessageType.TransactionAuthField:\n        l.push(deserializeTransactionAuthField(bytesReader));\n        break;\n    }\n  }\n  return createLPList(l, lengthPrefixBytes);\n}\n\nexport function serializePostCondition(postCondition: PostCondition): Uint8Array {\n  const bytesArray = [];\n  bytesArray.push(postCondition.conditionType);\n  bytesArray.push(serializePrincipal(postCondition.principal));\n\n  if (\n    postCondition.conditionType === PostConditionType.Fungible ||\n    postCondition.conditionType === PostConditionType.NonFungible\n  ) {\n    bytesArray.push(serializeAssetInfo(postCondition.assetInfo));\n  }\n\n  if (postCondition.conditionType === PostConditionType.NonFungible) {\n    bytesArray.push(serializeCV(postCondition.assetName));\n  }\n\n  bytesArray.push(postCondition.conditionCode);\n\n  if (\n    postCondition.conditionType === PostConditionType.STX ||\n    postCondition.conditionType === PostConditionType.Fungible\n  ) {\n    bytesArray.push(intToBytes(postCondition.amount, false, 8));\n  }\n\n  return concatArray(bytesArray);\n}\n\nexport function deserializePostCondition(bytesReader: BytesReader): PostCondition {\n  const postConditionType = bytesReader.readUInt8Enum(PostConditionType, n => {\n    throw new DeserializationError(`Could not read ${n} as PostConditionType`);\n  });\n\n  const principal = deserializePrincipal(bytesReader);\n\n  let conditionCode;\n  let assetInfo;\n  let amount: bigint;\n  switch (postConditionType) {\n    case PostConditionType.STX:\n      conditionCode = bytesReader.readUInt8Enum(FungibleConditionCode, n => {\n        throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);\n      });\n      amount = BigInt(`0x${bytesToHex(bytesReader.readBytes(8))}`);\n      return {\n        type: StacksMessageType.PostCondition,\n        conditionType: PostConditionType.STX,\n        principal,\n        conditionCode,\n        amount,\n      };\n    case PostConditionType.Fungible:\n      assetInfo = deserializeAssetInfo(bytesReader);\n      conditionCode = bytesReader.readUInt8Enum(FungibleConditionCode, n => {\n        throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);\n      });\n      amount = BigInt(`0x${bytesToHex(bytesReader.readBytes(8))}`);\n      return {\n        type: StacksMessageType.PostCondition,\n        conditionType: PostConditionType.Fungible,\n        principal,\n        conditionCode,\n        amount,\n        assetInfo,\n      };\n    case PostConditionType.NonFungible:\n      assetInfo = deserializeAssetInfo(bytesReader);\n      const assetName = deserializeCV(bytesReader);\n      conditionCode = bytesReader.readUInt8Enum(NonFungibleConditionCode, n => {\n        throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);\n      });\n      return {\n        type: StacksMessageType.PostCondition,\n        conditionType: PostConditionType.NonFungible,\n        principal,\n        conditionCode,\n        assetInfo,\n        assetName,\n      };\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}