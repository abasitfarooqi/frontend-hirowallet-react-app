{"ast":null,"code":"import { hmac } from '@noble/hashes/hmac';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { getPublicKey as nobleGetPublicKey, signSync, utils } from '@noble/secp256k1';\nimport { bytesToHex, concatBytes, hexToBytes, privateKeyToBytes, PRIVATE_KEY_COMPRESSED_LENGTH, readUInt8 } from '@stacks/common';\nimport base58 from 'bs58';\nimport { hashRipemd160 } from './hashRipemd160';\nimport { hashSha256Sync } from './sha2Hash';\nconst BITCOIN_PUBKEYHASH = 0x00;\nutils.hmacSha256Sync = function (key) {\n  const h = hmac.create(sha256, key);\n  for (var _len = arguments.length, msgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    msgs[_key - 1] = arguments[_key];\n  }\n  msgs.forEach(msg => h.update(msg));\n  return h.digest();\n};\nexport function makeECPrivateKey() {\n  return bytesToHex(utils.randomPrivateKey());\n}\nexport function base58CheckDecode(btcAddress) {\n  const bytes = base58.decode(btcAddress);\n  const payload = bytes.slice(0, -4);\n  const checksum = bytes.slice(-4);\n  const newChecksum = sha256(sha256(payload));\n  if (checksum[0] ^ newChecksum[0] | checksum[1] ^ newChecksum[1] | checksum[2] ^ newChecksum[2] | checksum[3] ^ newChecksum[3]) {\n    throw new Error('Invalid checksum');\n  }\n  if (payload.length !== 21) throw new TypeError('Invalid address length');\n  const version = readUInt8(payload, 0);\n  const hash = payload.slice(1);\n  return {\n    version,\n    hash\n  };\n}\nexport function base58Encode(hash) {\n  const checksum = sha256(sha256(hash));\n  return base58.encode(concatBytes(hash, checksum).slice(0, hash.length + 4));\n}\nexport function base58CheckEncode(version, hash) {\n  return base58Encode(concatBytes(new Uint8Array([version]), hash.slice(0, 20)));\n}\nexport function publicKeyToBtcAddress(publicKey) {\n  let version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : BITCOIN_PUBKEYHASH;\n  const publicKeyBytes = typeof publicKey === 'string' ? hexToBytes(publicKey) : publicKey;\n  const publicKeyHash160 = hashRipemd160(hashSha256Sync(publicKeyBytes));\n  return base58CheckEncode(version, publicKeyHash160);\n}\nexport function getPublicKeyFromPrivate(privateKey) {\n  const privateKeyBytes = privateKeyToBytes(privateKey);\n  return bytesToHex(nobleGetPublicKey(privateKeyBytes.slice(0, 32), true));\n}\nexport function ecSign(messageHash, hexPrivateKey) {\n  return signSync(messageHash, privateKeyToBytes(hexPrivateKey).slice(0, 32), {\n    der: false\n  });\n}\nexport function isValidPrivateKey(privateKey) {\n  return utils.isValidPrivateKey(privateKeyToBytes(privateKey));\n}\nexport function compressPrivateKey(privateKey) {\n  const privateKeyBytes = privateKeyToBytes(privateKey);\n  return privateKeyBytes.length == PRIVATE_KEY_COMPRESSED_LENGTH ? privateKeyBytes : concatBytes(privateKeyBytes, new Uint8Array([1]));\n}","map":{"version":3,"names":["hmac","sha256","getPublicKey","nobleGetPublicKey","signSync","utils","bytesToHex","concatBytes","hexToBytes","privateKeyToBytes","PRIVATE_KEY_COMPRESSED_LENGTH","readUInt8","base58","hashRipemd160","hashSha256Sync","BITCOIN_PUBKEYHASH","hmacSha256Sync","key","h","create","_len","arguments","length","msgs","Array","_key","forEach","msg","update","digest","makeECPrivateKey","randomPrivateKey","base58CheckDecode","btcAddress","bytes","decode","payload","slice","checksum","newChecksum","Error","TypeError","version","hash","base58Encode","encode","base58CheckEncode","Uint8Array","publicKeyToBtcAddress","publicKey","undefined","publicKeyBytes","publicKeyHash160","getPublicKeyFromPrivate","privateKey","privateKeyBytes","ecSign","messageHash","hexPrivateKey","der","isValidPrivateKey","compressPrivateKey"],"sources":["C:\\Users\\abasi\\Desktop\\web3-apps\\react-cra\\node_modules\\@stacks\\encryption\\src\\keys.ts"],"sourcesContent":["import { hmac } from '@noble/hashes/hmac';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { getPublicKey as nobleGetPublicKey, signSync, utils } from '@noble/secp256k1';\nimport {\n  bytesToHex,\n  concatBytes,\n  hexToBytes,\n  privateKeyToBytes,\n  PRIVATE_KEY_COMPRESSED_LENGTH,\n  readUInt8,\n} from '@stacks/common';\nimport base58 from 'bs58';\nimport { hashRipemd160 } from './hashRipemd160';\nimport { hashSha256Sync } from './sha2Hash';\n\nconst BITCOIN_PUBKEYHASH = 0x00;\n\n/**\n * To use secp256k1.signSync set utils.hmacSha256Sync to a function using noble-hashes\n * secp256k1.signSync is the counter part of secp256k1.sign (async version)\n * secp256k1.signSync is used within signWithKey in this file\n * secp256k1.signSync is used to maintain the semantics of signWithKey while migrating from elliptic lib\n * utils.hmacSha256Sync docs: https://github.com/paulmillr/noble-secp256k1 readme file\n */\nutils.hmacSha256Sync = (key: Uint8Array, ...msgs: Uint8Array[]) => {\n  const h = hmac.create(sha256, key);\n  msgs.forEach(msg => h.update(msg));\n  return h.digest();\n};\n\n/**\n * @ignore\n */\nexport function makeECPrivateKey() {\n  return bytesToHex(utils.randomPrivateKey());\n}\n\n/**\n * Based on bitcoinjs-lib MIT https://github.com/bitcoinjs/bs58check/blob/12b3e700f355c5c49d0be3f8fc29be6c66e753e9/base.js\n * @ignore\n */\nexport function base58CheckDecode(btcAddress: string): {\n  version: number;\n  hash: Uint8Array;\n} {\n  const bytes = base58.decode(btcAddress);\n  const payload = bytes.slice(0, -4);\n  const checksum = bytes.slice(-4);\n  const newChecksum = sha256(sha256(payload));\n\n  if (\n    (checksum[0] ^ newChecksum[0]) |\n    (checksum[1] ^ newChecksum[1]) |\n    (checksum[2] ^ newChecksum[2]) |\n    (checksum[3] ^ newChecksum[3])\n  ) {\n    throw new Error('Invalid checksum');\n  }\n\n  if (payload.length !== 21) throw new TypeError('Invalid address length');\n\n  const version = readUInt8(payload, 0);\n  const hash = payload.slice(1);\n\n  return { version, hash };\n}\n\n/**\n * @ignore\n */\nexport function base58Encode(hash: Uint8Array) {\n  const checksum = sha256(sha256(hash));\n  return base58.encode(concatBytes(hash, checksum).slice(0, hash.length + 4));\n}\n\n/**\n * @ignore\n */\nexport function base58CheckEncode(version: number, hash: Uint8Array) {\n  return base58Encode(concatBytes(new Uint8Array([version]), hash.slice(0, 20)));\n}\n\n/**\n * @ignore\n */\nexport function publicKeyToBtcAddress(\n  publicKey: string | Uint8Array,\n  version: number = BITCOIN_PUBKEYHASH\n) {\n  const publicKeyBytes = typeof publicKey === 'string' ? hexToBytes(publicKey) : publicKey;\n  const publicKeyHash160 = hashRipemd160(hashSha256Sync(publicKeyBytes));\n  return base58CheckEncode(version, publicKeyHash160);\n}\n\n/**\n * @ignore\n * @returns a compressed public key\n */\nexport function getPublicKeyFromPrivate(privateKey: string | Uint8Array): string {\n  const privateKeyBytes = privateKeyToBytes(privateKey);\n  // for backwards compatibility we always return a compressed public key, regardless of private key mode\n  return bytesToHex(nobleGetPublicKey(privateKeyBytes.slice(0, 32), true));\n}\n\n/**\n * @ignore\n */\nexport function ecSign(messageHash: Uint8Array, hexPrivateKey: string | Uint8Array) {\n  return signSync(messageHash, privateKeyToBytes(hexPrivateKey).slice(0, 32), {\n    der: false,\n  });\n}\n\n/**\n * @ignore\n */\nexport function isValidPrivateKey(privateKey: string | Uint8Array): boolean {\n  return utils.isValidPrivateKey(privateKeyToBytes(privateKey));\n}\n\n/**\n * @ignore\n */\nexport function compressPrivateKey(privateKey: string | Uint8Array): Uint8Array {\n  const privateKeyBytes = privateKeyToBytes(privateKey);\n\n  return privateKeyBytes.length == PRIVATE_KEY_COMPRESSED_LENGTH\n    ? privateKeyBytes // leave compressed\n    : concatBytes(privateKeyBytes, new Uint8Array([1])); // compress\n}\n"],"mappings":"AAAA,SAASA,IAAI,QAAQ,oBAAoB;AACzC,SAASC,MAAM,QAAQ,sBAAsB;AAC7C,SAASC,YAAY,IAAIC,iBAAiB,EAAEC,QAAQ,EAAEC,KAAK,QAAQ,kBAAkB;AACrF,SACEC,UAAU,EACVC,WAAW,EACXC,UAAU,EACVC,iBAAiB,EACjBC,6BAA6B,EAC7BC,SAAS,QACJ,gBAAgB;AACvB,OAAOC,MAAM,MAAM,MAAM;AACzB,SAASC,aAAa,QAAQ,iBAAiB;AAC/C,SAASC,cAAc,QAAQ,YAAY;AAE3C,MAAMC,kBAAkB,GAAG,IAAI;AAS/BV,KAAK,CAACW,cAAc,GAAG,UAACC,GAAe,EAA2B;EAChE,MAAMC,CAAC,GAAGlB,IAAI,CAACmB,MAAM,CAAClB,MAAM,EAAEgB,GAAG,CAAC;EAAC,SAAAG,IAAA,GAAAC,SAAA,CAAAC,MAAA,EADOC,IAAkB,OAAAC,KAAA,CAAAJ,IAAA,OAAAA,IAAA,WAAAK,IAAA,MAAAA,IAAA,GAAAL,IAAA,EAAAK,IAAA;IAAlBF,IAAkB,CAAAE,IAAA,QAAAJ,SAAA,CAAAI,IAAA;EAAA;EAE5DF,IAAI,CAACG,OAAO,CAACC,GAAG,IAAIT,CAAC,CAACU,MAAM,CAACD,GAAG,CAAC,CAAC;EAClC,OAAOT,CAAC,CAACW,MAAM,EAAE;AACnB,CAAC;AAKD,OAAM,SAAUC,gBAAgBA,CAAA;EAC9B,OAAOxB,UAAU,CAACD,KAAK,CAAC0B,gBAAgB,EAAE,CAAC;AAC7C;AAMA,OAAM,SAAUC,iBAAiBA,CAACC,UAAkB;EAIlD,MAAMC,KAAK,GAAGtB,MAAM,CAACuB,MAAM,CAACF,UAAU,CAAC;EACvC,MAAMG,OAAO,GAAGF,KAAK,CAACG,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EAClC,MAAMC,QAAQ,GAAGJ,KAAK,CAACG,KAAK,CAAC,CAAC,CAAC,CAAC;EAChC,MAAME,WAAW,GAAGtC,MAAM,CAACA,MAAM,CAACmC,OAAO,CAAC,CAAC;EAE3C,IACGE,QAAQ,CAAC,CAAC,CAAC,GAAGC,WAAW,CAAC,CAAC,CAAC,GAC5BD,QAAQ,CAAC,CAAC,CAAC,GAAGC,WAAW,CAAC,CAAC,CAAE,GAC7BD,QAAQ,CAAC,CAAC,CAAC,GAAGC,WAAW,CAAC,CAAC,CAAE,GAC7BD,QAAQ,CAAC,CAAC,CAAC,GAAGC,WAAW,CAAC,CAAC,CAAE,EAC9B;IACA,MAAM,IAAIC,KAAK,CAAC,kBAAkB,CAAC;;EAGrC,IAAIJ,OAAO,CAACd,MAAM,KAAK,EAAE,EAAE,MAAM,IAAImB,SAAS,CAAC,wBAAwB,CAAC;EAExE,MAAMC,OAAO,GAAG/B,SAAS,CAACyB,OAAO,EAAE,CAAC,CAAC;EACrC,MAAMO,IAAI,GAAGP,OAAO,CAACC,KAAK,CAAC,CAAC,CAAC;EAE7B,OAAO;IAAEK,OAAO;IAAEC;EAAI,CAAE;AAC1B;AAKA,OAAM,SAAUC,YAAYA,CAACD,IAAgB;EAC3C,MAAML,QAAQ,GAAGrC,MAAM,CAACA,MAAM,CAAC0C,IAAI,CAAC,CAAC;EACrC,OAAO/B,MAAM,CAACiC,MAAM,CAACtC,WAAW,CAACoC,IAAI,EAAEL,QAAQ,CAAC,CAACD,KAAK,CAAC,CAAC,EAAEM,IAAI,CAACrB,MAAM,GAAG,CAAC,CAAC,CAAC;AAC7E;AAKA,OAAM,SAAUwB,iBAAiBA,CAACJ,OAAe,EAAEC,IAAgB;EACjE,OAAOC,YAAY,CAACrC,WAAW,CAAC,IAAIwC,UAAU,CAAC,CAACL,OAAO,CAAC,CAAC,EAAEC,IAAI,CAACN,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AAChF;AAKA,OAAM,SAAUW,qBAAqBA,CACnCC,SAA8B,EACM;EAAA,IAApCP,OAAA,GAAArB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAA6B,SAAA,GAAA7B,SAAA,MAAkBN,kBAAkB;EAEpC,MAAMoC,cAAc,GAAG,OAAOF,SAAS,KAAK,QAAQ,GAAGzC,UAAU,CAACyC,SAAS,CAAC,GAAGA,SAAS;EACxF,MAAMG,gBAAgB,GAAGvC,aAAa,CAACC,cAAc,CAACqC,cAAc,CAAC,CAAC;EACtE,OAAOL,iBAAiB,CAACJ,OAAO,EAAEU,gBAAgB,CAAC;AACrD;AAMA,OAAM,SAAUC,uBAAuBA,CAACC,UAA+B;EACrE,MAAMC,eAAe,GAAG9C,iBAAiB,CAAC6C,UAAU,CAAC;EAErD,OAAOhD,UAAU,CAACH,iBAAiB,CAACoD,eAAe,CAAClB,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;AAC1E;AAKA,OAAM,SAAUmB,MAAMA,CAACC,WAAuB,EAAEC,aAAkC;EAChF,OAAOtD,QAAQ,CAACqD,WAAW,EAAEhD,iBAAiB,CAACiD,aAAa,CAAC,CAACrB,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE;IAC1EsB,GAAG,EAAE;GACN,CAAC;AACJ;AAKA,OAAM,SAAUC,iBAAiBA,CAACN,UAA+B;EAC/D,OAAOjD,KAAK,CAACuD,iBAAiB,CAACnD,iBAAiB,CAAC6C,UAAU,CAAC,CAAC;AAC/D;AAKA,OAAM,SAAUO,kBAAkBA,CAACP,UAA+B;EAChE,MAAMC,eAAe,GAAG9C,iBAAiB,CAAC6C,UAAU,CAAC;EAErD,OAAOC,eAAe,CAACjC,MAAM,IAAIZ,6BAA6B,GAC1D6C,eAAe,GACfhD,WAAW,CAACgD,eAAe,EAAE,IAAIR,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvD"},"metadata":{},"sourceType":"module","externalDependencies":[]}