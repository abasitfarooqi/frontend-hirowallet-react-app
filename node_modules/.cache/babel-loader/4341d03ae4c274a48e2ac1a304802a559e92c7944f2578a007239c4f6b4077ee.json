{"ast":null,"code":"import { ClarityType, intCV, uintCV, bufferCV, trueCV, falseCV, standardPrincipalCVFromAddress, contractPrincipalCVFromAddress, responseOkCV, responseErrorCV, noneCV, someCV, listCV, tupleCV } from '.';\nimport { BytesReader } from '../bytesReader';\nimport { deserializeAddress, deserializeLPString } from '../types';\nimport { DeserializationError } from '../errors';\nimport { stringAsciiCV, stringUtf8CV } from './types/stringCV';\nimport { bytesToAscii, bytesToUtf8, hexToBytes } from '@stacks/common';\nexport default function deserializeCV(serializedClarityValue) {\n  let bytesReader;\n  if (typeof serializedClarityValue === 'string') {\n    const hasHexPrefix = serializedClarityValue.slice(0, 2).toLowerCase() === '0x';\n    bytesReader = new BytesReader(hexToBytes(hasHexPrefix ? serializedClarityValue.slice(2) : serializedClarityValue));\n  } else if (serializedClarityValue instanceof Uint8Array) {\n    bytesReader = new BytesReader(serializedClarityValue);\n  } else {\n    bytesReader = serializedClarityValue;\n  }\n  const type = bytesReader.readUInt8Enum(ClarityType, n => {\n    throw new DeserializationError(`Cannot recognize Clarity Type: ${n}`);\n  });\n  switch (type) {\n    case ClarityType.Int:\n      return intCV(bytesReader.readBytes(16));\n    case ClarityType.UInt:\n      return uintCV(bytesReader.readBytes(16));\n    case ClarityType.Buffer:\n      const bufferLength = bytesReader.readUInt32BE();\n      return bufferCV(bytesReader.readBytes(bufferLength));\n    case ClarityType.BoolTrue:\n      return trueCV();\n    case ClarityType.BoolFalse:\n      return falseCV();\n    case ClarityType.PrincipalStandard:\n      const sAddress = deserializeAddress(bytesReader);\n      return standardPrincipalCVFromAddress(sAddress);\n    case ClarityType.PrincipalContract:\n      const cAddress = deserializeAddress(bytesReader);\n      const contractName = deserializeLPString(bytesReader);\n      return contractPrincipalCVFromAddress(cAddress, contractName);\n    case ClarityType.ResponseOk:\n      return responseOkCV(deserializeCV(bytesReader));\n    case ClarityType.ResponseErr:\n      return responseErrorCV(deserializeCV(bytesReader));\n    case ClarityType.OptionalNone:\n      return noneCV();\n    case ClarityType.OptionalSome:\n      return someCV(deserializeCV(bytesReader));\n    case ClarityType.List:\n      const listLength = bytesReader.readUInt32BE();\n      const listContents = [];\n      for (let i = 0; i < listLength; i++) {\n        listContents.push(deserializeCV(bytesReader));\n      }\n      return listCV(listContents);\n    case ClarityType.Tuple:\n      const tupleLength = bytesReader.readUInt32BE();\n      const tupleContents = {};\n      for (let i = 0; i < tupleLength; i++) {\n        const clarityName = deserializeLPString(bytesReader).content;\n        if (clarityName === undefined) {\n          throw new DeserializationError('\"content\" is undefined');\n        }\n        tupleContents[clarityName] = deserializeCV(bytesReader);\n      }\n      return tupleCV(tupleContents);\n    case ClarityType.StringASCII:\n      const asciiStrLen = bytesReader.readUInt32BE();\n      const asciiStr = bytesToAscii(bytesReader.readBytes(asciiStrLen));\n      return stringAsciiCV(asciiStr);\n    case ClarityType.StringUTF8:\n      const utf8StrLen = bytesReader.readUInt32BE();\n      const utf8Str = bytesToUtf8(bytesReader.readBytes(utf8StrLen));\n      return stringUtf8CV(utf8Str);\n    default:\n      throw new DeserializationError('Unable to deserialize Clarity Value from Uint8Array. Could not find valid Clarity Type.');\n  }\n}","map":{"version":3,"names":["ClarityType","intCV","uintCV","bufferCV","trueCV","falseCV","standardPrincipalCVFromAddress","contractPrincipalCVFromAddress","responseOkCV","responseErrorCV","noneCV","someCV","listCV","tupleCV","BytesReader","deserializeAddress","deserializeLPString","DeserializationError","stringAsciiCV","stringUtf8CV","bytesToAscii","bytesToUtf8","hexToBytes","deserializeCV","serializedClarityValue","bytesReader","hasHexPrefix","slice","toLowerCase","Uint8Array","type","readUInt8Enum","n","Int","readBytes","UInt","Buffer","bufferLength","readUInt32BE","BoolTrue","BoolFalse","PrincipalStandard","sAddress","PrincipalContract","cAddress","contractName","ResponseOk","ResponseErr","OptionalNone","OptionalSome","List","listLength","listContents","i","push","Tuple","tupleLength","tupleContents","clarityName","content","undefined","StringASCII","asciiStrLen","asciiStr","StringUTF8","utf8StrLen","utf8Str"],"sources":["C:\\Users\\abasi\\Desktop\\web3-apps\\react-cra\\node_modules\\@stacks\\transactions\\src\\clarity\\deserialize.ts"],"sourcesContent":["import {\n  ClarityType,\n  ClarityValue,\n  intCV,\n  uintCV,\n  bufferCV,\n  trueCV,\n  falseCV,\n  standardPrincipalCVFromAddress,\n  contractPrincipalCVFromAddress,\n  responseOkCV,\n  responseErrorCV,\n  noneCV,\n  someCV,\n  listCV,\n  tupleCV,\n} from '.';\nimport { BytesReader as BytesReader } from '../bytesReader';\nimport { deserializeAddress, deserializeLPString } from '../types';\nimport { DeserializationError } from '../errors';\nimport { stringAsciiCV, stringUtf8CV } from './types/stringCV';\nimport { bytesToAscii, bytesToUtf8, hexToBytes } from '@stacks/common';\n\n/**\n * Deserializes clarity value to clarity type\n *\n * @param {value} Uint8Array | string value to be converted to clarity type\n **\n * @returns {ClarityType} returns the clarity type instance\n *\n * @example\n * ```\n *  import { intCV, serializeCV, deserializeCV } from '@stacks/transactions';\n *\n *  const serialized = serializeCV(intCV(100)); // Similarly works for other clarity types as well like listCV, booleanCV ...\n *\n *  // <Uint8Array 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 64>\n *\n *  const deserialized = deserializeCV(serialized);\n *  // { type: 0, value: 100n }\n * ```\n *\n * @see\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts | clarity test cases for more examples}\n */\nexport default function deserializeCV<T extends ClarityValue = ClarityValue>(\n  serializedClarityValue: BytesReader | Uint8Array | string\n): T {\n  let bytesReader: BytesReader;\n  if (typeof serializedClarityValue === 'string') {\n    const hasHexPrefix = serializedClarityValue.slice(0, 2).toLowerCase() === '0x';\n    bytesReader = new BytesReader(\n      hexToBytes(hasHexPrefix ? serializedClarityValue.slice(2) : serializedClarityValue)\n    );\n  } else if (serializedClarityValue instanceof Uint8Array) {\n    bytesReader = new BytesReader(serializedClarityValue);\n  } else {\n    bytesReader = serializedClarityValue;\n  }\n  const type = bytesReader.readUInt8Enum(ClarityType, n => {\n    throw new DeserializationError(`Cannot recognize Clarity Type: ${n}`);\n  });\n\n  switch (type) {\n    case ClarityType.Int:\n      return intCV(bytesReader.readBytes(16)) as T;\n\n    case ClarityType.UInt:\n      return uintCV(bytesReader.readBytes(16)) as T;\n\n    case ClarityType.Buffer:\n      const bufferLength = bytesReader.readUInt32BE();\n      return bufferCV(bytesReader.readBytes(bufferLength)) as T;\n\n    case ClarityType.BoolTrue:\n      return trueCV() as T;\n\n    case ClarityType.BoolFalse:\n      return falseCV() as T;\n\n    case ClarityType.PrincipalStandard:\n      const sAddress = deserializeAddress(bytesReader);\n      return standardPrincipalCVFromAddress(sAddress) as T;\n\n    case ClarityType.PrincipalContract:\n      const cAddress = deserializeAddress(bytesReader);\n      const contractName = deserializeLPString(bytesReader);\n      return contractPrincipalCVFromAddress(cAddress, contractName) as T;\n\n    case ClarityType.ResponseOk:\n      return responseOkCV(deserializeCV(bytesReader)) as T;\n\n    case ClarityType.ResponseErr:\n      return responseErrorCV(deserializeCV(bytesReader)) as T;\n\n    case ClarityType.OptionalNone:\n      return noneCV() as T;\n\n    case ClarityType.OptionalSome:\n      return someCV(deserializeCV(bytesReader)) as T;\n\n    case ClarityType.List:\n      const listLength = bytesReader.readUInt32BE();\n      const listContents: ClarityValue[] = [];\n      for (let i = 0; i < listLength; i++) {\n        listContents.push(deserializeCV(bytesReader));\n      }\n      return listCV(listContents) as T;\n\n    case ClarityType.Tuple:\n      const tupleLength = bytesReader.readUInt32BE();\n      const tupleContents: { [key: string]: ClarityValue } = {};\n      for (let i = 0; i < tupleLength; i++) {\n        const clarityName = deserializeLPString(bytesReader).content;\n        if (clarityName === undefined) {\n          throw new DeserializationError('\"content\" is undefined');\n        }\n        tupleContents[clarityName] = deserializeCV(bytesReader);\n      }\n      return tupleCV(tupleContents) as T;\n\n    case ClarityType.StringASCII:\n      const asciiStrLen = bytesReader.readUInt32BE();\n      const asciiStr = bytesToAscii(bytesReader.readBytes(asciiStrLen));\n      return stringAsciiCV(asciiStr) as T;\n\n    case ClarityType.StringUTF8:\n      const utf8StrLen = bytesReader.readUInt32BE();\n      const utf8Str = bytesToUtf8(bytesReader.readBytes(utf8StrLen));\n      return stringUtf8CV(utf8Str) as T;\n\n    default:\n      throw new DeserializationError(\n        'Unable to deserialize Clarity Value from Uint8Array. Could not find valid Clarity Type.'\n      );\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}