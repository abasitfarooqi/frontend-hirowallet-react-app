{"ast":null,"code":"import { readUInt16LE, readUInt32LE, readUInt8, writeUInt16LE, writeUInt32LE, writeUInt8 } from '@stacks/common';\nconst MAX_SAFE_INTEGER = 9007199254740991;\nfunction ensureUInt53(n) {\n  if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0) throw new RangeError('value out of range');\n}\nexport function encode(number, bytes) {\n  let offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  ensureUInt53(number);\n  if (!bytes) bytes = new Uint8Array(encodingLength(number));\n  if (number < 0xfd) {\n    writeUInt8(bytes, number, offset);\n  } else if (number <= 65535) {\n    writeUInt8(bytes, 0xfd, offset);\n    writeUInt16LE(bytes, number, offset + 1);\n  } else if (number <= 4294967295) {\n    writeUInt8(bytes, 0xfe, offset);\n    writeUInt32LE(bytes, number, offset + 1);\n  } else {\n    writeUInt8(bytes, 0xff, offset);\n    writeUInt32LE(bytes, number >>> 0, offset + 1);\n    writeUInt32LE(bytes, number / 4294967296 | 0, offset + 5);\n  }\n  return bytes;\n}\nexport function decode(bytes) {\n  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  const first = readUInt8(bytes, offset);\n  if (first < 0xfd) {\n    return first;\n  } else if (first === 0xfd) {\n    return readUInt16LE(bytes, offset + 1);\n  } else if (first === 0xfe) {\n    return readUInt32LE(bytes, offset + 1);\n  } else {\n    const lo = readUInt32LE(bytes, offset + 1);\n    const hi = readUInt32LE(bytes, offset + 5);\n    const number = hi * 4294967296 + lo;\n    ensureUInt53(number);\n    return number;\n  }\n}\nexport function encodingLength(number) {\n  ensureUInt53(number);\n  return number < 0xfd ? 1 : number <= 65535 ? 3 : number <= 4294967295 ? 5 : 9;\n}","map":{"version":3,"names":["readUInt16LE","readUInt32LE","readUInt8","writeUInt16LE","writeUInt32LE","writeUInt8","MAX_SAFE_INTEGER","ensureUInt53","n","RangeError","encode","number","bytes","offset","arguments","length","undefined","Uint8Array","encodingLength","decode","first","lo","hi"],"sources":["C:\\Users\\abasi\\Desktop\\web3-apps\\react-cra\\node_modules\\@stacks\\encryption\\src\\varuint.ts"],"sourcesContent":["import {\n  readUInt16LE,\n  readUInt32LE,\n  readUInt8,\n  writeUInt16LE,\n  writeUInt32LE,\n  writeUInt8,\n} from '@stacks/common';\n\n// The following methods are based on `bitcoinjs/varuint-bitcoin` implementation\n// https://github.com/bitcoinjs/varuint-bitcoin/blob/8342fe7362f20a412d61b9ade20839aafaa7f78e/index.js\n\n// Copyright (c) 2016 Kirill Fomichev\n// Parts of this software are based on https://github.com/mappum/bitcoin-protocol\n// Copyright (c) 2016 Matt Bell\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the “Software”), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// Number.MAX_SAFE_INTEGER\nconst MAX_SAFE_INTEGER = 9_007_199_254_740_991;\n\nfunction ensureUInt53(n: number) {\n  if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0) throw new RangeError('value out of range');\n}\n\nexport function encode(number: number, bytes?: Uint8Array, offset: number = 0) {\n  ensureUInt53(number);\n  if (!bytes) bytes = new Uint8Array(encodingLength(number));\n\n  // 8 bit\n  if (number < 0xfd) {\n    writeUInt8(bytes, number, offset);\n\n    // 16 bit\n  } else if (number <= 0xff_ff) {\n    writeUInt8(bytes, 0xfd, offset);\n    writeUInt16LE(bytes, number, offset + 1);\n\n    // 32 bit\n  } else if (number <= 0xff_ff_ff_ff) {\n    writeUInt8(bytes, 0xfe, offset);\n    writeUInt32LE(bytes, number, offset + 1);\n\n    // 64 bit\n  } else {\n    writeUInt8(bytes, 0xff, offset);\n    writeUInt32LE(bytes, number >>> 0, offset + 1);\n    writeUInt32LE(bytes, (number / 0x1_00_00_00_00) | 0, offset + 5);\n  }\n\n  return bytes;\n}\n\nexport function decode(bytes: Uint8Array, offset: number = 0) {\n  const first = readUInt8(bytes, offset);\n\n  // 8 bit\n  if (first < 0xfd) {\n    return first;\n\n    // 16 bit\n  } else if (first === 0xfd) {\n    return readUInt16LE(bytes, offset + 1);\n\n    // 32 bit\n  } else if (first === 0xfe) {\n    return readUInt32LE(bytes, offset + 1);\n\n    // 64 bit\n  } else {\n    const lo = readUInt32LE(bytes, offset + 1);\n    const hi = readUInt32LE(bytes, offset + 5);\n    const number = hi * 0x01_00_00_00_00 + lo;\n    ensureUInt53(number);\n\n    return number;\n  }\n}\n\nexport function encodingLength(number: number) {\n  ensureUInt53(number);\n\n  return number < 0xfd ? 1 : number <= 0xff_ff ? 3 : number <= 0xff_ff_ff_ff ? 5 : 9;\n}\n"],"mappings":"AAAA,SACEA,YAAY,EACZC,YAAY,EACZC,SAAS,EACTC,aAAa,EACbC,aAAa,EACbC,UAAU,QACL,gBAAgB;AAkBvB,MAAMC,gBAAgB,GAAG,gBAAqB;AAE9C,SAASC,YAAYA,CAACC,CAAS;EAC7B,IAAIA,CAAC,GAAG,CAAC,IAAIA,CAAC,GAAGF,gBAAgB,IAAIE,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,MAAM,IAAIC,UAAU,CAAC,oBAAoB,CAAC;AAC9F;AAEA,OAAM,SAAUC,MAAMA,CAACC,MAAc,EAAEC,KAAkB,EAAoB;EAAA,IAAlBC,MAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAiB,CAAC;EAC3EP,YAAY,CAACI,MAAM,CAAC;EACpB,IAAI,CAACC,KAAK,EAAEA,KAAK,GAAG,IAAIK,UAAU,CAACC,cAAc,CAACP,MAAM,CAAC,CAAC;EAG1D,IAAIA,MAAM,GAAG,IAAI,EAAE;IACjBN,UAAU,CAACO,KAAK,EAAED,MAAM,EAAEE,MAAM,CAAC;GAGlC,MAAM,IAAIF,MAAM,IAAI,KAAO,EAAE;IAC5BN,UAAU,CAACO,KAAK,EAAE,IAAI,EAAEC,MAAM,CAAC;IAC/BV,aAAa,CAACS,KAAK,EAAED,MAAM,EAAEE,MAAM,GAAG,CAAC,CAAC;GAGzC,MAAM,IAAIF,MAAM,IAAI,UAAa,EAAE;IAClCN,UAAU,CAACO,KAAK,EAAE,IAAI,EAAEC,MAAM,CAAC;IAC/BT,aAAa,CAACQ,KAAK,EAAED,MAAM,EAAEE,MAAM,GAAG,CAAC,CAAC;GAGzC,MAAM;IACLR,UAAU,CAACO,KAAK,EAAE,IAAI,EAAEC,MAAM,CAAC;IAC/BT,aAAa,CAACQ,KAAK,EAAED,MAAM,KAAK,CAAC,EAAEE,MAAM,GAAG,CAAC,CAAC;IAC9CT,aAAa,CAACQ,KAAK,EAAGD,MAAM,GAAG,UAAe,GAAI,CAAC,EAAEE,MAAM,GAAG,CAAC,CAAC;;EAGlE,OAAOD,KAAK;AACd;AAEA,OAAM,SAAUO,MAAMA,CAACP,KAAiB,EAAoB;EAAA,IAAlBC,MAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAiB,CAAC;EAC1D,MAAMM,KAAK,GAAGlB,SAAS,CAACU,KAAK,EAAEC,MAAM,CAAC;EAGtC,IAAIO,KAAK,GAAG,IAAI,EAAE;IAChB,OAAOA,KAAK;GAGb,MAAM,IAAIA,KAAK,KAAK,IAAI,EAAE;IACzB,OAAOpB,YAAY,CAACY,KAAK,EAAEC,MAAM,GAAG,CAAC,CAAC;GAGvC,MAAM,IAAIO,KAAK,KAAK,IAAI,EAAE;IACzB,OAAOnB,YAAY,CAACW,KAAK,EAAEC,MAAM,GAAG,CAAC,CAAC;GAGvC,MAAM;IACL,MAAMQ,EAAE,GAAGpB,YAAY,CAACW,KAAK,EAAEC,MAAM,GAAG,CAAC,CAAC;IAC1C,MAAMS,EAAE,GAAGrB,YAAY,CAACW,KAAK,EAAEC,MAAM,GAAG,CAAC,CAAC;IAC1C,MAAMF,MAAM,GAAGW,EAAE,GAAG,UAAgB,GAAGD,EAAE;IACzCd,YAAY,CAACI,MAAM,CAAC;IAEpB,OAAOA,MAAM;;AAEjB;AAEA,OAAM,SAAUO,cAAcA,CAACP,MAAc;EAC3CJ,YAAY,CAACI,MAAM,CAAC;EAEpB,OAAOA,MAAM,GAAG,IAAI,GAAG,CAAC,GAAGA,MAAM,IAAI,KAAO,GAAG,CAAC,GAAGA,MAAM,IAAI,UAAa,GAAG,CAAC,GAAG,CAAC;AACpF"},"metadata":{},"sourceType":"module","externalDependencies":[]}