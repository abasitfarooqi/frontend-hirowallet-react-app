{"ast":null,"code":"import { concatArray, concatBytes, bigIntToBytes, toTwos, writeUInt32BE, utf8ToBytes, asciiToBytes } from '@stacks/common';\nimport { serializeAddress, serializeLPString } from '../types';\nimport { createLPString } from '../postcondition-types';\nimport { ClarityType } from './constants';\nimport { SerializationError } from '../errors';\nimport { CLARITY_INT_BYTE_SIZE, CLARITY_INT_SIZE } from '../constants';\nfunction bytesWithTypeID(typeId, bytes) {\n  return concatArray([typeId, bytes]);\n}\nfunction serializeBoolCV(value) {\n  return new Uint8Array([value.type]);\n}\nfunction serializeOptionalCV(cv) {\n  if (cv.type === ClarityType.OptionalNone) {\n    return new Uint8Array([cv.type]);\n  } else {\n    return bytesWithTypeID(cv.type, serializeCV(cv.value));\n  }\n}\nfunction serializeBufferCV(cv) {\n  const length = new Uint8Array(4);\n  writeUInt32BE(length, cv.buffer.length, 0);\n  return bytesWithTypeID(cv.type, concatBytes(length, cv.buffer));\n}\nfunction serializeIntCV(cv) {\n  const bytes = bigIntToBytes(toTwos(cv.value, BigInt(CLARITY_INT_SIZE)), CLARITY_INT_BYTE_SIZE);\n  return bytesWithTypeID(cv.type, bytes);\n}\nfunction serializeUIntCV(cv) {\n  const bytes = bigIntToBytes(cv.value, CLARITY_INT_BYTE_SIZE);\n  return bytesWithTypeID(cv.type, bytes);\n}\nfunction serializeStandardPrincipalCV(cv) {\n  return bytesWithTypeID(cv.type, serializeAddress(cv.address));\n}\nfunction serializeContractPrincipalCV(cv) {\n  return bytesWithTypeID(cv.type, concatBytes(serializeAddress(cv.address), serializeLPString(cv.contractName)));\n}\nfunction serializeResponseCV(cv) {\n  return bytesWithTypeID(cv.type, serializeCV(cv.value));\n}\nfunction serializeListCV(cv) {\n  const bytesArray = [];\n  const length = new Uint8Array(4);\n  writeUInt32BE(length, cv.list.length, 0);\n  bytesArray.push(length);\n  for (const value of cv.list) {\n    const serializedValue = serializeCV(value);\n    bytesArray.push(serializedValue);\n  }\n  return bytesWithTypeID(cv.type, concatArray(bytesArray));\n}\nfunction serializeTupleCV(cv) {\n  const bytesArray = [];\n  const length = new Uint8Array(4);\n  writeUInt32BE(length, Object.keys(cv.data).length, 0);\n  bytesArray.push(length);\n  const lexicographicOrder = Object.keys(cv.data).sort((a, b) => a.localeCompare(b));\n  for (const key of lexicographicOrder) {\n    const nameWithLength = createLPString(key);\n    bytesArray.push(serializeLPString(nameWithLength));\n    const serializedValue = serializeCV(cv.data[key]);\n    bytesArray.push(serializedValue);\n  }\n  return bytesWithTypeID(cv.type, concatArray(bytesArray));\n}\nfunction serializeStringCV(cv, encoding) {\n  const bytesArray = [];\n  const str = encoding == 'ascii' ? asciiToBytes(cv.data) : utf8ToBytes(cv.data);\n  const len = new Uint8Array(4);\n  writeUInt32BE(len, str.length, 0);\n  bytesArray.push(len);\n  bytesArray.push(str);\n  return bytesWithTypeID(cv.type, concatArray(bytesArray));\n}\nfunction serializeStringAsciiCV(cv) {\n  return serializeStringCV(cv, 'ascii');\n}\nfunction serializeStringUtf8CV(cv) {\n  return serializeStringCV(cv, 'utf8');\n}\nexport function serializeCV(value) {\n  switch (value.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return serializeBoolCV(value);\n    case ClarityType.OptionalNone:\n    case ClarityType.OptionalSome:\n      return serializeOptionalCV(value);\n    case ClarityType.Buffer:\n      return serializeBufferCV(value);\n    case ClarityType.UInt:\n      return serializeUIntCV(value);\n    case ClarityType.Int:\n      return serializeIntCV(value);\n    case ClarityType.PrincipalStandard:\n      return serializeStandardPrincipalCV(value);\n    case ClarityType.PrincipalContract:\n      return serializeContractPrincipalCV(value);\n    case ClarityType.ResponseOk:\n    case ClarityType.ResponseErr:\n      return serializeResponseCV(value);\n    case ClarityType.List:\n      return serializeListCV(value);\n    case ClarityType.Tuple:\n      return serializeTupleCV(value);\n    case ClarityType.StringASCII:\n      return serializeStringAsciiCV(value);\n    case ClarityType.StringUTF8:\n      return serializeStringUtf8CV(value);\n    default:\n      throw new SerializationError('Unable to serialize. Invalid Clarity Value.');\n  }\n}","map":{"version":3,"names":["concatArray","concatBytes","bigIntToBytes","toTwos","writeUInt32BE","utf8ToBytes","asciiToBytes","serializeAddress","serializeLPString","createLPString","ClarityType","SerializationError","CLARITY_INT_BYTE_SIZE","CLARITY_INT_SIZE","bytesWithTypeID","typeId","bytes","serializeBoolCV","value","Uint8Array","type","serializeOptionalCV","cv","OptionalNone","serializeCV","serializeBufferCV","length","buffer","serializeIntCV","BigInt","serializeUIntCV","serializeStandardPrincipalCV","address","serializeContractPrincipalCV","contractName","serializeResponseCV","serializeListCV","bytesArray","list","push","serializedValue","serializeTupleCV","Object","keys","data","lexicographicOrder","sort","a","b","localeCompare","key","nameWithLength","serializeStringCV","encoding","str","len","serializeStringAsciiCV","serializeStringUtf8CV","BoolTrue","BoolFalse","OptionalSome","Buffer","UInt","Int","PrincipalStandard","PrincipalContract","ResponseOk","ResponseErr","List","Tuple","StringASCII","StringUTF8"],"sources":["C:\\Users\\abasi\\Desktop\\web3-apps\\react-cra\\node_modules\\@stacks\\transactions\\src\\clarity\\serialize.ts"],"sourcesContent":["import {\n  concatArray,\n  concatBytes,\n  bigIntToBytes,\n  toTwos,\n  writeUInt32BE,\n  utf8ToBytes,\n  asciiToBytes,\n} from '@stacks/common';\nimport { serializeAddress, serializeLPString } from '../types';\nimport { createLPString } from '../postcondition-types';\nimport {\n  BooleanCV,\n  OptionalCV,\n  BufferCV,\n  IntCV,\n  UIntCV,\n  StandardPrincipalCV,\n  ContractPrincipalCV,\n  ResponseCV,\n  ListCV,\n  TupleCV,\n  ClarityValue,\n} from '.';\nimport { ClarityType } from './constants';\n\nimport { SerializationError } from '../errors';\nimport { StringAsciiCV, StringUtf8CV } from './types/stringCV';\nimport { CLARITY_INT_BYTE_SIZE, CLARITY_INT_SIZE } from '../constants';\n\nfunction bytesWithTypeID(typeId: ClarityType, bytes: Uint8Array): Uint8Array {\n  return concatArray([typeId, bytes]);\n}\n\nfunction serializeBoolCV(value: BooleanCV): Uint8Array {\n  return new Uint8Array([value.type]);\n}\n\nfunction serializeOptionalCV(cv: OptionalCV): Uint8Array {\n  if (cv.type === ClarityType.OptionalNone) {\n    return new Uint8Array([cv.type]);\n  } else {\n    return bytesWithTypeID(cv.type, serializeCV(cv.value));\n  }\n}\n\nfunction serializeBufferCV(cv: BufferCV): Uint8Array {\n  const length = new Uint8Array(4);\n  writeUInt32BE(length, cv.buffer.length, 0);\n  return bytesWithTypeID(cv.type, concatBytes(length, cv.buffer));\n}\n\nfunction serializeIntCV(cv: IntCV): Uint8Array {\n  const bytes = bigIntToBytes(toTwos(cv.value, BigInt(CLARITY_INT_SIZE)), CLARITY_INT_BYTE_SIZE);\n  return bytesWithTypeID(cv.type, bytes);\n}\n\nfunction serializeUIntCV(cv: UIntCV): Uint8Array {\n  const bytes = bigIntToBytes(cv.value, CLARITY_INT_BYTE_SIZE);\n  return bytesWithTypeID(cv.type, bytes);\n}\n\nfunction serializeStandardPrincipalCV(cv: StandardPrincipalCV): Uint8Array {\n  return bytesWithTypeID(cv.type, serializeAddress(cv.address));\n}\n\nfunction serializeContractPrincipalCV(cv: ContractPrincipalCV): Uint8Array {\n  return bytesWithTypeID(\n    cv.type,\n    concatBytes(serializeAddress(cv.address), serializeLPString(cv.contractName))\n  );\n}\n\nfunction serializeResponseCV(cv: ResponseCV) {\n  return bytesWithTypeID(cv.type, serializeCV(cv.value));\n}\n\nfunction serializeListCV(cv: ListCV) {\n  const bytesArray = [];\n\n  const length = new Uint8Array(4);\n  writeUInt32BE(length, cv.list.length, 0);\n  bytesArray.push(length);\n\n  for (const value of cv.list) {\n    const serializedValue = serializeCV(value);\n    bytesArray.push(serializedValue);\n  }\n\n  return bytesWithTypeID(cv.type, concatArray(bytesArray));\n}\n\nfunction serializeTupleCV(cv: TupleCV) {\n  const bytesArray = [];\n\n  const length = new Uint8Array(4);\n  writeUInt32BE(length, Object.keys(cv.data).length, 0);\n  bytesArray.push(length);\n\n  const lexicographicOrder = Object.keys(cv.data).sort((a, b) => a.localeCompare(b));\n\n  for (const key of lexicographicOrder) {\n    const nameWithLength = createLPString(key);\n    bytesArray.push(serializeLPString(nameWithLength));\n\n    const serializedValue = serializeCV(cv.data[key]);\n    bytesArray.push(serializedValue);\n  }\n\n  return bytesWithTypeID(cv.type, concatArray(bytesArray));\n}\n\nfunction serializeStringCV(cv: StringAsciiCV | StringUtf8CV, encoding: 'ascii' | 'utf8') {\n  const bytesArray = [];\n\n  const str = encoding == 'ascii' ? asciiToBytes(cv.data) : utf8ToBytes(cv.data);\n  const len = new Uint8Array(4);\n  writeUInt32BE(len, str.length, 0);\n\n  bytesArray.push(len);\n  bytesArray.push(str);\n\n  return bytesWithTypeID(cv.type, concatArray(bytesArray));\n}\n\nfunction serializeStringAsciiCV(cv: StringAsciiCV) {\n  return serializeStringCV(cv, 'ascii');\n}\n\nfunction serializeStringUtf8CV(cv: StringUtf8CV) {\n  return serializeStringCV(cv, 'utf8');\n}\n\n/**\n * Serializes clarity value to Uint8Array\n *\n * @param {ClarityValue} value to be converted to bytes\n **\n * @returns {Uint8Array} returns the bytes\n *\n * @example\n * ```\n *  import { intCV, serializeCV } from '@stacks/transactions';\n *\n *  const serialized = serializeCV(intCV(100)); // Similarly works for other clarity types as well like listCV, booleanCV ...\n *\n *  // <Uint8Array 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 64>\n * ```\n *\n * @see\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts | clarity test cases for more examples}\n */\nexport function serializeCV(value: ClarityValue): Uint8Array {\n  switch (value.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return serializeBoolCV(value);\n    case ClarityType.OptionalNone:\n    case ClarityType.OptionalSome:\n      return serializeOptionalCV(value);\n    case ClarityType.Buffer:\n      return serializeBufferCV(value);\n    case ClarityType.UInt:\n      return serializeUIntCV(value);\n    case ClarityType.Int:\n      return serializeIntCV(value);\n    case ClarityType.PrincipalStandard:\n      return serializeStandardPrincipalCV(value);\n    case ClarityType.PrincipalContract:\n      return serializeContractPrincipalCV(value);\n    case ClarityType.ResponseOk:\n    case ClarityType.ResponseErr:\n      return serializeResponseCV(value);\n    case ClarityType.List:\n      return serializeListCV(value);\n    case ClarityType.Tuple:\n      return serializeTupleCV(value);\n    case ClarityType.StringASCII:\n      return serializeStringAsciiCV(value);\n    case ClarityType.StringUTF8:\n      return serializeStringUtf8CV(value);\n    default:\n      throw new SerializationError('Unable to serialize. Invalid Clarity Value.');\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}