{"ast":null,"code":"import { isSingleSig, nextVerification } from './authorization';\nimport { cloneDeep } from './utils';\nimport { AuthType, PubKeyEncoding, StacksMessageType } from './constants';\nimport { SigningError } from './errors';\nexport class TransactionSigner {\n  constructor(transaction) {\n    this.transaction = transaction;\n    this.sigHash = transaction.signBegin();\n    this.originDone = false;\n    this.checkOversign = true;\n    this.checkOverlap = true;\n    const spendingCondition = transaction.auth.spendingCondition;\n    if (spendingCondition && !isSingleSig(spendingCondition)) {\n      if (spendingCondition.fields.filter(field => field.contents.type === StacksMessageType.MessageSignature).length >= spendingCondition.signaturesRequired) {\n        throw new Error('SpendingCondition has more signatures than are expected');\n      }\n      spendingCondition.fields.forEach(field => {\n        if (field.contents.type === StacksMessageType.MessageSignature) {\n          const signature = field.contents;\n          const nextVerify = nextVerification(this.sigHash, transaction.auth.authType, spendingCondition.fee, spendingCondition.nonce, PubKeyEncoding.Compressed, signature);\n          this.sigHash = nextVerify.nextSigHash;\n        }\n      });\n    }\n  }\n  static createSponsorSigner(transaction, spendingCondition) {\n    if (transaction.auth.authType != AuthType.Sponsored) {\n      throw new SigningError('Cannot add sponsor to non-sponsored transaction');\n    }\n    const tx = cloneDeep(transaction);\n    tx.setSponsor(spendingCondition);\n    const originSigHash = tx.verifyOrigin();\n    const signer = new this(tx);\n    signer.originDone = true;\n    signer.sigHash = originSigHash;\n    signer.checkOversign = true;\n    signer.checkOverlap = true;\n    return signer;\n  }\n  signOrigin(privateKey) {\n    if (this.checkOverlap && this.originDone) {\n      throw new SigningError('Cannot sign origin after sponsor key');\n    }\n    if (this.transaction.auth === undefined) {\n      throw new SigningError('\"transaction.auth\" is undefined');\n    }\n    if (this.transaction.auth.spendingCondition === undefined) {\n      throw new SigningError('\"transaction.auth.spendingCondition\" is undefined');\n    }\n    if (!isSingleSig(this.transaction.auth.spendingCondition)) {\n      const spendingCondition = this.transaction.auth.spendingCondition;\n      if (this.checkOversign && spendingCondition.fields.filter(field => field.contents.type === StacksMessageType.MessageSignature).length >= spendingCondition.signaturesRequired) {\n        throw new Error('Origin would have too many signatures');\n      }\n    }\n    const nextSighash = this.transaction.signNextOrigin(this.sigHash, privateKey);\n    this.sigHash = nextSighash;\n  }\n  appendOrigin(publicKey) {\n    if (this.checkOverlap && this.originDone) {\n      throw Error('Cannot append public key to origin after sponsor key');\n    }\n    if (this.transaction.auth === undefined) {\n      throw new Error('\"transaction.auth\" is undefined');\n    }\n    if (this.transaction.auth.spendingCondition === undefined) {\n      throw new Error('\"transaction.auth.spendingCondition\" is undefined');\n    }\n    this.transaction.appendPubkey(publicKey);\n  }\n  signSponsor(privateKey) {\n    if (this.transaction.auth === undefined) {\n      throw new SigningError('\"transaction.auth\" is undefined');\n    }\n    if (this.transaction.auth.authType !== AuthType.Sponsored) {\n      throw new SigningError('\"transaction.auth.authType\" is not AuthType.Sponsored');\n    }\n    const nextSighash = this.transaction.signNextSponsor(this.sigHash, privateKey);\n    this.sigHash = nextSighash;\n    this.originDone = true;\n  }\n  getTxInComplete() {\n    return cloneDeep(this.transaction);\n  }\n  resume(transaction) {\n    this.transaction = cloneDeep(transaction);\n    this.sigHash = transaction.signBegin();\n  }\n}","map":{"version":3,"names":["isSingleSig","nextVerification","cloneDeep","AuthType","PubKeyEncoding","StacksMessageType","SigningError","TransactionSigner","constructor","transaction","sigHash","signBegin","originDone","checkOversign","checkOverlap","spendingCondition","auth","fields","filter","field","contents","type","MessageSignature","length","signaturesRequired","Error","forEach","signature","nextVerify","authType","fee","nonce","Compressed","nextSigHash","createSponsorSigner","Sponsored","tx","setSponsor","originSigHash","verifyOrigin","signer","signOrigin","privateKey","undefined","nextSighash","signNextOrigin","appendOrigin","publicKey","appendPubkey","signSponsor","signNextSponsor","getTxInComplete","resume"],"sources":["C:\\Users\\abasi\\Desktop\\web3-apps\\react-cra\\node_modules\\@stacks\\transactions\\src\\signer.ts"],"sourcesContent":["import { StacksTransaction } from './transaction';\n\nimport { StacksPrivateKey, StacksPublicKey } from './keys';\nimport { isSingleSig, nextVerification, SpendingConditionOpts } from './authorization';\nimport { cloneDeep } from './utils';\nimport { AuthType, PubKeyEncoding, StacksMessageType } from './constants';\nimport { SigningError } from './errors';\n\nexport class TransactionSigner {\n  transaction: StacksTransaction;\n  sigHash: string;\n  originDone: boolean;\n  checkOversign: boolean;\n  checkOverlap: boolean;\n\n  constructor(transaction: StacksTransaction) {\n    this.transaction = transaction;\n    this.sigHash = transaction.signBegin();\n    this.originDone = false;\n    this.checkOversign = true;\n    this.checkOverlap = true;\n\n    // If multi-sig spending condition exists, iterate over\n    // auth fields and reconstruct sigHash\n    const spendingCondition = transaction.auth.spendingCondition;\n    if (spendingCondition && !isSingleSig(spendingCondition)) {\n      if (\n        spendingCondition.fields.filter(\n          field => field.contents.type === StacksMessageType.MessageSignature\n        ).length >= spendingCondition.signaturesRequired\n      ) {\n        throw new Error('SpendingCondition has more signatures than are expected');\n      }\n\n      spendingCondition.fields.forEach(field => {\n        if (field.contents.type === StacksMessageType.MessageSignature) {\n          const signature = field.contents;\n          const nextVerify = nextVerification(\n            this.sigHash,\n            transaction.auth.authType,\n            spendingCondition.fee,\n            spendingCondition.nonce,\n            PubKeyEncoding.Compressed, // always compressed for multisig\n            signature\n          );\n          this.sigHash = nextVerify.nextSigHash;\n        }\n      });\n    }\n  }\n\n  static createSponsorSigner(\n    transaction: StacksTransaction,\n    spendingCondition: SpendingConditionOpts\n  ) {\n    if (transaction.auth.authType != AuthType.Sponsored) {\n      throw new SigningError('Cannot add sponsor to non-sponsored transaction');\n    }\n\n    const tx: StacksTransaction = cloneDeep(transaction);\n    tx.setSponsor(spendingCondition);\n    const originSigHash = tx.verifyOrigin();\n    const signer = new this(tx);\n    signer.originDone = true;\n    signer.sigHash = originSigHash;\n    signer.checkOversign = true;\n    signer.checkOverlap = true;\n    return signer;\n  }\n\n  signOrigin(privateKey: StacksPrivateKey) {\n    if (this.checkOverlap && this.originDone) {\n      throw new SigningError('Cannot sign origin after sponsor key');\n    }\n\n    if (this.transaction.auth === undefined) {\n      throw new SigningError('\"transaction.auth\" is undefined');\n    }\n    if (this.transaction.auth.spendingCondition === undefined) {\n      throw new SigningError('\"transaction.auth.spendingCondition\" is undefined');\n    }\n\n    if (!isSingleSig(this.transaction.auth.spendingCondition)) {\n      const spendingCondition = this.transaction.auth.spendingCondition;\n      if (\n        this.checkOversign &&\n        spendingCondition.fields.filter(\n          field => field.contents.type === StacksMessageType.MessageSignature\n        ).length >= spendingCondition.signaturesRequired\n      ) {\n        throw new Error('Origin would have too many signatures');\n      }\n    }\n\n    const nextSighash = this.transaction.signNextOrigin(this.sigHash, privateKey);\n    this.sigHash = nextSighash;\n  }\n\n  appendOrigin(publicKey: StacksPublicKey) {\n    if (this.checkOverlap && this.originDone) {\n      throw Error('Cannot append public key to origin after sponsor key');\n    }\n\n    if (this.transaction.auth === undefined) {\n      throw new Error('\"transaction.auth\" is undefined');\n    }\n    if (this.transaction.auth.spendingCondition === undefined) {\n      throw new Error('\"transaction.auth.spendingCondition\" is undefined');\n    }\n\n    this.transaction.appendPubkey(publicKey);\n  }\n\n  signSponsor(privateKey: StacksPrivateKey) {\n    if (this.transaction.auth === undefined) {\n      throw new SigningError('\"transaction.auth\" is undefined');\n    }\n    if (this.transaction.auth.authType !== AuthType.Sponsored) {\n      throw new SigningError('\"transaction.auth.authType\" is not AuthType.Sponsored');\n    }\n\n    const nextSighash = this.transaction.signNextSponsor(this.sigHash, privateKey);\n    this.sigHash = nextSighash;\n    this.originDone = true;\n  }\n\n  getTxInComplete(): StacksTransaction {\n    return cloneDeep(this.transaction);\n  }\n\n  resume(transaction: StacksTransaction) {\n    this.transaction = cloneDeep(transaction);\n    this.sigHash = transaction.signBegin();\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}