{"ast":null,"code":"import { bytesToHex, hexToBytes, intToBigInt } from '@stacks/common';\nimport { StacksNetwork, StacksMainnet, StacksTestnet, createFetchFn } from '@stacks/network';\nimport { c32address } from 'c32check';\nimport { createMultiSigSpendingCondition, createSingleSigSpendingCondition, createSponsoredAuth, createStandardAuth } from './authorization';\nimport { deserializeCV, serializeCV } from './clarity';\nimport { AddressHashMode, AddressVersion, PayloadType, PostConditionMode, TransactionVersion, RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, StacksMessageType, ClarityVersion } from './constants';\nimport { validateContractCall } from './contract-abi';\nimport { NoEstimateAvailableError } from './errors';\nimport { createStacksPrivateKey, createStacksPublicKey, getPublicKey, pubKeyfromPrivKey, publicKeyFromBytes, publicKeyToAddress, publicKeyToString } from './keys';\nimport { createContractCallPayload, createSmartContractPayload, createTokenTransferPayload, serializePayload } from './payload';\nimport { createFungiblePostCondition, createNonFungiblePostCondition, createSTXPostCondition } from './postcondition';\nimport { createContractPrincipal, createStandardPrincipal } from './postcondition-types';\nimport { TransactionSigner } from './signer';\nimport { StacksTransaction } from './transaction';\nimport { createLPList } from './types';\nimport { cvToHex, omit, parseReadOnlyResponse, validateTxId } from './utils';\nexport async function getNonce(address, network) {\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network !== null && network !== void 0 ? network : new StacksMainnet());\n  const url = derivedNetwork.getAccountApiUrl(address);\n  const response = await derivedNetwork.fetchFn(url);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(`Error fetching nonce. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n  const responseText = await response.text();\n  const result = JSON.parse(responseText);\n  return BigInt(result.nonce);\n}\nexport async function estimateTransfer(transaction, network) {\n  if (transaction.payload.payloadType !== PayloadType.TokenTransfer) {\n    throw new Error(`Transaction fee estimation only possible with ${PayloadType[PayloadType.TokenTransfer]} transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`);\n  }\n  return estimateTransferUnsafe(transaction, network);\n}\nexport async function estimateTransferUnsafe(transaction, network) {\n  const requestHeaders = {\n    Accept: 'application/text'\n  };\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders\n  };\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network !== null && network !== void 0 ? network : deriveNetwork(transaction));\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(`Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n  const feeRateResult = await response.text();\n  const txBytes = BigInt(transaction.serialize().byteLength);\n  const feeRate = BigInt(feeRateResult);\n  return feeRate * txBytes;\n}\nexport async function estimateTransaction(transactionPayload, estimatedLen, network) {\n  const options = {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      transaction_payload: bytesToHex(serializePayload(transactionPayload)),\n      ...(estimatedLen ? {\n        estimated_len: estimatedLen\n      } : {})\n    })\n  };\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network !== null && network !== void 0 ? network : new StacksMainnet());\n  const url = derivedNetwork.getTransactionFeeEstimateApiUrl();\n  const response = await derivedNetwork.fetchFn(url, options);\n  if (!response.ok) {\n    const body = await response.json().catch(() => ({}));\n    if ((body === null || body === void 0 ? void 0 : body.reason) === 'NoEstimateAvailable') {\n      var _body$reason_data$mes, _body$reason_data;\n      throw new NoEstimateAvailableError((_body$reason_data$mes = body === null || body === void 0 ? void 0 : (_body$reason_data = body.reason_data) === null || _body$reason_data === void 0 ? void 0 : _body$reason_data.message) !== null && _body$reason_data$mes !== void 0 ? _body$reason_data$mes : '');\n    }\n    throw new Error(`Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${body}\"`);\n  }\n  const data = await response.json();\n  return data.estimations;\n}\nexport async function broadcastTransaction(transaction, network, attachment) {\n  const rawTx = transaction.serialize();\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network !== null && network !== void 0 ? network : deriveNetwork(transaction));\n  const url = derivedNetwork.getBroadcastApiUrl();\n  return broadcastRawTransaction(rawTx, url, attachment, derivedNetwork.fetchFn);\n}\nexport async function broadcastRawTransaction(rawTx, url, attachment) {\n  let fetchFn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : createFetchFn();\n  const options = {\n    method: 'POST',\n    headers: {\n      'Content-Type': attachment ? 'application/json' : 'application/octet-stream'\n    },\n    body: attachment ? JSON.stringify({\n      tx: bytesToHex(rawTx),\n      attachment: bytesToHex(attachment)\n    }) : rawTx\n  };\n  const response = await fetchFn(url, options);\n  if (!response.ok) {\n    try {\n      return await response.json();\n    } catch (e) {\n      throw Error(`Failed to broadcast transaction: ${e.message}`);\n    }\n  }\n  const text = await response.text();\n  const txid = text.replace(/[\"]+/g, '');\n  if (!validateTxId(txid)) throw new Error(text);\n  return {\n    txid\n  };\n}\nexport async function getAbi(address, contractName, network) {\n  const options = {\n    method: 'GET'\n  };\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network);\n  const url = derivedNetwork.getAbiApiUrl(address, contractName);\n  const response = await derivedNetwork.fetchFn(url, options);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(`Error fetching contract ABI for contract \"${contractName}\" at address ${address}. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n  return JSON.parse(await response.text());\n}\nfunction deriveNetwork(transaction) {\n  switch (transaction.version) {\n    case TransactionVersion.Mainnet:\n      return new StacksMainnet();\n    case TransactionVersion.Testnet:\n      return new StacksTestnet();\n  }\n}\nexport async function makeUnsignedSTXTokenTransfer(txOptions) {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    postConditionMode: PostConditionMode.Deny,\n    memo: '',\n    sponsored: false\n  };\n  const options = Object.assign(defaultOptions, txOptions);\n  const payload = createTokenTransferPayload(options.recipient, options.amount, options.memo);\n  let authorization = null;\n  let spendingCondition = null;\n  if ('publicKey' in options) {\n    spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);\n  } else {\n    spendingCondition = createMultiSigSpendingCondition(AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);\n  }\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const postConditions = [];\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n  const lpPostConditions = createLPList(postConditions);\n  const transaction = new StacksTransaction(network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, network.chainId);\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const fee = await estimateTransactionFeeWithFallback(transaction, network);\n    transaction.setFee(fee);\n  }\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion = options.network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition.signer);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n  return transaction;\n}\nexport async function makeSTXTokenTransfer(txOptions) {\n  if ('senderKey' in txOptions) {\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedSTXTokenTransfer({\n      publicKey,\n      ...options\n    });\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n    return transaction;\n  } else {\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedSTXTokenTransfer(options);\n    const signer = new TransactionSigner(transaction);\n    let pubKeys = txOptions.publicKeys;\n    for (const key of txOptions.signerKeys) {\n      const pubKey = pubKeyfromPrivKey(key);\n      pubKeys = pubKeys.filter(pk => pk !== bytesToHex(pubKey.data));\n      signer.signOrigin(createStacksPrivateKey(key));\n    }\n    for (const key of pubKeys) {\n      signer.appendOrigin(publicKeyFromBytes(hexToBytes(key)));\n    }\n    return transaction;\n  }\n}\nexport async function estimateContractDeploy(transaction, network) {\n  if (transaction.payload.payloadType !== PayloadType.SmartContract && transaction.payload.payloadType !== PayloadType.VersionedSmartContract) {\n    throw new Error(`Contract deploy fee estimation only possible with ${PayloadType[PayloadType.SmartContract]} transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`);\n  }\n  const requestHeaders = {\n    Accept: 'application/text'\n  };\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders\n  };\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network !== null && network !== void 0 ? network : deriveNetwork(transaction));\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(`Error estimating contract deploy fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n  const feeRateResult = await response.text();\n  const txBytes = intToBigInt(transaction.serialize().byteLength, false);\n  const feeRate = intToBigInt(feeRateResult, false);\n  return feeRate * txBytes;\n}\nexport async function makeContractDeploy(txOptions) {\n  const privKey = createStacksPrivateKey(txOptions.senderKey);\n  const stacksPublicKey = getPublicKey(privKey);\n  const publicKey = publicKeyToString(stacksPublicKey);\n  const unsignedTxOptions = {\n    ...txOptions,\n    publicKey\n  };\n  const transaction = await makeUnsignedContractDeploy(unsignedTxOptions);\n  if (txOptions.senderKey) {\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n  }\n  return transaction;\n}\nexport async function makeUnsignedContractDeploy(txOptions) {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    postConditionMode: PostConditionMode.Deny,\n    sponsored: false,\n    clarityVersion: ClarityVersion.Clarity2\n  };\n  const options = Object.assign(defaultOptions, txOptions);\n  const payload = createSmartContractPayload(options.contractName, options.codeBody, options.clarityVersion);\n  const addressHashMode = AddressHashMode.SerializeP2PKH;\n  const pubKey = createStacksPublicKey(options.publicKey);\n  let authorization = null;\n  const spendingCondition = createSingleSigSpendingCondition(addressHashMode, publicKeyToString(pubKey), options.nonce, options.fee);\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const postConditions = [];\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n  const lpPostConditions = createLPList(postConditions);\n  const transaction = new StacksTransaction(network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, network.chainId);\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const fee = await estimateTransactionFeeWithFallback(transaction, network);\n    transaction.setFee(fee);\n  }\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion = options.network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;\n    const senderAddress = publicKeyToAddress(addressVersion, pubKey);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n  return transaction;\n}\nexport async function estimateContractFunctionCall(transaction, network) {\n  if (transaction.payload.payloadType !== PayloadType.ContractCall) {\n    throw new Error(`Contract call fee estimation only possible with ${PayloadType[PayloadType.ContractCall]} transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`);\n  }\n  const requestHeaders = {\n    Accept: 'application/text'\n  };\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders\n  };\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network !== null && network !== void 0 ? network : deriveNetwork(transaction));\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(`Error estimating contract call fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n  const feeRateResult = await response.text();\n  const txBytes = intToBigInt(transaction.serialize().byteLength, false);\n  const feeRate = intToBigInt(feeRateResult, false);\n  return feeRate * txBytes;\n}\nexport async function makeUnsignedContractCall(txOptions) {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    postConditionMode: PostConditionMode.Deny,\n    sponsored: false\n  };\n  const options = Object.assign(defaultOptions, txOptions);\n  const payload = createContractCallPayload(options.contractAddress, options.contractName, options.functionName, options.functionArgs);\n  if (options !== null && options !== void 0 && options.validateWithAbi) {\n    let abi;\n    if (typeof options.validateWithAbi === 'boolean') {\n      if (options !== null && options !== void 0 && options.network) {\n        abi = await getAbi(options.contractAddress, options.contractName, options.network);\n      } else {\n        throw new Error('Network option must be provided in order to validate with ABI');\n      }\n    } else {\n      abi = options.validateWithAbi;\n    }\n    validateContractCall(payload, abi);\n  }\n  let spendingCondition = null;\n  let authorization = null;\n  if ('publicKey' in options) {\n    spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);\n  } else {\n    spendingCondition = createMultiSigSpendingCondition(AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);\n  }\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const postConditions = [];\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n  const lpPostConditions = createLPList(postConditions);\n  const transaction = new StacksTransaction(network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, network.chainId);\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const fee = await estimateTransactionFeeWithFallback(transaction, network);\n    transaction.setFee(fee);\n  }\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion = network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition.signer);\n    const txNonce = await getNonce(senderAddress, network);\n    transaction.setNonce(txNonce);\n  }\n  return transaction;\n}\nexport async function makeContractCall(txOptions) {\n  if ('senderKey' in txOptions) {\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedContractCall({\n      publicKey,\n      ...options\n    });\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n    return transaction;\n  } else {\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedContractCall(options);\n    const signer = new TransactionSigner(transaction);\n    let pubKeys = txOptions.publicKeys;\n    for (const key of txOptions.signerKeys) {\n      const pubKey = pubKeyfromPrivKey(key);\n      pubKeys = pubKeys.filter(pk => pk !== bytesToHex(pubKey.data));\n      signer.signOrigin(createStacksPrivateKey(key));\n    }\n    for (const key of pubKeys) {\n      signer.appendOrigin(publicKeyFromBytes(hexToBytes(key)));\n    }\n    return transaction;\n  }\n}\nexport function makeStandardSTXPostCondition(address, conditionCode, amount) {\n  return createSTXPostCondition(createStandardPrincipal(address), conditionCode, amount);\n}\nexport function makeContractSTXPostCondition(address, contractName, conditionCode, amount) {\n  return createSTXPostCondition(createContractPrincipal(address, contractName), conditionCode, amount);\n}\nexport function makeStandardFungiblePostCondition(address, conditionCode, amount, assetInfo) {\n  return createFungiblePostCondition(createStandardPrincipal(address), conditionCode, amount, assetInfo);\n}\nexport function makeContractFungiblePostCondition(address, contractName, conditionCode, amount, assetInfo) {\n  return createFungiblePostCondition(createContractPrincipal(address, contractName), conditionCode, amount, assetInfo);\n}\nexport function makeStandardNonFungiblePostCondition(address, conditionCode, assetInfo, assetId) {\n  return createNonFungiblePostCondition(createStandardPrincipal(address), conditionCode, assetInfo, assetId);\n}\nexport function makeContractNonFungiblePostCondition(address, contractName, conditionCode, assetInfo, assetId) {\n  return createNonFungiblePostCondition(createContractPrincipal(address, contractName), conditionCode, assetInfo, assetId);\n}\nexport async function callReadOnlyFunction(readOnlyFunctionOptions) {\n  const defaultOptions = {\n    network: new StacksMainnet()\n  };\n  const options = Object.assign(defaultOptions, readOnlyFunctionOptions);\n  const {\n    contractName,\n    contractAddress,\n    functionName,\n    functionArgs,\n    senderAddress\n  } = options;\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const url = network.getReadOnlyFunctionCallApiUrl(contractAddress, contractName, functionName);\n  const args = functionArgs.map(arg => cvToHex(arg));\n  const body = JSON.stringify({\n    sender: senderAddress,\n    arguments: args\n  });\n  const response = await network.fetchFn(url, {\n    method: 'POST',\n    body,\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  });\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(`Error calling read-only function. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n  return response.json().then(responseJson => parseReadOnlyResponse(responseJson));\n}\nexport async function getContractMapEntry(getContractMapEntryOptions) {\n  const defaultOptions = {\n    network: new StacksMainnet()\n  };\n  const {\n    contractAddress,\n    contractName,\n    mapName,\n    mapKey,\n    network\n  } = Object.assign(defaultOptions, getContractMapEntryOptions);\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network);\n  const url = derivedNetwork.getMapEntryUrl(contractAddress, contractName, mapName);\n  const serializedKeyBytes = serializeCV(mapKey);\n  const serializedKeyHex = '0x' + bytesToHex(serializedKeyBytes);\n  const fetchOptions = {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      Accept: 'application/json'\n    },\n    body: JSON.stringify(serializedKeyHex)\n  };\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(`Error fetching map entry for map \"${mapName}\" in contract \"${contractName}\" at address ${contractAddress}, using map key \"${serializedKeyHex}\". Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n  const responseBody = await response.text();\n  const responseJson = JSON.parse(responseBody);\n  if (!responseJson.data) {\n    throw new Error(`Error fetching map entry for map \"${mapName}\" in contract \"${contractName}\" at address ${contractAddress}, using map key \"${serializedKeyHex}\". Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the response: \"${responseBody}\"`);\n  }\n  let deserializedCv;\n  try {\n    deserializedCv = deserializeCV(responseJson.data);\n  } catch (error) {\n    throw new Error(`Error deserializing Clarity value \"${responseJson.data}\": ${error}`);\n  }\n  return deserializedCv;\n}\nexport async function sponsorTransaction(sponsorOptions) {\n  const defaultOptions = {\n    fee: 0,\n    sponsorNonce: 0,\n    sponsorAddressHashmode: AddressHashMode.SerializeP2PKH,\n    network: sponsorOptions.transaction.version === TransactionVersion.Mainnet ? new StacksMainnet() : new StacksTestnet()\n  };\n  const options = Object.assign(defaultOptions, sponsorOptions);\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const sponsorPubKey = pubKeyfromPrivKey(options.sponsorPrivateKey);\n  if (sponsorOptions.fee === undefined || sponsorOptions.fee === null) {\n    let txFee = 0;\n    switch (options.transaction.payload.payloadType) {\n      case PayloadType.TokenTransfer:\n      case PayloadType.SmartContract:\n      case PayloadType.VersionedSmartContract:\n      case PayloadType.ContractCall:\n        const estimatedLen = estimateTransactionByteLength(options.transaction);\n        try {\n          txFee = (await estimateTransaction(options.transaction.payload, estimatedLen, network))[1].fee;\n        } catch (e) {\n          throw e;\n        }\n        break;\n      default:\n        throw new Error(`Sponsored transactions not supported for transaction type ${PayloadType[options.transaction.payload.payloadType]}`);\n    }\n    options.transaction.setFee(txFee);\n    options.fee = txFee;\n  }\n  if (sponsorOptions.sponsorNonce === undefined || sponsorOptions.sponsorNonce === null) {\n    const addressVersion = network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;\n    const senderAddress = publicKeyToAddress(addressVersion, sponsorPubKey);\n    const sponsorNonce = await getNonce(senderAddress, network);\n    options.sponsorNonce = sponsorNonce;\n  }\n  const sponsorSpendingCondition = createSingleSigSpendingCondition(options.sponsorAddressHashmode, publicKeyToString(sponsorPubKey), options.sponsorNonce, options.fee);\n  options.transaction.setSponsor(sponsorSpendingCondition);\n  const privKey = createStacksPrivateKey(options.sponsorPrivateKey);\n  const signer = TransactionSigner.createSponsorSigner(options.transaction, sponsorSpendingCondition);\n  signer.signSponsor(privKey);\n  return signer.transaction;\n}\nexport function estimateTransactionByteLength(transaction) {\n  const hashMode = transaction.auth.spendingCondition.hashMode;\n  const multiSigHashModes = [AddressHashMode.SerializeP2SH, AddressHashMode.SerializeP2WSH];\n  if (multiSigHashModes.includes(hashMode)) {\n    const multiSigSpendingCondition = transaction.auth.spendingCondition;\n    const existingSignatures = multiSigSpendingCondition.fields.filter(field => field.contents.type === StacksMessageType.MessageSignature).length;\n    const totalSignatureLength = (multiSigSpendingCondition.signaturesRequired - existingSignatures) * (RECOVERABLE_ECDSA_SIG_LENGTH_BYTES + 1);\n    return transaction.serialize().byteLength + totalSignatureLength;\n  } else {\n    return transaction.serialize().byteLength;\n  }\n}\nexport async function estimateTransactionFeeWithFallback(transaction, network) {\n  try {\n    const estimatedLen = estimateTransactionByteLength(transaction);\n    return (await estimateTransaction(transaction.payload, estimatedLen, network))[1].fee;\n  } catch (error) {\n    if (error instanceof NoEstimateAvailableError) {\n      return await estimateTransferUnsafe(transaction, network);\n    }\n    throw error;\n  }\n}","map":{"version":3,"names":["bytesToHex","hexToBytes","intToBigInt","StacksNetwork","StacksMainnet","StacksTestnet","createFetchFn","c32address","createMultiSigSpendingCondition","createSingleSigSpendingCondition","createSponsoredAuth","createStandardAuth","deserializeCV","serializeCV","AddressHashMode","AddressVersion","PayloadType","PostConditionMode","TransactionVersion","RECOVERABLE_ECDSA_SIG_LENGTH_BYTES","StacksMessageType","ClarityVersion","validateContractCall","NoEstimateAvailableError","createStacksPrivateKey","createStacksPublicKey","getPublicKey","pubKeyfromPrivKey","publicKeyFromBytes","publicKeyToAddress","publicKeyToString","createContractCallPayload","createSmartContractPayload","createTokenTransferPayload","serializePayload","createFungiblePostCondition","createNonFungiblePostCondition","createSTXPostCondition","createContractPrincipal","createStandardPrincipal","TransactionSigner","StacksTransaction","createLPList","cvToHex","omit","parseReadOnlyResponse","validateTxId","getNonce","address","network","derivedNetwork","fromNameOrNetwork","url","getAccountApiUrl","response","fetchFn","ok","msg","text","error","Error","status","statusText","responseText","result","JSON","parse","BigInt","nonce","estimateTransfer","transaction","payload","payloadType","TokenTransfer","estimateTransferUnsafe","requestHeaders","Accept","fetchOptions","method","headers","deriveNetwork","getTransferFeeEstimateApiUrl","feeRateResult","txBytes","serialize","byteLength","feeRate","estimateTransaction","transactionPayload","estimatedLen","options","body","stringify","transaction_payload","estimated_len","getTransactionFeeEstimateApiUrl","json","catch","reason","_body$reason_data$mes","_body$reason_data","reason_data","message","data","estimations","broadcastTransaction","attachment","rawTx","getBroadcastApiUrl","broadcastRawTransaction","arguments","length","undefined","tx","e","txid","replace","getAbi","contractName","getAbiApiUrl","version","Mainnet","Testnet","makeUnsignedSTXTokenTransfer","txOptions","defaultOptions","fee","postConditionMode","Deny","memo","sponsored","Object","assign","recipient","amount","authorization","spendingCondition","SerializeP2PKH","publicKey","SerializeP2SH","numSignatures","publicKeys","postConditions","forEach","postCondition","push","lpPostConditions","anchorMode","chainId","estimateTransactionFeeWithFallback","setFee","addressVersion","MainnetSingleSig","TestnetSingleSig","senderAddress","auth","signer","txNonce","setNonce","makeSTXTokenTransfer","senderKey","privKey","signOrigin","pubKeys","key","signerKeys","pubKey","filter","pk","appendOrigin","estimateContractDeploy","SmartContract","VersionedSmartContract","makeContractDeploy","stacksPublicKey","unsignedTxOptions","makeUnsignedContractDeploy","clarityVersion","Clarity2","codeBody","addressHashMode","estimateContractFunctionCall","ContractCall","makeUnsignedContractCall","contractAddress","functionName","functionArgs","validateWithAbi","abi","makeContractCall","makeStandardSTXPostCondition","conditionCode","makeContractSTXPostCondition","makeStandardFungiblePostCondition","assetInfo","makeContractFungiblePostCondition","makeStandardNonFungiblePostCondition","assetId","makeContractNonFungiblePostCondition","callReadOnlyFunction","readOnlyFunctionOptions","getReadOnlyFunctionCallApiUrl","args","map","arg","sender","then","responseJson","getContractMapEntry","getContractMapEntryOptions","mapName","mapKey","getMapEntryUrl","serializedKeyBytes","serializedKeyHex","responseBody","deserializedCv","sponsorTransaction","sponsorOptions","sponsorNonce","sponsorAddressHashmode","sponsorPubKey","sponsorPrivateKey","txFee","estimateTransactionByteLength","sponsorSpendingCondition","setSponsor","createSponsorSigner","signSponsor","hashMode","multiSigHashModes","SerializeP2WSH","includes","multiSigSpendingCondition","existingSignatures","fields","field","contents","type","MessageSignature","totalSignatureLength","signaturesRequired"],"sources":["C:\\Users\\abasi\\Desktop\\web3-apps\\react-cra\\node_modules\\@stacks\\transactions\\src\\builders.ts"],"sourcesContent":["import { bytesToHex, hexToBytes, IntegerType, intToBigInt } from '@stacks/common';\nimport {\n  StacksNetwork,\n  StacksMainnet,\n  StacksNetworkName,\n  StacksTestnet,\n  FetchFn,\n  createFetchFn,\n} from '@stacks/network';\nimport { c32address } from 'c32check';\nimport {\n  Authorization,\n  createMultiSigSpendingCondition,\n  createSingleSigSpendingCondition,\n  createSponsoredAuth,\n  createStandardAuth,\n  SpendingCondition,\n  MultiSigSpendingCondition,\n} from './authorization';\nimport { ClarityValue, deserializeCV, NoneCV, PrincipalCV, serializeCV } from './clarity';\nimport {\n  AddressHashMode,\n  AddressVersion,\n  AnchorMode,\n  FungibleConditionCode,\n  NonFungibleConditionCode,\n  PayloadType,\n  PostConditionMode,\n  SingleSigHashMode,\n  TransactionVersion,\n  TxRejectedReason,\n  RECOVERABLE_ECDSA_SIG_LENGTH_BYTES,\n  StacksMessageType,\n  ClarityVersion,\n  AnchorModeName,\n} from './constants';\nimport { ClarityAbi, validateContractCall } from './contract-abi';\nimport { NoEstimateAvailableError } from './errors';\nimport {\n  createStacksPrivateKey,\n  createStacksPublicKey,\n  getPublicKey,\n  pubKeyfromPrivKey,\n  publicKeyFromBytes,\n  publicKeyToAddress,\n  publicKeyToString,\n} from './keys';\nimport {\n  createContractCallPayload,\n  createSmartContractPayload,\n  createTokenTransferPayload,\n  Payload,\n  serializePayload,\n} from './payload';\nimport {\n  createFungiblePostCondition,\n  createNonFungiblePostCondition,\n  createSTXPostCondition,\n} from './postcondition';\nimport {\n  AssetInfo,\n  createContractPrincipal,\n  createStandardPrincipal,\n  FungiblePostCondition,\n  NonFungiblePostCondition,\n  PostCondition,\n  STXPostCondition,\n} from './postcondition-types';\nimport { TransactionSigner } from './signer';\nimport { StacksTransaction } from './transaction';\nimport { createLPList } from './types';\nimport { cvToHex, omit, parseReadOnlyResponse, validateTxId } from './utils';\n\n/**\n * Lookup the nonce for an address from a core node\n *\n * @param {string} address - the c32check address to look up\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to look up address on\n *\n * @return a promise that resolves to an integer\n */\nexport async function getNonce(\n  address: string,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<bigint> {\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? new StacksMainnet());\n  const url = derivedNetwork.getAccountApiUrl(address);\n\n  const response = await derivedNetwork.fetchFn(url);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error fetching nonce. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const responseText = await response.text();\n  const result = JSON.parse(responseText) as { nonce: string };\n  return BigInt(result.nonce);\n}\n\n/**\n * @deprecated Use the new {@link estimateTransaction} function instead.\n *\n * Estimate the total transaction fee in microstacks for a token transfer\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to estimate transaction for\n *\n * @return a promise that resolves to number of microstacks per byte\n */\nexport async function estimateTransfer(\n  transaction: StacksTransaction,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<bigint> {\n  if (transaction.payload.payloadType !== PayloadType.TokenTransfer) {\n    throw new Error(\n      `Transaction fee estimation only possible with ${\n        PayloadType[PayloadType.TokenTransfer]\n      } transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`\n    );\n  }\n\n  return estimateTransferUnsafe(transaction, network);\n}\n\n/**\n * @deprecated Use the new {@link estimateTransaction} function instead.\n * @internal\n */\nexport async function estimateTransferUnsafe(\n  transaction: StacksTransaction,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<bigint> {\n  const requestHeaders = {\n    Accept: 'application/text',\n  };\n\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders,\n  };\n\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\n\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const feeRateResult = await response.text();\n  const txBytes = BigInt(transaction.serialize().byteLength);\n  const feeRate = BigInt(feeRateResult);\n  return feeRate * txBytes;\n}\n\ninterface FeeEstimation {\n  fee: number;\n  fee_rate: number;\n}\ninterface FeeEstimateResponse {\n  cost_scalar_change_by_byte: bigint;\n  estimated_cost: {\n    read_count: bigint;\n    read_length: bigint;\n    runtime: bigint;\n    write_count: bigint;\n    write_length: bigint;\n  };\n  estimated_cost_scalar: bigint;\n  estimations: [FeeEstimation, FeeEstimation, FeeEstimation];\n}\n\n/**\n * Estimate the total transaction fee in microstacks for a Stacks transaction\n *\n * @param {StacksTransaction} transaction - the transaction to estimate fees for\n * @param {number} estimatedLen - is an optional argument that provides the endpoint with an\n * estimation of the final length (in bytes) of the transaction, including any post-conditions\n * and signatures\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to estimate transaction fees for\n *\n * @return a promise that resolves to FeeEstimate\n */\nexport async function estimateTransaction(\n  transactionPayload: Payload,\n  estimatedLen?: number,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<[FeeEstimation, FeeEstimation, FeeEstimation]> {\n  const options = {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      transaction_payload: bytesToHex(serializePayload(transactionPayload)),\n      ...(estimatedLen ? { estimated_len: estimatedLen } : {}),\n    }),\n  };\n\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? new StacksMainnet());\n  const url = derivedNetwork.getTransactionFeeEstimateApiUrl();\n\n  const response = await derivedNetwork.fetchFn(url, options);\n\n  if (!response.ok) {\n    const body = await response.json().catch(() => ({}));\n\n    if (body?.reason === 'NoEstimateAvailable') {\n      throw new NoEstimateAvailableError(body?.reason_data?.message ?? '');\n    }\n\n    throw new Error(\n      `Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${body}\"`\n    );\n  }\n\n  const data: FeeEstimateResponse = await response.json();\n  return data.estimations;\n}\n\nexport type SerializationRejection = {\n  error: string;\n  reason: TxRejectedReason.Serialization;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type DeserializationRejection = {\n  error: string;\n  reason: TxRejectedReason.Deserialization;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type SignatureValidationRejection = {\n  error: string;\n  reason: TxRejectedReason.SignatureValidation;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type BadNonceRejection = {\n  error: string;\n  reason: TxRejectedReason.BadNonce;\n  reason_data: {\n    expected: number;\n    actual: number;\n    is_origin: boolean;\n    principal: boolean;\n  };\n  txid: string;\n};\n\nexport type FeeTooLowRejection = {\n  error: string;\n  reason: TxRejectedReason.FeeTooLow;\n  reason_data: {\n    expected: number;\n    actual: number;\n  };\n  txid: string;\n};\n\nexport type NotEnoughFundsRejection = {\n  error: string;\n  reason: TxRejectedReason.NotEnoughFunds;\n  reason_data: {\n    expected: string;\n    actual: string;\n  };\n  txid: string;\n};\n\nexport type NoSuchContractRejection = {\n  error: string;\n  reason: TxRejectedReason.NoSuchContract;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type NoSuchPublicFunctionRejection = {\n  error: string;\n  reason: TxRejectedReason.NoSuchPublicFunction;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type BadFunctionArgumentRejection = {\n  error: string;\n  reason: TxRejectedReason.BadFunctionArgument;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type ContractAlreadyExistsRejection = {\n  error: string;\n  reason: TxRejectedReason.ContractAlreadyExists;\n  reason_data: {\n    contract_identifier: string;\n  };\n  txid: string;\n};\n\nexport type PoisonMicroblocksDoNotConflictRejection = {\n  error: string;\n  reason: TxRejectedReason.PoisonMicroblocksDoNotConflict;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type PoisonMicroblockHasUnknownPubKeyHashRejection = {\n  error: string;\n  reason: TxRejectedReason.PoisonMicroblockHasUnknownPubKeyHash;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type PoisonMicroblockIsInvalidRejection = {\n  error: string;\n  reason: TxRejectedReason.PoisonMicroblockIsInvalid;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type BadAddressVersionByteRejection = {\n  error: string;\n  reason: TxRejectedReason.BadAddressVersionByte;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type NoCoinbaseViaMempoolRejection = {\n  error: string;\n  reason: TxRejectedReason.NoCoinbaseViaMempool;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type ServerFailureNoSuchChainTipRejection = {\n  error: string;\n  reason: TxRejectedReason.ServerFailureNoSuchChainTip;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type ServerFailureDatabaseRejection = {\n  error: string;\n  reason: TxRejectedReason.ServerFailureDatabase;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type ServerFailureOtherRejection = {\n  error: string;\n  reason: TxRejectedReason.ServerFailureOther;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type TxBroadcastResultOk = {\n  txid: string;\n  error?: undefined;\n  reason?: undefined;\n  reason_data?: undefined;\n};\n\nexport type TxBroadcastResultRejected =\n  | SerializationRejection\n  | DeserializationRejection\n  | SignatureValidationRejection\n  | BadNonceRejection\n  | FeeTooLowRejection\n  | NotEnoughFundsRejection\n  | NoSuchContractRejection\n  | NoSuchPublicFunctionRejection\n  | BadFunctionArgumentRejection\n  | ContractAlreadyExistsRejection\n  | PoisonMicroblocksDoNotConflictRejection\n  | PoisonMicroblockHasUnknownPubKeyHashRejection\n  | PoisonMicroblockIsInvalidRejection\n  | BadAddressVersionByteRejection\n  | NoCoinbaseViaMempoolRejection\n  | ServerFailureNoSuchChainTipRejection\n  | ServerFailureDatabaseRejection\n  | ServerFailureOtherRejection;\n\nexport type TxBroadcastResult = TxBroadcastResultOk | TxBroadcastResultRejected;\n\n/**\n * Broadcast the signed transaction to a core node\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to broadcast\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to broadcast transaction to\n *\n * @returns {Promise} that resolves to a response if the operation succeeds\n */\nexport async function broadcastTransaction(\n  transaction: StacksTransaction,\n  network?: StacksNetworkName | StacksNetwork,\n  attachment?: Uint8Array\n): Promise<TxBroadcastResult> {\n  const rawTx = transaction.serialize();\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getBroadcastApiUrl();\n\n  return broadcastRawTransaction(rawTx, url, attachment, derivedNetwork.fetchFn);\n}\n\n/**\n * Broadcast the signed transaction to a core node\n *\n * @param {Uint8Array} rawTx - the raw serialized transaction bytes to broadcast\n * @param {string} url - the broadcast endpoint URL\n *\n * @returns {Promise} that resolves to a response if the operation succeeds\n */\nexport async function broadcastRawTransaction(\n  rawTx: Uint8Array,\n  url: string,\n  attachment?: Uint8Array,\n  fetchFn: FetchFn = createFetchFn()\n): Promise<TxBroadcastResult> {\n  const options = {\n    method: 'POST',\n    headers: { 'Content-Type': attachment ? 'application/json' : 'application/octet-stream' },\n    body: attachment\n      ? JSON.stringify({\n          tx: bytesToHex(rawTx),\n          attachment: bytesToHex(attachment),\n        })\n      : rawTx,\n  };\n\n  const response = await fetchFn(url, options);\n  if (!response.ok) {\n    try {\n      return (await response.json()) as TxBroadcastResult;\n    } catch (e) {\n      throw Error(`Failed to broadcast transaction: ${(e as Error).message}`);\n    }\n  }\n\n  const text = await response.text();\n  // Replace extra quotes around txid string\n  const txid = text.replace(/[\"]+/g, '');\n  if (!validateTxId(txid)) throw new Error(text);\n  return { txid } as TxBroadcastResult;\n}\n\n/**\n * Fetch a contract's ABI\n *\n * @param {string} address - the contracts address\n * @param {string} contractName - the contracts name\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to broadcast transaction to\n *\n * @returns {Promise} that resolves to a ClarityAbi if the operation succeeds\n */\nexport async function getAbi(\n  address: string,\n  contractName: string,\n  network: StacksNetworkName | StacksNetwork\n): Promise<ClarityAbi> {\n  const options = {\n    method: 'GET',\n  };\n\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network);\n  const url = derivedNetwork.getAbiApiUrl(address, contractName);\n\n  const response = await derivedNetwork.fetchFn(url, options);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(\n      `Error fetching contract ABI for contract \"${contractName}\" at address ${address}. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n\n  return JSON.parse(await response.text()) as ClarityAbi;\n}\n\nfunction deriveNetwork(transaction: StacksTransaction) {\n  switch (transaction.version) {\n    case TransactionVersion.Mainnet:\n      return new StacksMainnet();\n    case TransactionVersion.Testnet:\n      return new StacksTestnet();\n  }\n}\n\nexport interface MultiSigOptions {\n  numSignatures: number;\n  publicKeys: string[];\n  signerKeys?: string[];\n}\n\n/**\n * STX token transfer transaction options\n */\nexport interface TokenTransferOptions {\n  /** the address of the recipient of the token transfer */\n  recipient: string | PrincipalCV;\n  /** the amount to be transfered in microstacks */\n  amount: IntegerType;\n  /** the transaction fee in microstacks */\n  fee?: IntegerType;\n  /** the transaction nonce, which must be increased monotonically with each new transaction */\n  nonce?: IntegerType;\n  /** the network that the transaction will ultimately be broadcast to */\n  network?: StacksNetworkName | StacksNetwork;\n  /** the transaction anchorMode, which specifies whether it should be\n   * included in an anchor block or a microblock */\n  anchorMode: AnchorModeName | AnchorMode;\n  /** an arbitrary string to include in the transaction, must be less than 34 bytes */\n  memo?: string;\n  /** the post condition mode, specifying whether or not post-conditions must fully cover all\n   * transfered assets */\n  postConditionMode?: PostConditionMode;\n  /** a list of post conditions to add to the transaction */\n  postConditions?: PostCondition[];\n  /** set to true if another account is sponsoring the transaction (covering the transaction fee) */\n  sponsored?: boolean;\n}\n\nexport interface UnsignedTokenTransferOptions extends TokenTransferOptions {\n  publicKey: string;\n}\n\nexport interface SignedTokenTransferOptions extends TokenTransferOptions {\n  senderKey: string;\n}\n\nexport interface UnsignedMultiSigTokenTransferOptions extends TokenTransferOptions {\n  numSignatures: number;\n  publicKeys: string[];\n}\n\nexport interface SignedMultiSigTokenTransferOptions extends TokenTransferOptions {\n  numSignatures: number;\n  publicKeys: string[];\n  signerKeys: string[];\n}\n\n/**\n * Generates an unsigned Stacks token transfer transaction\n *\n * Returns a Stacks token transfer transaction.\n *\n * @param {UnsignedTokenTransferOptions | UnsignedMultiSigTokenTransferOptions} txOptions - an options object for the token transfer\n *\n * @return {Promise<StacksTransaction>}\n */\nexport async function makeUnsignedSTXTokenTransfer(\n  txOptions: UnsignedTokenTransferOptions | UnsignedMultiSigTokenTransferOptions\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    postConditionMode: PostConditionMode.Deny,\n    memo: '',\n    sponsored: false,\n  };\n\n  const options = Object.assign(defaultOptions, txOptions);\n\n  const payload = createTokenTransferPayload(options.recipient, options.amount, options.memo);\n\n  let authorization: Authorization | null = null;\n  let spendingCondition: SpendingCondition | null = null;\n\n  if ('publicKey' in options) {\n    // single-sig\n    spendingCondition = createSingleSigSpendingCondition(\n      AddressHashMode.SerializeP2PKH,\n      options.publicKey,\n      options.nonce,\n      options.fee\n    );\n  } else {\n    // multi-sig\n    spendingCondition = createMultiSigSpendingCondition(\n      AddressHashMode.SerializeP2SH,\n      options.numSignatures,\n      options.publicKeys,\n      options.nonce,\n      options.fee\n    );\n  }\n\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n\n  const postConditions: PostCondition[] = [];\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n  const lpPostConditions = createLPList(postConditions);\n\n  const transaction = new StacksTransaction(\n    network.version,\n    authorization,\n    payload,\n    lpPostConditions,\n    options.postConditionMode,\n    options.anchorMode,\n    network.chainId\n  );\n\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const fee = await estimateTransactionFeeWithFallback(transaction, network);\n    transaction.setFee(fee);\n  }\n\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion =\n      options.network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition!.signer);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\n\n/**\n * Generates a signed Stacks token transfer transaction\n *\n * Returns a signed Stacks token transfer transaction.\n *\n * @param {SignedTokenTransferOptions | SignedMultiSigTokenTransferOptions} txOptions - an options object for the token transfer\n *\n * @return {StacksTransaction}\n */\nexport async function makeSTXTokenTransfer(\n  txOptions: SignedTokenTransferOptions | SignedMultiSigTokenTransferOptions\n): Promise<StacksTransaction> {\n  if ('senderKey' in txOptions) {\n    // txOptions is SignedTokenTransferOptions\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedSTXTokenTransfer({ publicKey, ...options });\n\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n\n    return transaction;\n  } else {\n    // txOptions is SignedMultiSigTokenTransferOptions\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedSTXTokenTransfer(options);\n\n    const signer = new TransactionSigner(transaction);\n    let pubKeys = txOptions.publicKeys;\n    for (const key of txOptions.signerKeys) {\n      const pubKey = pubKeyfromPrivKey(key);\n      pubKeys = pubKeys.filter(pk => pk !== bytesToHex(pubKey.data));\n      signer.signOrigin(createStacksPrivateKey(key));\n    }\n\n    for (const key of pubKeys) {\n      signer.appendOrigin(publicKeyFromBytes(hexToBytes(key)));\n    }\n\n    return transaction;\n  }\n}\n\n/**\n * Contract deploy transaction options\n */\nexport interface BaseContractDeployOptions {\n  clarityVersion?: ClarityVersion;\n  contractName: string;\n  /** the Clarity code to be deployed */\n  codeBody: string;\n  /** transaction fee in microstacks */\n  fee?: IntegerType;\n  /** the transaction nonce, which must be increased monotonically with each new transaction */\n  nonce?: IntegerType;\n  /** the network that the transaction will ultimately be broadcast to */\n  network?: StacksNetworkName | StacksNetwork;\n  /** the transaction anchorMode, which specifies whether it should be\n   * included in an anchor block or a microblock */\n  anchorMode: AnchorModeName | AnchorMode;\n  /** the post condition mode, specifying whether or not post-conditions must fully cover all\n   * transfered assets */\n  postConditionMode?: PostConditionMode;\n  /** a list of post conditions to add to the transaction */\n  postConditions?: PostCondition[];\n  /** set to true if another account is sponsoring the transaction (covering the transaction fee) */\n  sponsored?: boolean;\n}\n\nexport interface ContractDeployOptions extends BaseContractDeployOptions {\n  /** a hex string of the private key of the transaction sender */\n  senderKey: string;\n}\n\nexport interface UnsignedContractDeployOptions extends BaseContractDeployOptions {\n  /** a hex string of the public key of the transaction sender */\n  publicKey: string;\n}\n\n/**\n * @deprecated Use the new {@link estimateTransaction} function insterad.\n *\n * Estimate the total transaction fee in microstacks for a contract deploy\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to estimate transaction for\n *\n * @return a promise that resolves to number of microstacks per byte\n */\nexport async function estimateContractDeploy(\n  transaction: StacksTransaction,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<bigint> {\n  if (\n    transaction.payload.payloadType !== PayloadType.SmartContract &&\n    transaction.payload.payloadType !== PayloadType.VersionedSmartContract\n  ) {\n    throw new Error(\n      `Contract deploy fee estimation only possible with ${\n        PayloadType[PayloadType.SmartContract]\n      } transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`\n    );\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text',\n  };\n\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders,\n  };\n\n  // Place holder estimate until contract deploy fee estimation is fully implemented on Stacks\n  // blockchain core\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\n\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(\n      `Error estimating contract deploy fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const feeRateResult = await response.text();\n  const txBytes = intToBigInt(transaction.serialize().byteLength, false);\n  const feeRate = intToBigInt(feeRateResult, false);\n  return feeRate * txBytes;\n}\n\n/**\n * Generates a Clarity smart contract deploy transaction\n *\n * @param {ContractDeployOptions} txOptions - an options object for the contract deploy\n *\n * Returns a signed Stacks smart contract deploy transaction.\n *\n * @return {StacksTransaction}\n */\nexport async function makeContractDeploy(\n  txOptions: ContractDeployOptions\n): Promise<StacksTransaction> {\n  const privKey = createStacksPrivateKey(txOptions.senderKey);\n  const stacksPublicKey = getPublicKey(privKey);\n  const publicKey = publicKeyToString(stacksPublicKey);\n  const unsignedTxOptions: UnsignedContractDeployOptions = { ...txOptions, publicKey };\n  const transaction: StacksTransaction = await makeUnsignedContractDeploy(unsignedTxOptions);\n\n  if (txOptions.senderKey) {\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n  }\n\n  return transaction;\n}\n\nexport async function makeUnsignedContractDeploy(\n  txOptions: UnsignedContractDeployOptions\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    postConditionMode: PostConditionMode.Deny,\n    sponsored: false,\n    clarityVersion: ClarityVersion.Clarity2,\n  };\n\n  const options = Object.assign(defaultOptions, txOptions);\n\n  const payload = createSmartContractPayload(\n    options.contractName,\n    options.codeBody,\n    options.clarityVersion\n  );\n\n  const addressHashMode = AddressHashMode.SerializeP2PKH;\n  const pubKey = createStacksPublicKey(options.publicKey);\n\n  let authorization: Authorization | null = null;\n\n  const spendingCondition = createSingleSigSpendingCondition(\n    addressHashMode,\n    publicKeyToString(pubKey),\n    options.nonce,\n    options.fee\n  );\n\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n\n  const postConditions: PostCondition[] = [];\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n  const lpPostConditions = createLPList(postConditions);\n\n  const transaction = new StacksTransaction(\n    network.version,\n    authorization,\n    payload,\n    lpPostConditions,\n    options.postConditionMode,\n    options.anchorMode,\n    network.chainId\n  );\n\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const fee = await estimateTransactionFeeWithFallback(transaction, network);\n    transaction.setFee(fee);\n  }\n\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion =\n      options.network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n    const senderAddress = publicKeyToAddress(addressVersion, pubKey);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\n\n/**\n * Contract function call transaction options\n */\nexport interface ContractCallOptions {\n  /** the Stacks address of the contract */\n  contractAddress: string;\n  contractName: string;\n  functionName: string;\n  functionArgs: ClarityValue[];\n  /** transaction fee in microstacks */\n  fee?: IntegerType;\n  feeEstimateApiUrl?: string;\n  /** the transaction nonce, which must be increased monotonically with each new transaction */\n  nonce?: IntegerType;\n  /** the Stacks blockchain network that will ultimately be used to broadcast this transaction */\n  network?: StacksNetworkName | StacksNetwork;\n  /** the transaction anchorMode, which specifies whether it should be\n   * included in an anchor block or a microblock */\n  anchorMode: AnchorModeName | AnchorMode;\n  /** the post condition mode, specifying whether or not post-conditions must fully cover all\n   * transfered assets */\n  postConditionMode?: PostConditionMode;\n  /** a list of post conditions to add to the transaction */\n  postConditions?: PostCondition[];\n  /** set to true to validate that the supplied function args match those specified in\n   * the published contract */\n  validateWithAbi?: boolean | ClarityAbi;\n  /** set to true if another account is sponsoring the transaction (covering the transaction fee) */\n  sponsored?: boolean;\n}\n\nexport interface UnsignedContractCallOptions extends ContractCallOptions {\n  publicKey: string;\n}\n\nexport interface SignedContractCallOptions extends ContractCallOptions {\n  senderKey: string;\n}\n\nexport interface UnsignedMultiSigContractCallOptions extends ContractCallOptions {\n  numSignatures: number;\n  publicKeys: string[];\n}\n\nexport interface SignedMultiSigContractCallOptions extends ContractCallOptions {\n  numSignatures: number;\n  publicKeys: string[];\n  signerKeys: string[];\n}\n\n/**\n * @deprecated Use the new {@link estimateTransaction} function insterad.\n *\n * Estimate the total transaction fee in microstacks for a contract function call\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to estimate transaction for\n *\n * @return a promise that resolves to number of microstacks per byte\n */\nexport async function estimateContractFunctionCall(\n  transaction: StacksTransaction,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<bigint> {\n  if (transaction.payload.payloadType !== PayloadType.ContractCall) {\n    throw new Error(\n      `Contract call fee estimation only possible with ${\n        PayloadType[PayloadType.ContractCall]\n      } transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`\n    );\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text',\n  };\n\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders,\n  };\n\n  // Place holder estimate until contract call fee estimation is fully implemented on Stacks\n  // blockchain core\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\n\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(\n      `Error estimating contract call fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const feeRateResult = await response.text();\n  const txBytes = intToBigInt(transaction.serialize().byteLength, false);\n  const feeRate = intToBigInt(feeRateResult, false);\n  return feeRate * txBytes;\n}\n\n/**\n * Generates an unsigned Clarity smart contract function call transaction\n *\n * @param {UnsignedContractCallOptions | UnsignedMultiSigContractCallOptions} txOptions - an options object for the contract call\n *\n * @returns {Promise<StacksTransaction>}\n */\nexport async function makeUnsignedContractCall(\n  txOptions: UnsignedContractCallOptions | UnsignedMultiSigContractCallOptions\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    postConditionMode: PostConditionMode.Deny,\n    sponsored: false,\n  };\n\n  const options = Object.assign(defaultOptions, txOptions);\n\n  const payload = createContractCallPayload(\n    options.contractAddress,\n    options.contractName,\n    options.functionName,\n    options.functionArgs\n  );\n\n  if (options?.validateWithAbi) {\n    let abi: ClarityAbi;\n    if (typeof options.validateWithAbi === 'boolean') {\n      if (options?.network) {\n        abi = await getAbi(options.contractAddress, options.contractName, options.network);\n      } else {\n        throw new Error('Network option must be provided in order to validate with ABI');\n      }\n    } else {\n      abi = options.validateWithAbi;\n    }\n\n    validateContractCall(payload, abi);\n  }\n\n  let spendingCondition: SpendingCondition | null = null;\n  let authorization: Authorization | null = null;\n\n  if ('publicKey' in options) {\n    // single-sig\n    spendingCondition = createSingleSigSpendingCondition(\n      AddressHashMode.SerializeP2PKH,\n      options.publicKey,\n      options.nonce,\n      options.fee\n    );\n  } else {\n    // multi-sig\n    spendingCondition = createMultiSigSpendingCondition(\n      AddressHashMode.SerializeP2SH,\n      options.numSignatures,\n      options.publicKeys,\n      options.nonce,\n      options.fee\n    );\n  }\n\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n\n  const postConditions: PostCondition[] = [];\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n\n  const lpPostConditions = createLPList(postConditions);\n  const transaction = new StacksTransaction(\n    network.version,\n    authorization,\n    payload,\n    lpPostConditions,\n    options.postConditionMode,\n    options.anchorMode,\n    network.chainId\n  );\n\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const fee = await estimateTransactionFeeWithFallback(transaction, network);\n    transaction.setFee(fee);\n  }\n\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion =\n      network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition!.signer);\n    const txNonce = await getNonce(senderAddress, network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\n\n/**\n * Generates a Clarity smart contract function call transaction\n *\n * @param {SignedContractCallOptions | SignedMultiSigContractCallOptions} txOptions - an options object for the contract function call\n *\n * Returns a signed Stacks smart contract function call transaction.\n *\n * @return {StacksTransaction}\n */\nexport async function makeContractCall(\n  txOptions: SignedContractCallOptions | SignedMultiSigContractCallOptions\n): Promise<StacksTransaction> {\n  if ('senderKey' in txOptions) {\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedContractCall({ publicKey, ...options });\n\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n\n    return transaction;\n  } else {\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedContractCall(options);\n\n    const signer = new TransactionSigner(transaction);\n    let pubKeys = txOptions.publicKeys;\n    for (const key of txOptions.signerKeys) {\n      const pubKey = pubKeyfromPrivKey(key);\n      pubKeys = pubKeys.filter(pk => pk !== bytesToHex(pubKey.data));\n      signer.signOrigin(createStacksPrivateKey(key));\n    }\n\n    for (const key of pubKeys) {\n      signer.appendOrigin(publicKeyFromBytes(hexToBytes(key)));\n    }\n\n    return transaction;\n  }\n}\n\n/**\n * Generates a STX post condition with a standard principal\n *\n * Returns a STX post condition object\n *\n * @param address - the c32check address\n * @param conditionCode - the condition code\n * @param amount - the amount of STX tokens (denoted in micro-STX)\n */\nexport function makeStandardSTXPostCondition(\n  address: string,\n  conditionCode: FungibleConditionCode,\n  amount: IntegerType\n): STXPostCondition {\n  return createSTXPostCondition(createStandardPrincipal(address), conditionCode, amount);\n}\n\n/**\n * Generates a STX post condition with a contract principal\n *\n * Returns a STX post condition object\n *\n * @param address - the c32check address of the contract\n * @param contractName - the name of the contract\n * @param conditionCode - the condition code\n * @param amount - the amount of STX tokens (denoted in micro-STX)\n *\n * @return {STXPostCondition}\n */\nexport function makeContractSTXPostCondition(\n  address: string,\n  contractName: string,\n  conditionCode: FungibleConditionCode,\n  amount: IntegerType\n): STXPostCondition {\n  return createSTXPostCondition(\n    createContractPrincipal(address, contractName),\n    conditionCode,\n    amount\n  );\n}\n\n/**\n * Generates a fungible token post condition with a standard principal\n *\n * Returns a fungible token post condition object\n *\n * @param address - the c32check address\n * @param conditionCode - the condition code\n * @param amount - the amount of fungible tokens (in their respective base unit)\n * @param assetInfo - asset info describing the fungible token\n */\nexport function makeStandardFungiblePostCondition(\n  address: string,\n  conditionCode: FungibleConditionCode,\n  amount: IntegerType,\n  assetInfo: string | AssetInfo\n): FungiblePostCondition {\n  return createFungiblePostCondition(\n    createStandardPrincipal(address),\n    conditionCode,\n    amount,\n    assetInfo\n  );\n}\n\n/**\n * Generates a fungible token post condition with a contract principal\n *\n * Returns a fungible token post condition object\n *\n * @param address - the c32check address\n * @param contractName - the name of the contract\n * @param conditionCode - the condition code\n * @param amount - the amount of fungible tokens (in their respective base unit)\n * @param assetInfo - asset info describing the fungible token\n */\nexport function makeContractFungiblePostCondition(\n  address: string,\n  contractName: string,\n  conditionCode: FungibleConditionCode,\n  amount: IntegerType,\n  assetInfo: string | AssetInfo\n): FungiblePostCondition {\n  return createFungiblePostCondition(\n    createContractPrincipal(address, contractName),\n    conditionCode,\n    amount,\n    assetInfo\n  );\n}\n\n/**\n * Generates a non-fungible token post condition with a standard principal\n *\n * Returns a non-fungible token post condition object\n *\n * @param {String} address - the c32check address\n * @param {FungibleConditionCode} conditionCode - the condition code\n * @param {AssetInfo} assetInfo - asset info describing the non-fungible token\n * @param {ClarityValue} assetId - asset identifier of the nft instance (typically a uint/buffer/string)\n *\n * @return {NonFungiblePostCondition}\n */\nexport function makeStandardNonFungiblePostCondition(\n  address: string,\n  conditionCode: NonFungibleConditionCode,\n  assetInfo: string | AssetInfo,\n  assetId: ClarityValue\n): NonFungiblePostCondition {\n  return createNonFungiblePostCondition(\n    createStandardPrincipal(address),\n    conditionCode,\n    assetInfo,\n    assetId\n  );\n}\n\n/**\n * Generates a non-fungible token post condition with a contract principal\n *\n * Returns a non-fungible token post condition object\n *\n * @param {String} address - the c32check address\n * @param {String} contractName - the name of the contract\n * @param {FungibleConditionCode} conditionCode - the condition code\n * @param {AssetInfo} assetInfo - asset info describing the non-fungible token\n * @param {ClarityValue} assetId - asset identifier of the nft instance (typically a uint/buffer/string)\n *\n * @return {NonFungiblePostCondition}\n */\nexport function makeContractNonFungiblePostCondition(\n  address: string,\n  contractName: string,\n  conditionCode: NonFungibleConditionCode,\n  assetInfo: string | AssetInfo,\n  assetId: ClarityValue\n): NonFungiblePostCondition {\n  return createNonFungiblePostCondition(\n    createContractPrincipal(address, contractName),\n    conditionCode,\n    assetInfo,\n    assetId\n  );\n}\n\n/**\n * Read only function options\n *\n * @param {String} contractAddress - the c32check address of the contract\n * @param {String} contractName - the contract name\n * @param {String} functionName - name of the function to be called\n * @param {[ClarityValue]} functionArgs - an array of Clarity values as arguments to the function call\n * @param {StacksNetwork} network - the Stacks blockchain network this transaction is destined for\n * @param {String} senderAddress - the c32check address of the sender\n */\n\nexport interface ReadOnlyFunctionOptions {\n  contractName: string;\n  contractAddress: string;\n  functionName: string;\n  functionArgs: ClarityValue[];\n  /** the network that the contract which contains the function is deployed to */\n  network?: StacksNetworkName | StacksNetwork;\n  /** address of the sender */\n  senderAddress: string;\n}\n\n/**\n * Calls a function as read-only from a contract interface\n * It is not necessary that the function is defined as read-only in the contract\n *\n * @param {ReadOnlyFunctionOptions} readOnlyFunctionOptions - the options object\n *\n * Returns an object with a status bool (okay) and a result string that is a serialized clarity value in hex format.\n *\n * @return {ClarityValue}\n */\nexport async function callReadOnlyFunction(\n  readOnlyFunctionOptions: ReadOnlyFunctionOptions\n): Promise<ClarityValue> {\n  const defaultOptions = {\n    network: new StacksMainnet(),\n  };\n\n  const options = Object.assign(defaultOptions, readOnlyFunctionOptions);\n\n  const { contractName, contractAddress, functionName, functionArgs, senderAddress } = options;\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const url = network.getReadOnlyFunctionCallApiUrl(contractAddress, contractName, functionName);\n\n  const args = functionArgs.map(arg => cvToHex(arg));\n\n  const body = JSON.stringify({\n    sender: senderAddress,\n    arguments: args,\n  });\n\n  const response = await network.fetchFn(url, {\n    method: 'POST',\n    body,\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  });\n\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(\n      `Error calling read-only function. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n\n  return response.json().then(responseJson => parseReadOnlyResponse(responseJson));\n}\n\nexport interface GetContractMapEntryOptions {\n  /** the contracts address */\n  contractAddress: string;\n  /** the contracts name */\n  contractName: string;\n  /** the map name */\n  mapName: string;\n  /** key to lookup in the map */\n  mapKey: ClarityValue;\n  /** the network that has the contract */\n  network?: StacksNetworkName | StacksNetwork;\n}\n\n/**\n * Fetch data from a contract data map.\n * @param getContractMapEntryOptions - the options object\n * @returns\n * Promise that resolves to a ClarityValue if the operation succeeds.\n * Resolves to NoneCV if the map does not contain the given key, if the map does not exist, or if the contract prinicipal does not exist\n */\nexport async function getContractMapEntry<T extends ClarityValue = ClarityValue>(\n  getContractMapEntryOptions: GetContractMapEntryOptions\n): Promise<T | NoneCV> {\n  const defaultOptions = {\n    network: new StacksMainnet(),\n  };\n  const { contractAddress, contractName, mapName, mapKey, network } = Object.assign(\n    defaultOptions,\n    getContractMapEntryOptions\n  );\n\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network);\n  const url = derivedNetwork.getMapEntryUrl(contractAddress, contractName, mapName);\n\n  const serializedKeyBytes = serializeCV(mapKey);\n  const serializedKeyHex = '0x' + bytesToHex(serializedKeyBytes);\n\n  const fetchOptions: RequestInit = {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      Accept: 'application/json',\n    },\n    body: JSON.stringify(serializedKeyHex), // endpoint expects a JSON string atom (quote wrapped string)\n  };\n\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(\n      `Error fetching map entry for map \"${mapName}\" in contract \"${contractName}\" at address ${contractAddress}, using map key \"${serializedKeyHex}\". Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const responseBody = await response.text();\n  const responseJson: { data?: string } = JSON.parse(responseBody);\n  if (!responseJson.data) {\n    throw new Error(\n      `Error fetching map entry for map \"${mapName}\" in contract \"${contractName}\" at address ${contractAddress}, using map key \"${serializedKeyHex}\". Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the response: \"${responseBody}\"`\n    );\n  }\n  let deserializedCv: T;\n  try {\n    deserializedCv = deserializeCV<T>(responseJson.data);\n  } catch (error) {\n    throw new Error(`Error deserializing Clarity value \"${responseJson.data}\": ${error}`);\n  }\n  return deserializedCv;\n}\n\n/**\n * Sponsored transaction options\n */\nexport interface SponsorOptionsOpts {\n  /** the origin-signed transaction */\n  transaction: StacksTransaction;\n  /** the sponsor's private key */\n  sponsorPrivateKey: string;\n  /** the transaction fee amount to sponsor */\n  fee?: IntegerType;\n  /** the nonce of the sponsor account */\n  sponsorNonce?: IntegerType;\n  /** the hashmode of the sponsor's address */\n  sponsorAddressHashmode?: AddressHashMode;\n  /** the Stacks blockchain network that this transaction will ultimately be broadcast to */\n  network?: StacksNetworkName | StacksNetwork;\n}\n\n/**\n * Constructs and signs a sponsored transaction as the sponsor\n *\n * @param {SponsorOptionsOpts} sponsorOptions - the sponsor options object\n *\n * Returns a signed sponsored transaction.\n *\n * @return {ClarityValue}\n */\nexport async function sponsorTransaction(\n  sponsorOptions: SponsorOptionsOpts\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: 0 as IntegerType,\n    sponsorNonce: 0 as IntegerType,\n    sponsorAddressHashmode: AddressHashMode.SerializeP2PKH as SingleSigHashMode,\n    network:\n      sponsorOptions.transaction.version === TransactionVersion.Mainnet\n        ? new StacksMainnet()\n        : new StacksTestnet(),\n  };\n\n  const options = Object.assign(defaultOptions, sponsorOptions);\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const sponsorPubKey = pubKeyfromPrivKey(options.sponsorPrivateKey);\n\n  if (sponsorOptions.fee === undefined || sponsorOptions.fee === null) {\n    let txFee = 0;\n    switch (options.transaction.payload.payloadType) {\n      case PayloadType.TokenTransfer:\n      case PayloadType.SmartContract:\n      case PayloadType.VersionedSmartContract:\n      case PayloadType.ContractCall:\n        const estimatedLen = estimateTransactionByteLength(options.transaction);\n        try {\n          txFee = (await estimateTransaction(options.transaction.payload, estimatedLen, network))[1]\n            .fee;\n        } catch (e) {\n          throw e;\n        }\n        break;\n      default:\n        throw new Error(\n          `Sponsored transactions not supported for transaction type ${\n            PayloadType[options.transaction.payload.payloadType]\n          }`\n        );\n    }\n    options.transaction.setFee(txFee);\n    options.fee = txFee;\n  }\n\n  if (sponsorOptions.sponsorNonce === undefined || sponsorOptions.sponsorNonce === null) {\n    const addressVersion =\n      network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n\n    const senderAddress = publicKeyToAddress(addressVersion, sponsorPubKey);\n    const sponsorNonce = await getNonce(senderAddress, network);\n    options.sponsorNonce = sponsorNonce;\n  }\n\n  const sponsorSpendingCondition = createSingleSigSpendingCondition(\n    options.sponsorAddressHashmode,\n    publicKeyToString(sponsorPubKey),\n    options.sponsorNonce,\n    options.fee\n  );\n\n  options.transaction.setSponsor(sponsorSpendingCondition);\n\n  const privKey = createStacksPrivateKey(options.sponsorPrivateKey);\n  const signer = TransactionSigner.createSponsorSigner(\n    options.transaction,\n    sponsorSpendingCondition\n  );\n  signer.signSponsor(privKey);\n\n  return signer.transaction;\n}\n\n/**\n * Estimates transaction byte length\n * Context:\n * 1) Multi-sig transaction byte length increases by adding signatures\n *    which causes the incorrect fee estimation because the fee value is set while creating unsigned transaction\n * 2) Single-sig transaction byte length remain same due to empty message signature which allocates the space for signature\n * @param {transaction} - StacksTransaction object to be estimated\n * @return {number} Estimated transaction byte length\n */\nexport function estimateTransactionByteLength(transaction: StacksTransaction): number {\n  const hashMode = transaction.auth.spendingCondition.hashMode;\n  // List of Multi-sig transaction hash modes\n  const multiSigHashModes = [AddressHashMode.SerializeP2SH, AddressHashMode.SerializeP2WSH];\n\n  // Check if its a Multi-sig transaction\n  if (multiSigHashModes.includes(hashMode)) {\n    const multiSigSpendingCondition: MultiSigSpendingCondition = transaction.auth\n      .spendingCondition as MultiSigSpendingCondition;\n\n    // Find number of existing signatures if the transaction is signed or partially signed\n    const existingSignatures = multiSigSpendingCondition.fields.filter(\n      field => field.contents.type === StacksMessageType.MessageSignature\n    ).length; // existingSignatures will be 0 if its a unsigned transaction\n\n    // Estimate total signature bytes size required for this multi-sig transaction\n    // Formula: totalSignatureLength = (signaturesRequired - existingSignatures) * (SIG_LEN_BYTES + 1 byte of type of signature)\n    const totalSignatureLength =\n      (multiSigSpendingCondition.signaturesRequired - existingSignatures) *\n      (RECOVERABLE_ECDSA_SIG_LENGTH_BYTES + 1);\n\n    return transaction.serialize().byteLength + totalSignatureLength;\n  } else {\n    // Single-sig transaction\n    // Signature space already allocated by empty message signature\n    return transaction.serialize().byteLength;\n  }\n}\n\n/**\n * Estimates the fee using {@link estimateTransfer} as a fallback if\n * {@link estimateTransaction} does not get an estimation due to the\n * {@link NoEstimateAvailableError} error.\n */\nexport async function estimateTransactionFeeWithFallback(\n  transaction: StacksTransaction,\n  network: StacksNetwork\n): Promise<bigint | number> {\n  try {\n    const estimatedLen = estimateTransactionByteLength(transaction);\n    return (await estimateTransaction(transaction.payload, estimatedLen, network))[1].fee;\n  } catch (error) {\n    if (error instanceof NoEstimateAvailableError) {\n      return await estimateTransferUnsafe(transaction, network);\n    }\n    throw error;\n  }\n}\n"],"mappings":"AAAA,SAASA,UAAU,EAAEC,UAAU,EAAeC,WAAW,QAAQ,gBAAgB;AACjF,SACEC,aAAa,EACbC,aAAa,EAEbC,aAAa,EAEbC,aAAa,QACR,iBAAiB;AACxB,SAASC,UAAU,QAAQ,UAAU;AACrC,SAEEC,+BAA+B,EAC/BC,gCAAgC,EAChCC,mBAAmB,EACnBC,kBAAkB,QAGb,iBAAiB;AACxB,SAAuBC,aAAa,EAAuBC,WAAW,QAAQ,WAAW;AACzF,SACEC,eAAe,EACfC,cAAc,EAIdC,WAAW,EACXC,iBAAiB,EAEjBC,kBAAkB,EAElBC,kCAAkC,EAClCC,iBAAiB,EACjBC,cAAc,QAET,aAAa;AACpB,SAAqBC,oBAAoB,QAAQ,gBAAgB;AACjE,SAASC,wBAAwB,QAAQ,UAAU;AACnD,SACEC,sBAAsB,EACtBC,qBAAqB,EACrBC,YAAY,EACZC,iBAAiB,EACjBC,kBAAkB,EAClBC,kBAAkB,EAClBC,iBAAiB,QACZ,QAAQ;AACf,SACEC,yBAAyB,EACzBC,0BAA0B,EAC1BC,0BAA0B,EAE1BC,gBAAgB,QACX,WAAW;AAClB,SACEC,2BAA2B,EAC3BC,8BAA8B,EAC9BC,sBAAsB,QACjB,iBAAiB;AACxB,SAEEC,uBAAuB,EACvBC,uBAAuB,QAKlB,uBAAuB;AAC9B,SAASC,iBAAiB,QAAQ,UAAU;AAC5C,SAASC,iBAAiB,QAAQ,eAAe;AACjD,SAASC,YAAY,QAAQ,SAAS;AACtC,SAASC,OAAO,EAAEC,IAAI,EAAEC,qBAAqB,EAAEC,YAAY,QAAQ,SAAS;AAU5E,OAAO,eAAeC,QAAQA,CAC5BC,OAAe,EACfC,OAA2C;EAE3C,MAAMC,cAAc,GAAG/C,aAAa,CAACgD,iBAAiB,CAACF,OAAO,aAAPA,OAAO,cAAPA,OAAO,GAAI,IAAI7C,aAAa,EAAE,CAAC;EACtF,MAAMgD,GAAG,GAAGF,cAAc,CAACG,gBAAgB,CAACL,OAAO,CAAC;EAEpD,MAAMM,QAAQ,GAAG,MAAMJ,cAAc,CAACK,OAAO,CAACH,GAAG,CAAC;EAClD,IAAI,CAACE,QAAQ,CAACE,EAAE,EAAE;IAChB,IAAIC,GAAG,GAAG,EAAE;IACZ,IAAI;MACFA,GAAG,GAAG,MAAMH,QAAQ,CAACI,IAAI,EAAE;KAC5B,CAAC,OAAOC,KAAK,EAAE;IAChB,MAAM,IAAIC,KAAK,CACb,kCAAkCN,QAAQ,CAACO,MAAM,KAAKP,QAAQ,CAACQ,UAAU,wBAAwBV,GAAG,kCAAkCK,GAAG,GAAG,CAC7I;;EAEH,MAAMM,YAAY,GAAG,MAAMT,QAAQ,CAACI,IAAI,EAAE;EAC1C,MAAMM,MAAM,GAAGC,IAAI,CAACC,KAAK,CAACH,YAAY,CAAsB;EAC5D,OAAOI,MAAM,CAACH,MAAM,CAACI,KAAK,CAAC;AAC7B;AAYA,OAAO,eAAeC,gBAAgBA,CACpCC,WAA8B,EAC9BrB,OAA2C;EAE3C,IAAIqB,WAAW,CAACC,OAAO,CAACC,WAAW,KAAKxD,WAAW,CAACyD,aAAa,EAAE;IACjE,MAAM,IAAIb,KAAK,CACb,iDACE5C,WAAW,CAACA,WAAW,CAACyD,aAAa,CACvC,gCAAgCzD,WAAW,CAACsD,WAAW,CAACC,OAAO,CAACC,WAAW,CAAC,EAAE,CAC/E;;EAGH,OAAOE,sBAAsB,CAACJ,WAAW,EAAErB,OAAO,CAAC;AACrD;AAMA,OAAO,eAAeyB,sBAAsBA,CAC1CJ,WAA8B,EAC9BrB,OAA2C;EAE3C,MAAM0B,cAAc,GAAG;IACrBC,MAAM,EAAE;GACT;EAED,MAAMC,YAAY,GAAG;IACnBC,MAAM,EAAE,KAAK;IACbC,OAAO,EAAEJ;GACV;EAED,MAAMzB,cAAc,GAAG/C,aAAa,CAACgD,iBAAiB,CAACF,OAAO,aAAPA,OAAO,cAAPA,OAAO,GAAI+B,aAAa,CAACV,WAAW,CAAC,CAAC;EAC7F,MAAMlB,GAAG,GAAGF,cAAc,CAAC+B,4BAA4B,EAAE;EAEzD,MAAM3B,QAAQ,GAAG,MAAMJ,cAAc,CAACK,OAAO,CAACH,GAAG,EAAEyB,YAAY,CAAC;EAChE,IAAI,CAACvB,QAAQ,CAACE,EAAE,EAAE;IAChB,IAAIC,GAAG,GAAG,EAAE;IACZ,IAAI;MACFA,GAAG,GAAG,MAAMH,QAAQ,CAACI,IAAI,EAAE;KAC5B,CAAC,OAAOC,KAAK,EAAE;IAChB,MAAM,IAAIC,KAAK,CACb,8CAA8CN,QAAQ,CAACO,MAAM,KAAKP,QAAQ,CAACQ,UAAU,wBAAwBV,GAAG,kCAAkCK,GAAG,GAAG,CACzJ;;EAEH,MAAMyB,aAAa,GAAG,MAAM5B,QAAQ,CAACI,IAAI,EAAE;EAC3C,MAAMyB,OAAO,GAAGhB,MAAM,CAACG,WAAW,CAACc,SAAS,EAAE,CAACC,UAAU,CAAC;EAC1D,MAAMC,OAAO,GAAGnB,MAAM,CAACe,aAAa,CAAC;EACrC,OAAOI,OAAO,GAAGH,OAAO;AAC1B;AA8BA,OAAO,eAAeI,mBAAmBA,CACvCC,kBAA2B,EAC3BC,YAAqB,EACrBxC,OAA2C;EAE3C,MAAMyC,OAAO,GAAG;IACdZ,MAAM,EAAE,MAAM;IACdC,OAAO,EAAE;MAAE,cAAc,EAAE;IAAkB,CAAE;IAC/CY,IAAI,EAAE1B,IAAI,CAAC2B,SAAS,CAAC;MACnBC,mBAAmB,EAAE7F,UAAU,CAACkC,gBAAgB,CAACsD,kBAAkB,CAAC,CAAC;MACrE,IAAIC,YAAY,GAAG;QAAEK,aAAa,EAAEL;MAAY,CAAE,GAAG,EAAE;KACxD;GACF;EAED,MAAMvC,cAAc,GAAG/C,aAAa,CAACgD,iBAAiB,CAACF,OAAO,aAAPA,OAAO,cAAPA,OAAO,GAAI,IAAI7C,aAAa,EAAE,CAAC;EACtF,MAAMgD,GAAG,GAAGF,cAAc,CAAC6C,+BAA+B,EAAE;EAE5D,MAAMzC,QAAQ,GAAG,MAAMJ,cAAc,CAACK,OAAO,CAACH,GAAG,EAAEsC,OAAO,CAAC;EAE3D,IAAI,CAACpC,QAAQ,CAACE,EAAE,EAAE;IAChB,MAAMmC,IAAI,GAAG,MAAMrC,QAAQ,CAAC0C,IAAI,EAAE,CAACC,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC;IAEpD,IAAI,CAAAN,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAEO,MAAM,MAAK,qBAAqB,EAAE;MAAA,IAAAC,qBAAA,EAAAC,iBAAA;MAC1C,MAAM,IAAI7E,wBAAwB,EAAA4E,qBAAA,GAACR,IAAI,aAAJA,IAAI,wBAAAS,iBAAA,GAAJT,IAAI,CAAEU,WAAW,cAAAD,iBAAA,uBAAjBA,iBAAA,CAAmBE,OAAO,cAAAH,qBAAA,cAAAA,qBAAA,GAAI,EAAE,CAAC;;IAGtE,MAAM,IAAIvC,KAAK,CACb,8CAA8CN,QAAQ,CAACO,MAAM,KAAKP,QAAQ,CAACQ,UAAU,wBAAwBV,GAAG,kCAAkCuC,IAAI,GAAG,CAC1J;;EAGH,MAAMY,IAAI,GAAwB,MAAMjD,QAAQ,CAAC0C,IAAI,EAAE;EACvD,OAAOO,IAAI,CAACC,WAAW;AACzB;AA8LA,OAAO,eAAeC,oBAAoBA,CACxCnC,WAA8B,EAC9BrB,OAA2C,EAC3CyD,UAAuB;EAEvB,MAAMC,KAAK,GAAGrC,WAAW,CAACc,SAAS,EAAE;EACrC,MAAMlC,cAAc,GAAG/C,aAAa,CAACgD,iBAAiB,CAACF,OAAO,aAAPA,OAAO,cAAPA,OAAO,GAAI+B,aAAa,CAACV,WAAW,CAAC,CAAC;EAC7F,MAAMlB,GAAG,GAAGF,cAAc,CAAC0D,kBAAkB,EAAE;EAE/C,OAAOC,uBAAuB,CAACF,KAAK,EAAEvD,GAAG,EAAEsD,UAAU,EAAExD,cAAc,CAACK,OAAO,CAAC;AAChF;AAUA,OAAO,eAAesD,uBAAuBA,CAC3CF,KAAiB,EACjBvD,GAAW,EACXsD,UAAuB,EACW;EAAA,IAAlCnD,OAAA,GAAAuD,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAmBxG,aAAa,EAAE;EAElC,MAAMoF,OAAO,GAAG;IACdZ,MAAM,EAAE,MAAM;IACdC,OAAO,EAAE;MAAE,cAAc,EAAE2B,UAAU,GAAG,kBAAkB,GAAG;IAA0B,CAAE;IACzFf,IAAI,EAAEe,UAAU,GACZzC,IAAI,CAAC2B,SAAS,CAAC;MACbqB,EAAE,EAAEjH,UAAU,CAAC2G,KAAK,CAAC;MACrBD,UAAU,EAAE1G,UAAU,CAAC0G,UAAU;KAClC,CAAC,GACFC;GACL;EAED,MAAMrD,QAAQ,GAAG,MAAMC,OAAO,CAACH,GAAG,EAAEsC,OAAO,CAAC;EAC5C,IAAI,CAACpC,QAAQ,CAACE,EAAE,EAAE;IAChB,IAAI;MACF,OAAQ,MAAMF,QAAQ,CAAC0C,IAAI,EAAE;KAC9B,CAAC,OAAOkB,CAAC,EAAE;MACV,MAAMtD,KAAK,CAAC,oCAAqCsD,CAAW,CAACZ,OAAO,EAAE,CAAC;;;EAI3E,MAAM5C,IAAI,GAAG,MAAMJ,QAAQ,CAACI,IAAI,EAAE;EAElC,MAAMyD,IAAI,GAAGzD,IAAI,CAAC0D,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC;EACtC,IAAI,CAACtE,YAAY,CAACqE,IAAI,CAAC,EAAE,MAAM,IAAIvD,KAAK,CAACF,IAAI,CAAC;EAC9C,OAAO;IAAEyD;EAAI,CAAuB;AACtC;AAWA,OAAO,eAAeE,MAAMA,CAC1BrE,OAAe,EACfsE,YAAoB,EACpBrE,OAA0C;EAE1C,MAAMyC,OAAO,GAAG;IACdZ,MAAM,EAAE;GACT;EAED,MAAM5B,cAAc,GAAG/C,aAAa,CAACgD,iBAAiB,CAACF,OAAO,CAAC;EAC/D,MAAMG,GAAG,GAAGF,cAAc,CAACqE,YAAY,CAACvE,OAAO,EAAEsE,YAAY,CAAC;EAE9D,MAAMhE,QAAQ,GAAG,MAAMJ,cAAc,CAACK,OAAO,CAACH,GAAG,EAAEsC,OAAO,CAAC;EAC3D,IAAI,CAACpC,QAAQ,CAACE,EAAE,EAAE;IAChB,MAAMC,GAAG,GAAG,MAAMH,QAAQ,CAACI,IAAI,EAAE,CAACuC,KAAK,CAAC,MAAM,EAAE,CAAC;IACjD,MAAM,IAAIrC,KAAK,CACb,6CAA6C0D,YAAY,gBAAgBtE,OAAO,cAAcM,QAAQ,CAACO,MAAM,KAAKP,QAAQ,CAACQ,UAAU,wBAAwBV,GAAG,kCAAkCK,GAAG,GAAG,CACzM;;EAGH,OAAOQ,IAAI,CAACC,KAAK,CAAC,MAAMZ,QAAQ,CAACI,IAAI,EAAE,CAAe;AACxD;AAEA,SAASsB,aAAaA,CAACV,WAA8B;EACnD,QAAQA,WAAW,CAACkD,OAAO;IACzB,KAAKtG,kBAAkB,CAACuG,OAAO;MAC7B,OAAO,IAAIrH,aAAa,EAAE;IAC5B,KAAKc,kBAAkB,CAACwG,OAAO;MAC7B,OAAO,IAAIrH,aAAa,EAAE;;AAEhC;AAgEA,OAAO,eAAesH,4BAA4BA,CAChDC,SAA8E;EAE9E,MAAMC,cAAc,GAAG;IACrBC,GAAG,EAAE3D,MAAM,CAAC,CAAC,CAAC;IACdC,KAAK,EAAED,MAAM,CAAC,CAAC,CAAC;IAChBlB,OAAO,EAAE,IAAI7C,aAAa,EAAE;IAC5B2H,iBAAiB,EAAE9G,iBAAiB,CAAC+G,IAAI;IACzCC,IAAI,EAAE,EAAE;IACRC,SAAS,EAAE;GACZ;EAED,MAAMxC,OAAO,GAAGyC,MAAM,CAACC,MAAM,CAACP,cAAc,EAAED,SAAS,CAAC;EAExD,MAAMrD,OAAO,GAAGtC,0BAA0B,CAACyD,OAAO,CAAC2C,SAAS,EAAE3C,OAAO,CAAC4C,MAAM,EAAE5C,OAAO,CAACuC,IAAI,CAAC;EAE3F,IAAIM,aAAa,GAAyB,IAAI;EAC9C,IAAIC,iBAAiB,GAA6B,IAAI;EAEtD,IAAI,WAAW,IAAI9C,OAAO,EAAE;IAE1B8C,iBAAiB,GAAG/H,gCAAgC,CAClDK,eAAe,CAAC2H,cAAc,EAC9B/C,OAAO,CAACgD,SAAS,EACjBhD,OAAO,CAACtB,KAAK,EACbsB,OAAO,CAACoC,GAAG,CACZ;GACF,MAAM;IAELU,iBAAiB,GAAGhI,+BAA+B,CACjDM,eAAe,CAAC6H,aAAa,EAC7BjD,OAAO,CAACkD,aAAa,EACrBlD,OAAO,CAACmD,UAAU,EAClBnD,OAAO,CAACtB,KAAK,EACbsB,OAAO,CAACoC,GAAG,CACZ;;EAGH,IAAIpC,OAAO,CAACwC,SAAS,EAAE;IACrBK,aAAa,GAAG7H,mBAAmB,CAAC8H,iBAAiB,CAAC;GACvD,MAAM;IACLD,aAAa,GAAG5H,kBAAkB,CAAC6H,iBAAiB,CAAC;;EAGvD,MAAMvF,OAAO,GAAG9C,aAAa,CAACgD,iBAAiB,CAACuC,OAAO,CAACzC,OAAO,CAAC;EAEhE,MAAM6F,cAAc,GAAoB,EAAE;EAC1C,IAAIpD,OAAO,CAACoD,cAAc,IAAIpD,OAAO,CAACoD,cAAc,CAAC/B,MAAM,GAAG,CAAC,EAAE;IAC/DrB,OAAO,CAACoD,cAAc,CAACC,OAAO,CAACC,aAAa,IAAG;MAC7CF,cAAc,CAACG,IAAI,CAACD,aAAa,CAAC;IACpC,CAAC,CAAC;;EAEJ,MAAME,gBAAgB,GAAGxG,YAAY,CAACoG,cAAc,CAAC;EAErD,MAAMxE,WAAW,GAAG,IAAI7B,iBAAiB,CACvCQ,OAAO,CAACuE,OAAO,EACfe,aAAa,EACbhE,OAAO,EACP2E,gBAAgB,EAChBxD,OAAO,CAACqC,iBAAiB,EACzBrC,OAAO,CAACyD,UAAU,EAClBlG,OAAO,CAACmG,OAAO,CAChB;EAED,IAAIxB,SAAS,CAACE,GAAG,KAAKd,SAAS,IAAIY,SAAS,CAACE,GAAG,KAAK,IAAI,EAAE;IACzD,MAAMA,GAAG,GAAG,MAAMuB,kCAAkC,CAAC/E,WAAW,EAAErB,OAAO,CAAC;IAC1EqB,WAAW,CAACgF,MAAM,CAACxB,GAAG,CAAC;;EAGzB,IAAIF,SAAS,CAACxD,KAAK,KAAK4C,SAAS,IAAIY,SAAS,CAACxD,KAAK,KAAK,IAAI,EAAE;IAC7D,MAAMmF,cAAc,GAClB7D,OAAO,CAACzC,OAAO,CAACuE,OAAO,KAAKtG,kBAAkB,CAACuG,OAAO,GAClD1G,cAAc,CAACyI,gBAAgB,GAC/BzI,cAAc,CAAC0I,gBAAgB;IACrC,MAAMC,aAAa,GAAGnJ,UAAU,CAACgJ,cAAc,EAAEjF,WAAW,CAACqF,IAAI,CAACnB,iBAAkB,CAACoB,MAAM,CAAC;IAC5F,MAAMC,OAAO,GAAG,MAAM9G,QAAQ,CAAC2G,aAAa,EAAEhE,OAAO,CAACzC,OAAO,CAAC;IAC9DqB,WAAW,CAACwF,QAAQ,CAACD,OAAO,CAAC;;EAG/B,OAAOvF,WAAW;AACpB;AAWA,OAAO,eAAeyF,oBAAoBA,CACxCnC,SAA0E;EAE1E,IAAI,WAAW,IAAIA,SAAS,EAAE;IAE5B,MAAMc,SAAS,GAAG5G,iBAAiB,CAACJ,YAAY,CAACF,sBAAsB,CAACoG,SAAS,CAACoC,SAAS,CAAC,CAAC,CAAC;IAC9F,MAAMtE,OAAO,GAAG9C,IAAI,CAACgF,SAAS,EAAE,WAAW,CAAC;IAC5C,MAAMtD,WAAW,GAAG,MAAMqD,4BAA4B,CAAC;MAAEe,SAAS;MAAE,GAAGhD;IAAO,CAAE,CAAC;IAEjF,MAAMuE,OAAO,GAAGzI,sBAAsB,CAACoG,SAAS,CAACoC,SAAS,CAAC;IAC3D,MAAMJ,MAAM,GAAG,IAAIpH,iBAAiB,CAAC8B,WAAW,CAAC;IACjDsF,MAAM,CAACM,UAAU,CAACD,OAAO,CAAC;IAE1B,OAAO3F,WAAW;GACnB,MAAM;IAEL,MAAMoB,OAAO,GAAG9C,IAAI,CAACgF,SAAS,EAAE,YAAY,CAAC;IAC7C,MAAMtD,WAAW,GAAG,MAAMqD,4BAA4B,CAACjC,OAAO,CAAC;IAE/D,MAAMkE,MAAM,GAAG,IAAIpH,iBAAiB,CAAC8B,WAAW,CAAC;IACjD,IAAI6F,OAAO,GAAGvC,SAAS,CAACiB,UAAU;IAClC,KAAK,MAAMuB,GAAG,IAAIxC,SAAS,CAACyC,UAAU,EAAE;MACtC,MAAMC,MAAM,GAAG3I,iBAAiB,CAACyI,GAAG,CAAC;MACrCD,OAAO,GAAGA,OAAO,CAACI,MAAM,CAACC,EAAE,IAAIA,EAAE,KAAKxK,UAAU,CAACsK,MAAM,CAAC/D,IAAI,CAAC,CAAC;MAC9DqD,MAAM,CAACM,UAAU,CAAC1I,sBAAsB,CAAC4I,GAAG,CAAC,CAAC;;IAGhD,KAAK,MAAMA,GAAG,IAAID,OAAO,EAAE;MACzBP,MAAM,CAACa,YAAY,CAAC7I,kBAAkB,CAAC3B,UAAU,CAACmK,GAAG,CAAC,CAAC,CAAC;;IAG1D,OAAO9F,WAAW;;AAEtB;AAgDA,OAAO,eAAeoG,sBAAsBA,CAC1CpG,WAA8B,EAC9BrB,OAA2C;EAE3C,IACEqB,WAAW,CAACC,OAAO,CAACC,WAAW,KAAKxD,WAAW,CAAC2J,aAAa,IAC7DrG,WAAW,CAACC,OAAO,CAACC,WAAW,KAAKxD,WAAW,CAAC4J,sBAAsB,EACtE;IACA,MAAM,IAAIhH,KAAK,CACb,qDACE5C,WAAW,CAACA,WAAW,CAAC2J,aAAa,CACvC,gCAAgC3J,WAAW,CAACsD,WAAW,CAACC,OAAO,CAACC,WAAW,CAAC,EAAE,CAC/E;;EAGH,MAAMG,cAAc,GAAG;IACrBC,MAAM,EAAE;GACT;EAED,MAAMC,YAAY,GAAG;IACnBC,MAAM,EAAE,KAAK;IACbC,OAAO,EAAEJ;GACV;EAID,MAAMzB,cAAc,GAAG/C,aAAa,CAACgD,iBAAiB,CAACF,OAAO,aAAPA,OAAO,cAAPA,OAAO,GAAI+B,aAAa,CAACV,WAAW,CAAC,CAAC;EAC7F,MAAMlB,GAAG,GAAGF,cAAc,CAAC+B,4BAA4B,EAAE;EAEzD,MAAM3B,QAAQ,GAAG,MAAMJ,cAAc,CAACK,OAAO,CAACH,GAAG,EAAEyB,YAAY,CAAC;EAChE,IAAI,CAACvB,QAAQ,CAACE,EAAE,EAAE;IAChB,MAAMC,GAAG,GAAG,MAAMH,QAAQ,CAACI,IAAI,EAAE,CAACuC,KAAK,CAAC,MAAM,EAAE,CAAC;IACjD,MAAM,IAAIrC,KAAK,CACb,kDAAkDN,QAAQ,CAACO,MAAM,KAAKP,QAAQ,CAACQ,UAAU,wBAAwBV,GAAG,kCAAkCK,GAAG,GAAG,CAC7J;;EAEH,MAAMyB,aAAa,GAAG,MAAM5B,QAAQ,CAACI,IAAI,EAAE;EAC3C,MAAMyB,OAAO,GAAGjF,WAAW,CAACoE,WAAW,CAACc,SAAS,EAAE,CAACC,UAAU,EAAE,KAAK,CAAC;EACtE,MAAMC,OAAO,GAAGpF,WAAW,CAACgF,aAAa,EAAE,KAAK,CAAC;EACjD,OAAOI,OAAO,GAAGH,OAAO;AAC1B;AAWA,OAAO,eAAe0F,kBAAkBA,CACtCjD,SAAgC;EAEhC,MAAMqC,OAAO,GAAGzI,sBAAsB,CAACoG,SAAS,CAACoC,SAAS,CAAC;EAC3D,MAAMc,eAAe,GAAGpJ,YAAY,CAACuI,OAAO,CAAC;EAC7C,MAAMvB,SAAS,GAAG5G,iBAAiB,CAACgJ,eAAe,CAAC;EACpD,MAAMC,iBAAiB,GAAkC;IAAE,GAAGnD,SAAS;IAAEc;EAAS,CAAE;EACpF,MAAMpE,WAAW,GAAsB,MAAM0G,0BAA0B,CAACD,iBAAiB,CAAC;EAE1F,IAAInD,SAAS,CAACoC,SAAS,EAAE;IACvB,MAAMJ,MAAM,GAAG,IAAIpH,iBAAiB,CAAC8B,WAAW,CAAC;IACjDsF,MAAM,CAACM,UAAU,CAACD,OAAO,CAAC;;EAG5B,OAAO3F,WAAW;AACpB;AAEA,OAAO,eAAe0G,0BAA0BA,CAC9CpD,SAAwC;EAExC,MAAMC,cAAc,GAAG;IACrBC,GAAG,EAAE3D,MAAM,CAAC,CAAC,CAAC;IACdC,KAAK,EAAED,MAAM,CAAC,CAAC,CAAC;IAChBlB,OAAO,EAAE,IAAI7C,aAAa,EAAE;IAC5B2H,iBAAiB,EAAE9G,iBAAiB,CAAC+G,IAAI;IACzCE,SAAS,EAAE,KAAK;IAChB+C,cAAc,EAAE5J,cAAc,CAAC6J;GAChC;EAED,MAAMxF,OAAO,GAAGyC,MAAM,CAACC,MAAM,CAACP,cAAc,EAAED,SAAS,CAAC;EAExD,MAAMrD,OAAO,GAAGvC,0BAA0B,CACxC0D,OAAO,CAAC4B,YAAY,EACpB5B,OAAO,CAACyF,QAAQ,EAChBzF,OAAO,CAACuF,cAAc,CACvB;EAED,MAAMG,eAAe,GAAGtK,eAAe,CAAC2H,cAAc;EACtD,MAAM6B,MAAM,GAAG7I,qBAAqB,CAACiE,OAAO,CAACgD,SAAS,CAAC;EAEvD,IAAIH,aAAa,GAAyB,IAAI;EAE9C,MAAMC,iBAAiB,GAAG/H,gCAAgC,CACxD2K,eAAe,EACftJ,iBAAiB,CAACwI,MAAM,CAAC,EACzB5E,OAAO,CAACtB,KAAK,EACbsB,OAAO,CAACoC,GAAG,CACZ;EAED,IAAIpC,OAAO,CAACwC,SAAS,EAAE;IACrBK,aAAa,GAAG7H,mBAAmB,CAAC8H,iBAAiB,CAAC;GACvD,MAAM;IACLD,aAAa,GAAG5H,kBAAkB,CAAC6H,iBAAiB,CAAC;;EAGvD,MAAMvF,OAAO,GAAG9C,aAAa,CAACgD,iBAAiB,CAACuC,OAAO,CAACzC,OAAO,CAAC;EAEhE,MAAM6F,cAAc,GAAoB,EAAE;EAC1C,IAAIpD,OAAO,CAACoD,cAAc,IAAIpD,OAAO,CAACoD,cAAc,CAAC/B,MAAM,GAAG,CAAC,EAAE;IAC/DrB,OAAO,CAACoD,cAAc,CAACC,OAAO,CAACC,aAAa,IAAG;MAC7CF,cAAc,CAACG,IAAI,CAACD,aAAa,CAAC;IACpC,CAAC,CAAC;;EAEJ,MAAME,gBAAgB,GAAGxG,YAAY,CAACoG,cAAc,CAAC;EAErD,MAAMxE,WAAW,GAAG,IAAI7B,iBAAiB,CACvCQ,OAAO,CAACuE,OAAO,EACfe,aAAa,EACbhE,OAAO,EACP2E,gBAAgB,EAChBxD,OAAO,CAACqC,iBAAiB,EACzBrC,OAAO,CAACyD,UAAU,EAClBlG,OAAO,CAACmG,OAAO,CAChB;EAED,IAAIxB,SAAS,CAACE,GAAG,KAAKd,SAAS,IAAIY,SAAS,CAACE,GAAG,KAAK,IAAI,EAAE;IACzD,MAAMA,GAAG,GAAG,MAAMuB,kCAAkC,CAAC/E,WAAW,EAAErB,OAAO,CAAC;IAC1EqB,WAAW,CAACgF,MAAM,CAACxB,GAAG,CAAC;;EAGzB,IAAIF,SAAS,CAACxD,KAAK,KAAK4C,SAAS,IAAIY,SAAS,CAACxD,KAAK,KAAK,IAAI,EAAE;IAC7D,MAAMmF,cAAc,GAClB7D,OAAO,CAACzC,OAAO,CAACuE,OAAO,KAAKtG,kBAAkB,CAACuG,OAAO,GAClD1G,cAAc,CAACyI,gBAAgB,GAC/BzI,cAAc,CAAC0I,gBAAgB;IACrC,MAAMC,aAAa,GAAG7H,kBAAkB,CAAC0H,cAAc,EAAEe,MAAM,CAAC;IAChE,MAAMT,OAAO,GAAG,MAAM9G,QAAQ,CAAC2G,aAAa,EAAEhE,OAAO,CAACzC,OAAO,CAAC;IAC9DqB,WAAW,CAACwF,QAAQ,CAACD,OAAO,CAAC;;EAG/B,OAAOvF,WAAW;AACpB;AA8DA,OAAO,eAAe+G,4BAA4BA,CAChD/G,WAA8B,EAC9BrB,OAA2C;EAE3C,IAAIqB,WAAW,CAACC,OAAO,CAACC,WAAW,KAAKxD,WAAW,CAACsK,YAAY,EAAE;IAChE,MAAM,IAAI1H,KAAK,CACb,mDACE5C,WAAW,CAACA,WAAW,CAACsK,YAAY,CACtC,gCAAgCtK,WAAW,CAACsD,WAAW,CAACC,OAAO,CAACC,WAAW,CAAC,EAAE,CAC/E;;EAGH,MAAMG,cAAc,GAAG;IACrBC,MAAM,EAAE;GACT;EAED,MAAMC,YAAY,GAAG;IACnBC,MAAM,EAAE,KAAK;IACbC,OAAO,EAAEJ;GACV;EAID,MAAMzB,cAAc,GAAG/C,aAAa,CAACgD,iBAAiB,CAACF,OAAO,aAAPA,OAAO,cAAPA,OAAO,GAAI+B,aAAa,CAACV,WAAW,CAAC,CAAC;EAC7F,MAAMlB,GAAG,GAAGF,cAAc,CAAC+B,4BAA4B,EAAE;EAEzD,MAAM3B,QAAQ,GAAG,MAAMJ,cAAc,CAACK,OAAO,CAACH,GAAG,EAAEyB,YAAY,CAAC;EAChE,IAAI,CAACvB,QAAQ,CAACE,EAAE,EAAE;IAChB,MAAMC,GAAG,GAAG,MAAMH,QAAQ,CAACI,IAAI,EAAE,CAACuC,KAAK,CAAC,MAAM,EAAE,CAAC;IACjD,MAAM,IAAIrC,KAAK,CACb,gDAAgDN,QAAQ,CAACO,MAAM,KAAKP,QAAQ,CAACQ,UAAU,wBAAwBV,GAAG,kCAAkCK,GAAG,GAAG,CAC3J;;EAEH,MAAMyB,aAAa,GAAG,MAAM5B,QAAQ,CAACI,IAAI,EAAE;EAC3C,MAAMyB,OAAO,GAAGjF,WAAW,CAACoE,WAAW,CAACc,SAAS,EAAE,CAACC,UAAU,EAAE,KAAK,CAAC;EACtE,MAAMC,OAAO,GAAGpF,WAAW,CAACgF,aAAa,EAAE,KAAK,CAAC;EACjD,OAAOI,OAAO,GAAGH,OAAO;AAC1B;AASA,OAAO,eAAeoG,wBAAwBA,CAC5C3D,SAA4E;EAE5E,MAAMC,cAAc,GAAG;IACrBC,GAAG,EAAE3D,MAAM,CAAC,CAAC,CAAC;IACdC,KAAK,EAAED,MAAM,CAAC,CAAC,CAAC;IAChBlB,OAAO,EAAE,IAAI7C,aAAa,EAAE;IAC5B2H,iBAAiB,EAAE9G,iBAAiB,CAAC+G,IAAI;IACzCE,SAAS,EAAE;GACZ;EAED,MAAMxC,OAAO,GAAGyC,MAAM,CAACC,MAAM,CAACP,cAAc,EAAED,SAAS,CAAC;EAExD,MAAMrD,OAAO,GAAGxC,yBAAyB,CACvC2D,OAAO,CAAC8F,eAAe,EACvB9F,OAAO,CAAC4B,YAAY,EACpB5B,OAAO,CAAC+F,YAAY,EACpB/F,OAAO,CAACgG,YAAY,CACrB;EAED,IAAIhG,OAAO,aAAPA,OAAO,eAAPA,OAAO,CAAEiG,eAAe,EAAE;IAC5B,IAAIC,GAAe;IACnB,IAAI,OAAOlG,OAAO,CAACiG,eAAe,KAAK,SAAS,EAAE;MAChD,IAAIjG,OAAO,aAAPA,OAAO,eAAPA,OAAO,CAAEzC,OAAO,EAAE;QACpB2I,GAAG,GAAG,MAAMvE,MAAM,CAAC3B,OAAO,CAAC8F,eAAe,EAAE9F,OAAO,CAAC4B,YAAY,EAAE5B,OAAO,CAACzC,OAAO,CAAC;OACnF,MAAM;QACL,MAAM,IAAIW,KAAK,CAAC,+DAA+D,CAAC;;KAEnF,MAAM;MACLgI,GAAG,GAAGlG,OAAO,CAACiG,eAAe;;IAG/BrK,oBAAoB,CAACiD,OAAO,EAAEqH,GAAG,CAAC;;EAGpC,IAAIpD,iBAAiB,GAA6B,IAAI;EACtD,IAAID,aAAa,GAAyB,IAAI;EAE9C,IAAI,WAAW,IAAI7C,OAAO,EAAE;IAE1B8C,iBAAiB,GAAG/H,gCAAgC,CAClDK,eAAe,CAAC2H,cAAc,EAC9B/C,OAAO,CAACgD,SAAS,EACjBhD,OAAO,CAACtB,KAAK,EACbsB,OAAO,CAACoC,GAAG,CACZ;GACF,MAAM;IAELU,iBAAiB,GAAGhI,+BAA+B,CACjDM,eAAe,CAAC6H,aAAa,EAC7BjD,OAAO,CAACkD,aAAa,EACrBlD,OAAO,CAACmD,UAAU,EAClBnD,OAAO,CAACtB,KAAK,EACbsB,OAAO,CAACoC,GAAG,CACZ;;EAGH,IAAIpC,OAAO,CAACwC,SAAS,EAAE;IACrBK,aAAa,GAAG7H,mBAAmB,CAAC8H,iBAAiB,CAAC;GACvD,MAAM;IACLD,aAAa,GAAG5H,kBAAkB,CAAC6H,iBAAiB,CAAC;;EAGvD,MAAMvF,OAAO,GAAG9C,aAAa,CAACgD,iBAAiB,CAACuC,OAAO,CAACzC,OAAO,CAAC;EAEhE,MAAM6F,cAAc,GAAoB,EAAE;EAC1C,IAAIpD,OAAO,CAACoD,cAAc,IAAIpD,OAAO,CAACoD,cAAc,CAAC/B,MAAM,GAAG,CAAC,EAAE;IAC/DrB,OAAO,CAACoD,cAAc,CAACC,OAAO,CAACC,aAAa,IAAG;MAC7CF,cAAc,CAACG,IAAI,CAACD,aAAa,CAAC;IACpC,CAAC,CAAC;;EAGJ,MAAME,gBAAgB,GAAGxG,YAAY,CAACoG,cAAc,CAAC;EACrD,MAAMxE,WAAW,GAAG,IAAI7B,iBAAiB,CACvCQ,OAAO,CAACuE,OAAO,EACfe,aAAa,EACbhE,OAAO,EACP2E,gBAAgB,EAChBxD,OAAO,CAACqC,iBAAiB,EACzBrC,OAAO,CAACyD,UAAU,EAClBlG,OAAO,CAACmG,OAAO,CAChB;EAED,IAAIxB,SAAS,CAACE,GAAG,KAAKd,SAAS,IAAIY,SAAS,CAACE,GAAG,KAAK,IAAI,EAAE;IACzD,MAAMA,GAAG,GAAG,MAAMuB,kCAAkC,CAAC/E,WAAW,EAAErB,OAAO,CAAC;IAC1EqB,WAAW,CAACgF,MAAM,CAACxB,GAAG,CAAC;;EAGzB,IAAIF,SAAS,CAACxD,KAAK,KAAK4C,SAAS,IAAIY,SAAS,CAACxD,KAAK,KAAK,IAAI,EAAE;IAC7D,MAAMmF,cAAc,GAClBtG,OAAO,CAACuE,OAAO,KAAKtG,kBAAkB,CAACuG,OAAO,GAC1C1G,cAAc,CAACyI,gBAAgB,GAC/BzI,cAAc,CAAC0I,gBAAgB;IACrC,MAAMC,aAAa,GAAGnJ,UAAU,CAACgJ,cAAc,EAAEjF,WAAW,CAACqF,IAAI,CAACnB,iBAAkB,CAACoB,MAAM,CAAC;IAC5F,MAAMC,OAAO,GAAG,MAAM9G,QAAQ,CAAC2G,aAAa,EAAEzG,OAAO,CAAC;IACtDqB,WAAW,CAACwF,QAAQ,CAACD,OAAO,CAAC;;EAG/B,OAAOvF,WAAW;AACpB;AAWA,OAAO,eAAeuH,gBAAgBA,CACpCjE,SAAwE;EAExE,IAAI,WAAW,IAAIA,SAAS,EAAE;IAC5B,MAAMc,SAAS,GAAG5G,iBAAiB,CAACJ,YAAY,CAACF,sBAAsB,CAACoG,SAAS,CAACoC,SAAS,CAAC,CAAC,CAAC;IAC9F,MAAMtE,OAAO,GAAG9C,IAAI,CAACgF,SAAS,EAAE,WAAW,CAAC;IAC5C,MAAMtD,WAAW,GAAG,MAAMiH,wBAAwB,CAAC;MAAE7C,SAAS;MAAE,GAAGhD;IAAO,CAAE,CAAC;IAE7E,MAAMuE,OAAO,GAAGzI,sBAAsB,CAACoG,SAAS,CAACoC,SAAS,CAAC;IAC3D,MAAMJ,MAAM,GAAG,IAAIpH,iBAAiB,CAAC8B,WAAW,CAAC;IACjDsF,MAAM,CAACM,UAAU,CAACD,OAAO,CAAC;IAE1B,OAAO3F,WAAW;GACnB,MAAM;IACL,MAAMoB,OAAO,GAAG9C,IAAI,CAACgF,SAAS,EAAE,YAAY,CAAC;IAC7C,MAAMtD,WAAW,GAAG,MAAMiH,wBAAwB,CAAC7F,OAAO,CAAC;IAE3D,MAAMkE,MAAM,GAAG,IAAIpH,iBAAiB,CAAC8B,WAAW,CAAC;IACjD,IAAI6F,OAAO,GAAGvC,SAAS,CAACiB,UAAU;IAClC,KAAK,MAAMuB,GAAG,IAAIxC,SAAS,CAACyC,UAAU,EAAE;MACtC,MAAMC,MAAM,GAAG3I,iBAAiB,CAACyI,GAAG,CAAC;MACrCD,OAAO,GAAGA,OAAO,CAACI,MAAM,CAACC,EAAE,IAAIA,EAAE,KAAKxK,UAAU,CAACsK,MAAM,CAAC/D,IAAI,CAAC,CAAC;MAC9DqD,MAAM,CAACM,UAAU,CAAC1I,sBAAsB,CAAC4I,GAAG,CAAC,CAAC;;IAGhD,KAAK,MAAMA,GAAG,IAAID,OAAO,EAAE;MACzBP,MAAM,CAACa,YAAY,CAAC7I,kBAAkB,CAAC3B,UAAU,CAACmK,GAAG,CAAC,CAAC,CAAC;;IAG1D,OAAO9F,WAAW;;AAEtB;AAWA,OAAM,SAAUwH,4BAA4BA,CAC1C9I,OAAe,EACf+I,aAAoC,EACpCzD,MAAmB;EAEnB,OAAOjG,sBAAsB,CAACE,uBAAuB,CAACS,OAAO,CAAC,EAAE+I,aAAa,EAAEzD,MAAM,CAAC;AACxF;AAcA,OAAM,SAAU0D,4BAA4BA,CAC1ChJ,OAAe,EACfsE,YAAoB,EACpByE,aAAoC,EACpCzD,MAAmB;EAEnB,OAAOjG,sBAAsB,CAC3BC,uBAAuB,CAACU,OAAO,EAAEsE,YAAY,CAAC,EAC9CyE,aAAa,EACbzD,MAAM,CACP;AACH;AAYA,OAAM,SAAU2D,iCAAiCA,CAC/CjJ,OAAe,EACf+I,aAAoC,EACpCzD,MAAmB,EACnB4D,SAA6B;EAE7B,OAAO/J,2BAA2B,CAChCI,uBAAuB,CAACS,OAAO,CAAC,EAChC+I,aAAa,EACbzD,MAAM,EACN4D,SAAS,CACV;AACH;AAaA,OAAM,SAAUC,iCAAiCA,CAC/CnJ,OAAe,EACfsE,YAAoB,EACpByE,aAAoC,EACpCzD,MAAmB,EACnB4D,SAA6B;EAE7B,OAAO/J,2BAA2B,CAChCG,uBAAuB,CAACU,OAAO,EAAEsE,YAAY,CAAC,EAC9CyE,aAAa,EACbzD,MAAM,EACN4D,SAAS,CACV;AACH;AAcA,OAAM,SAAUE,oCAAoCA,CAClDpJ,OAAe,EACf+I,aAAuC,EACvCG,SAA6B,EAC7BG,OAAqB;EAErB,OAAOjK,8BAA8B,CACnCG,uBAAuB,CAACS,OAAO,CAAC,EAChC+I,aAAa,EACbG,SAAS,EACTG,OAAO,CACR;AACH;AAeA,OAAM,SAAUC,oCAAoCA,CAClDtJ,OAAe,EACfsE,YAAoB,EACpByE,aAAuC,EACvCG,SAA6B,EAC7BG,OAAqB;EAErB,OAAOjK,8BAA8B,CACnCE,uBAAuB,CAACU,OAAO,EAAEsE,YAAY,CAAC,EAC9CyE,aAAa,EACbG,SAAS,EACTG,OAAO,CACR;AACH;AAkCA,OAAO,eAAeE,oBAAoBA,CACxCC,uBAAgD;EAEhD,MAAM3E,cAAc,GAAG;IACrB5E,OAAO,EAAE,IAAI7C,aAAa;GAC3B;EAED,MAAMsF,OAAO,GAAGyC,MAAM,CAACC,MAAM,CAACP,cAAc,EAAE2E,uBAAuB,CAAC;EAEtE,MAAM;IAAElF,YAAY;IAAEkE,eAAe;IAAEC,YAAY;IAAEC,YAAY;IAAEhC;EAAa,CAAE,GAAGhE,OAAO;EAE5F,MAAMzC,OAAO,GAAG9C,aAAa,CAACgD,iBAAiB,CAACuC,OAAO,CAACzC,OAAO,CAAC;EAChE,MAAMG,GAAG,GAAGH,OAAO,CAACwJ,6BAA6B,CAACjB,eAAe,EAAElE,YAAY,EAAEmE,YAAY,CAAC;EAE9F,MAAMiB,IAAI,GAAGhB,YAAY,CAACiB,GAAG,CAACC,GAAG,IAAIjK,OAAO,CAACiK,GAAG,CAAC,CAAC;EAElD,MAAMjH,IAAI,GAAG1B,IAAI,CAAC2B,SAAS,CAAC;IAC1BiH,MAAM,EAAEnD,aAAa;IACrB5C,SAAS,EAAE4F;GACZ,CAAC;EAEF,MAAMpJ,QAAQ,GAAG,MAAML,OAAO,CAACM,OAAO,CAACH,GAAG,EAAE;IAC1C0B,MAAM,EAAE,MAAM;IACda,IAAI;IACJZ,OAAO,EAAE;MACP,cAAc,EAAE;;GAEnB,CAAC;EAEF,IAAI,CAACzB,QAAQ,CAACE,EAAE,EAAE;IAChB,MAAMC,GAAG,GAAG,MAAMH,QAAQ,CAACI,IAAI,EAAE,CAACuC,KAAK,CAAC,MAAM,EAAE,CAAC;IACjD,MAAM,IAAIrC,KAAK,CACb,8CAA8CN,QAAQ,CAACO,MAAM,KAAKP,QAAQ,CAACQ,UAAU,wBAAwBV,GAAG,kCAAkCK,GAAG,GAAG,CACzJ;;EAGH,OAAOH,QAAQ,CAAC0C,IAAI,EAAE,CAAC8G,IAAI,CAACC,YAAY,IAAIlK,qBAAqB,CAACkK,YAAY,CAAC,CAAC;AAClF;AAsBA,OAAO,eAAeC,mBAAmBA,CACvCC,0BAAsD;EAEtD,MAAMpF,cAAc,GAAG;IACrB5E,OAAO,EAAE,IAAI7C,aAAa;GAC3B;EACD,MAAM;IAAEoL,eAAe;IAAElE,YAAY;IAAE4F,OAAO;IAAEC,MAAM;IAAElK;EAAO,CAAE,GAAGkF,MAAM,CAACC,MAAM,CAC/EP,cAAc,EACdoF,0BAA0B,CAC3B;EAED,MAAM/J,cAAc,GAAG/C,aAAa,CAACgD,iBAAiB,CAACF,OAAO,CAAC;EAC/D,MAAMG,GAAG,GAAGF,cAAc,CAACkK,cAAc,CAAC5B,eAAe,EAAElE,YAAY,EAAE4F,OAAO,CAAC;EAEjF,MAAMG,kBAAkB,GAAGxM,WAAW,CAACsM,MAAM,CAAC;EAC9C,MAAMG,gBAAgB,GAAG,IAAI,GAAGtN,UAAU,CAACqN,kBAAkB,CAAC;EAE9D,MAAMxI,YAAY,GAAgB;IAChCC,MAAM,EAAE,MAAM;IACdC,OAAO,EAAE;MACP,cAAc,EAAE,kBAAkB;MAClCH,MAAM,EAAE;KACT;IACDe,IAAI,EAAE1B,IAAI,CAAC2B,SAAS,CAAC0H,gBAAgB;GACtC;EAED,MAAMhK,QAAQ,GAAG,MAAMJ,cAAc,CAACK,OAAO,CAACH,GAAG,EAAEyB,YAAY,CAAC;EAChE,IAAI,CAACvB,QAAQ,CAACE,EAAE,EAAE;IAChB,MAAMC,GAAG,GAAG,MAAMH,QAAQ,CAACI,IAAI,EAAE,CAACuC,KAAK,CAAC,MAAM,EAAE,CAAC;IACjD,MAAM,IAAIrC,KAAK,CACb,qCAAqCsJ,OAAO,kBAAkB5F,YAAY,gBAAgBkE,eAAe,oBAAoB8B,gBAAgB,eAAehK,QAAQ,CAACO,MAAM,KAAKP,QAAQ,CAACQ,UAAU,wBAAwBV,GAAG,kCAAkCK,GAAG,GAAG,CACvQ;;EAEH,MAAM8J,YAAY,GAAG,MAAMjK,QAAQ,CAACI,IAAI,EAAE;EAC1C,MAAMqJ,YAAY,GAAsB9I,IAAI,CAACC,KAAK,CAACqJ,YAAY,CAAC;EAChE,IAAI,CAACR,YAAY,CAACxG,IAAI,EAAE;IACtB,MAAM,IAAI3C,KAAK,CACb,qCAAqCsJ,OAAO,kBAAkB5F,YAAY,gBAAgBkE,eAAe,oBAAoB8B,gBAAgB,eAAehK,QAAQ,CAACO,MAAM,KAAKP,QAAQ,CAACQ,UAAU,wBAAwBV,GAAG,mCAAmCmK,YAAY,GAAG,CACjR;;EAEH,IAAIC,cAAiB;EACrB,IAAI;IACFA,cAAc,GAAG5M,aAAa,CAAImM,YAAY,CAACxG,IAAI,CAAC;GACrD,CAAC,OAAO5C,KAAK,EAAE;IACd,MAAM,IAAIC,KAAK,CAAC,sCAAsCmJ,YAAY,CAACxG,IAAI,MAAM5C,KAAK,EAAE,CAAC;;EAEvF,OAAO6J,cAAc;AACvB;AA6BA,OAAO,eAAeC,kBAAkBA,CACtCC,cAAkC;EAElC,MAAM7F,cAAc,GAAG;IACrBC,GAAG,EAAE,CAAgB;IACrB6F,YAAY,EAAE,CAAgB;IAC9BC,sBAAsB,EAAE9M,eAAe,CAAC2H,cAAmC;IAC3ExF,OAAO,EACLyK,cAAc,CAACpJ,WAAW,CAACkD,OAAO,KAAKtG,kBAAkB,CAACuG,OAAO,GAC7D,IAAIrH,aAAa,EAAE,GACnB,IAAIC,aAAa;GACxB;EAED,MAAMqF,OAAO,GAAGyC,MAAM,CAACC,MAAM,CAACP,cAAc,EAAE6F,cAAc,CAAC;EAE7D,MAAMzK,OAAO,GAAG9C,aAAa,CAACgD,iBAAiB,CAACuC,OAAO,CAACzC,OAAO,CAAC;EAChE,MAAM4K,aAAa,GAAGlM,iBAAiB,CAAC+D,OAAO,CAACoI,iBAAiB,CAAC;EAElE,IAAIJ,cAAc,CAAC5F,GAAG,KAAKd,SAAS,IAAI0G,cAAc,CAAC5F,GAAG,KAAK,IAAI,EAAE;IACnE,IAAIiG,KAAK,GAAG,CAAC;IACb,QAAQrI,OAAO,CAACpB,WAAW,CAACC,OAAO,CAACC,WAAW;MAC7C,KAAKxD,WAAW,CAACyD,aAAa;MAC9B,KAAKzD,WAAW,CAAC2J,aAAa;MAC9B,KAAK3J,WAAW,CAAC4J,sBAAsB;MACvC,KAAK5J,WAAW,CAACsK,YAAY;QAC3B,MAAM7F,YAAY,GAAGuI,6BAA6B,CAACtI,OAAO,CAACpB,WAAW,CAAC;QACvE,IAAI;UACFyJ,KAAK,GAAG,CAAC,MAAMxI,mBAAmB,CAACG,OAAO,CAACpB,WAAW,CAACC,OAAO,EAAEkB,YAAY,EAAExC,OAAO,CAAC,EAAE,CAAC,CAAC,CACvF6E,GAAG;SACP,CAAC,OAAOZ,CAAC,EAAE;UACV,MAAMA,CAAC;;QAET;MACF;QACE,MAAM,IAAItD,KAAK,CACb,6DACE5C,WAAW,CAAC0E,OAAO,CAACpB,WAAW,CAACC,OAAO,CAACC,WAAW,CACrD,EAAE,CACH;;IAELkB,OAAO,CAACpB,WAAW,CAACgF,MAAM,CAACyE,KAAK,CAAC;IACjCrI,OAAO,CAACoC,GAAG,GAAGiG,KAAK;;EAGrB,IAAIL,cAAc,CAACC,YAAY,KAAK3G,SAAS,IAAI0G,cAAc,CAACC,YAAY,KAAK,IAAI,EAAE;IACrF,MAAMpE,cAAc,GAClBtG,OAAO,CAACuE,OAAO,KAAKtG,kBAAkB,CAACuG,OAAO,GAC1C1G,cAAc,CAACyI,gBAAgB,GAC/BzI,cAAc,CAAC0I,gBAAgB;IAErC,MAAMC,aAAa,GAAG7H,kBAAkB,CAAC0H,cAAc,EAAEsE,aAAa,CAAC;IACvE,MAAMF,YAAY,GAAG,MAAM5K,QAAQ,CAAC2G,aAAa,EAAEzG,OAAO,CAAC;IAC3DyC,OAAO,CAACiI,YAAY,GAAGA,YAAY;;EAGrC,MAAMM,wBAAwB,GAAGxN,gCAAgC,CAC/DiF,OAAO,CAACkI,sBAAsB,EAC9B9L,iBAAiB,CAAC+L,aAAa,CAAC,EAChCnI,OAAO,CAACiI,YAAY,EACpBjI,OAAO,CAACoC,GAAG,CACZ;EAEDpC,OAAO,CAACpB,WAAW,CAAC4J,UAAU,CAACD,wBAAwB,CAAC;EAExD,MAAMhE,OAAO,GAAGzI,sBAAsB,CAACkE,OAAO,CAACoI,iBAAiB,CAAC;EACjE,MAAMlE,MAAM,GAAGpH,iBAAiB,CAAC2L,mBAAmB,CAClDzI,OAAO,CAACpB,WAAW,EACnB2J,wBAAwB,CACzB;EACDrE,MAAM,CAACwE,WAAW,CAACnE,OAAO,CAAC;EAE3B,OAAOL,MAAM,CAACtF,WAAW;AAC3B;AAWA,OAAM,SAAU0J,6BAA6BA,CAAC1J,WAA8B;EAC1E,MAAM+J,QAAQ,GAAG/J,WAAW,CAACqF,IAAI,CAACnB,iBAAiB,CAAC6F,QAAQ;EAE5D,MAAMC,iBAAiB,GAAG,CAACxN,eAAe,CAAC6H,aAAa,EAAE7H,eAAe,CAACyN,cAAc,CAAC;EAGzF,IAAID,iBAAiB,CAACE,QAAQ,CAACH,QAAQ,CAAC,EAAE;IACxC,MAAMI,yBAAyB,GAA8BnK,WAAW,CAACqF,IAAI,CAC1EnB,iBAA8C;IAGjD,MAAMkG,kBAAkB,GAAGD,yBAAyB,CAACE,MAAM,CAACpE,MAAM,CAChEqE,KAAK,IAAIA,KAAK,CAACC,QAAQ,CAACC,IAAI,KAAK1N,iBAAiB,CAAC2N,gBAAgB,CACpE,CAAChI,MAAM;IAIR,MAAMiI,oBAAoB,GACxB,CAACP,yBAAyB,CAACQ,kBAAkB,GAAGP,kBAAkB,KACjEvN,kCAAkC,GAAG,CAAC,CAAC;IAE1C,OAAOmD,WAAW,CAACc,SAAS,EAAE,CAACC,UAAU,GAAG2J,oBAAoB;GACjE,MAAM;IAGL,OAAO1K,WAAW,CAACc,SAAS,EAAE,CAACC,UAAU;;AAE7C;AAOA,OAAO,eAAegE,kCAAkCA,CACtD/E,WAA8B,EAC9BrB,OAAsB;EAEtB,IAAI;IACF,MAAMwC,YAAY,GAAGuI,6BAA6B,CAAC1J,WAAW,CAAC;IAC/D,OAAO,CAAC,MAAMiB,mBAAmB,CAACjB,WAAW,CAACC,OAAO,EAAEkB,YAAY,EAAExC,OAAO,CAAC,EAAE,CAAC,CAAC,CAAC6E,GAAG;GACtF,CAAC,OAAOnE,KAAK,EAAE;IACd,IAAIA,KAAK,YAAYpC,wBAAwB,EAAE;MAC7C,OAAO,MAAMmD,sBAAsB,CAACJ,WAAW,EAAErB,OAAO,CAAC;;IAE3D,MAAMU,KAAK;;AAEf"},"metadata":{},"sourceType":"module","externalDependencies":[]}